<!DOCTYPE html>
<html lang="en">
<head>

	<!-- Firebase (compat builds for simplicity) -->
	<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
	<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>


  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>German Trainer</title>
  <style>
    :root{
      --bg:#0f1115; --text:#eaeaea; --muted:#9aa6b2; --card:#171b23; --border:#2a3240; --input:#0f1620;
      --btn:#243042; --btn-hover:#2a3a50; --ok:#22c55e; --bad:#f97373;
      --der:#7fb3ff; --der-text:#0b2139; --die:#ff9aa2; --die-text:#3a0b12; --das:#9be7a1; --das-text:#0d2a14;
    }
    *{box-sizing:border-box}
    body{font-family:Arial,sans-serif;margin:0;padding:10px;background:var(--bg);color:var(--text)}
    .container{max-width:500px;margin:auto;padding:10px}
    h1{font-size:1.8em;text-align:center;margin-bottom:10px}
    #level{text-align:center;margin-bottom:15px;font-size:1.1em;color:var(--muted)}
    .card{background:var(--card);border-radius:12px;padding:15px;box-shadow:0 2px 6px rgba(0,0,0,.35);border:1px solid var(--border)}

    .button-row{display:flex;gap:8px}
    .article-btn{flex:1 1 0;padding:12px 0;font-size:16px;border-radius:10px;cursor:pointer;border:1px solid var(--border);background:#202734;color:var(--text)}
    #btnDer.selected{background:var(--der);color:var(--der-text);border-color:#6aa6ff}
    #btnDie.selected{background:var(--die);color:var(--die-text);border-color:#ff8a93}
    #btnDas.selected{background:var(--das);color:var(--das-text);border-color:#86d892}

    input{width:48%;padding:12px;margin:5px 1%;font-size:16px;border-radius:8px;border:1px solid var(--border);background:var(--input);color:var(--text)}
    input::placeholder{color:#7b879a}
    input:focus{outline:2px solid #3b82f680;border-color:#3b82f6}

    button{padding:12px;margin:5px 1%;font-size:16px;border-radius:8px;border:1px solid var(--border);background:var(--btn);color:var(--text);cursor:pointer}
    button:hover{background:var(--btn-hover)}

    #feedback{margin-top:5px;font-size:1em}
    #example{margin-top:6px;font-size:.95em;color:var(--muted)}
    #nextBtn{display:none;width:100%}
    #status{margin-top:10px;font-size:.9em;color:var(--muted);white-space:pre-wrap}
  </style>
  
  <style>
    /* === Additive styles for Verbs UI === */
    #mode-switch { margin: 12px 0; display: flex; gap: 8px; flex-wrap: wrap; }
    #mode-switch .mode-btn { padding: 6px 10px; border: 1px solid #ccc; background: #f8f8f8; cursor: pointer; border-radius: 6px; }
    #mode-switch .mode-btn.active { background: #e8f2ff; border-color: #5b9cff; }
  
    #verbs-card { border: 1px solid #e5e5e5; border-radius: 10px; padding: 16px; margin: 8px 0 16px; background: #fff; }
    #verbs-card[hidden] { display: none; }
    #verbs-card .prompt { font-size: 20px; font-weight: 600; margin-bottom: 8px; }
  
    .aux-toggle { display: flex; align-items: center; gap: 8px; margin: 8px 0; }
    .aux-btn { padding: 6px 10px; border: 1px solid #ccc; background: #fafafa; border-radius: 6px; cursor: pointer; }
    .aux-btn.selected { background: #e8f2ff; border-color: #5b9cff; }
    .badge { display: inline-block; padding: 2px 8px; border-radius: 999px; border: 1px solid #5b9cff; color: #1b62cf; font-size: 12px; }
  
    .praesens-grid { display: grid; grid-template-columns: repeat(2, minmax(200px, 1fr)); gap: 8px 16px; margin: 10px 0; }
    .praesens-grid div { display: flex; align-items: center; gap: 6px; }
    .praesens-grid input, #verbs-inf, #verbs-partizip { width: 100%; padding: 6px 8px; }
  
    .result-ok { border-color: #29a36a !important; background: #f0fff7 !important; }
    .result-bad { border-color: #d9534f !important; background: #fff5f5 !important; }
  
    #verbs-actions { display: flex; gap: 8px; margin-top: 12px; }
    #verbs-actions button { padding: 8px 12px; border-radius: 6px; border: 1px solid #ccc; background: #f8f8f8; cursor: pointer; }
    #verbs-feedback { margin-top: 10px; font-size: 14px; }
  </style>
  
  <style>
    /* ===== Global dark theme (opt-in via .dark on <body>) ===== */
    body.dark { background: #0b0d10; color: #e8eaed; }
  
    /* try to harmonize common elements if they exist */
    body.dark input, body.dark select, body.dark button, body.dark textarea {
      background: #111418; color: #e8eaed; border: 1px solid #2a2f36;
    }
    body.dark .card, body.dark .panel, body.dark .box {
      background: #0f1216; border: 1px solid #2a2f36; color: #e8eaed;
    }
    body.dark a { color: #96b7ff; }
  
    /* ===== Verbs UI dark styles ===== */
    body.dark #mode-switch .mode-btn {
      background: #12151a; border-color: #2a2f36; color: #e8eaed;
    }
    body.dark #mode-switch .mode-btn.active {
      background: #162036; border-color: #3b6ad9;
    }
    body.dark #verbs-card {
      background: #0f1216; border-color: #2a2f36;
    }
    body.dark .aux-btn {
      background: #12151a; border-color: #2a2f36; color: #e8eaed;
    }
    body.dark .aux-btn.selected {
      background: #162036; border-color: #3b6ad9;
    }
    body.dark .badge {
      border-color: #3b6ad9; color: #9bb8ff;
    }
    /* check result colors tuned for dark bg */
    body.dark .result-ok { border-color: #2fa97b !important; background: #0f1b16 !important; }
    body.dark .result-bad { border-color: #e66b6b !important; background: #1a1111 !important; }
  </style>
  
  <style>
	  /* Orange = correct choice (when user chose a different one), Red = user's wrong choice */
	  .choice-correct { border-color:#f59e0b !important; box-shadow:0 0 0 2px #f59e0b inset !important; }
	  .choice-wrong   { border-color:#ef4444 !important; box-shadow:0 0 0 2px #ef4444 inset !important; }
	  body.dark .choice-correct { border-color:#f59e0b !important; box-shadow:0 0 0 2px #f59e0b inset !important; }
	  body.dark .choice-wrong   { border-color:#e66b6b !important; box-shadow:0 0 0 2px #e66b6b inset !important; }
	</style>


  <style>
    #verbs-gov { margin: 10px 0 6px; display: grid; gap: 10px; }
    #verbs-gov .gov-row { display: grid; grid-template-columns: 110px 1fr; gap: 12px; align-items: center; }
    .refl-toggle { display: flex; gap: 8px; align-items: center; }
    .refl-btn { padding: 6px 10px; border: 1px solid #ccc; background: #fafafa; border-radius: 6px; cursor: pointer; }
    .refl-btn.selected { background: #e8f2ff; border-color: #5b9cff; }
  
    /* dark mode versions */
    body.dark #verbs-gov select,
    body.dark .refl-btn { background: #12151a; border-color: #2a2f36; color: #e8eaed; }
    body.dark .refl-btn.selected { background: #162036; border-color: #3b6ad9; }
  </style>

  <style>    
    /* Adj/Adv card styles (reuse look of verbs) */
    #adjadv-card { border: 1px solid var(--border); border-radius: 10px; padding: 16px; margin: 8px 0 16px; background: var(--card); }
    #adjadv-card[hidden] { display: none; }
    #adjadv-card .prompt { font-size: 20px; font-weight: 600; margin-bottom: 8px; }
    #adjadv-card input { width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 8px; background: var(--input); color: var(--text); }
    #adjadv-card .result-ok { border-color: #29a36a !important; background: #0f1b16 !important; }
    #adjadv-card .result-bad { border-color: #d9534f !important; background: #1a1111 !important; }
    .muted { color: var(--muted); }
  </style>

  <style>
    /* Make verbs inputs truly full width */
    #verbs-card .praesens-list { 
      grid-template-columns: 70px 1fr;  /* slimmer label column, more room for input */
    }
  
    /* Force width for all text inputs inside the verbs card */
    #verbs-card input[type="text"],
    #verbs-card input[list],
    #verbs-card input:not([type]),
    #verbs-gov input,
    #verbs-card .praesens-list input {
      width: 100% !important;
      box-sizing: border-box;
    }
  
    /* Optional: make the preposition row align perfectly */
    #verbs-gov .gov-row { 
      grid-template-columns: 110px 1fr; 
    }
  
    /* If some global CSS sets small widths, this beats it */
    #verbs-card input { 
      min-width: 0; 
      display: block; 
    }
  </style>

  
  <style>
    /* Vertical two-column label/input layout */
    .praesens-list {
      display: grid;
      grid-template-columns: 110px 1fr;
      row-gap: 10px;
      column-gap: 12px;
      margin: 12px 0;
      align-items: center;
    }
    .praesens-list label { opacity: 0.9; }
  
    /* Make verbs buttons dark (override whites) */
    body.dark #verbs-actions button {
      background: #12151a !important;
      border-color: #2a2f36 !important;
      color: #e8eaed !important;
    }
    body.dark #verbs-actions button:hover {
      background: #162036 !important;
      border-color: #3b6ad9 !important;
    }
  
    /* Ensure inputs match dark styling */
    body.dark #verbs-card input {
      background: #111418;
      color: #e8eaed;
      border: 1px solid #2a2f36;
    }
  </style>
  
 

  
  <style>
	  .past-row { display: grid; grid-template-columns: 110px 1fr; gap: 12px; align-items: center; margin: 10px 0; }
	  .case-toggle { display: flex; gap: 8px; align-items: center; }
	  .case-btn { padding: 6px 10px; border: 1px solid #ccc; background: #fafafa; border-radius: 6px; cursor: pointer; }
	  .case-btn.selected { background: #e8f2ff; border-color: #5b9cff; }

	  body.dark .case-btn { background: #12151a; border-color: #2a2f36; color: #e8eaed; }
	  body.dark .case-btn.selected { background: #162036; border-color: #3b6ad9; }
	</style>

	<style>#wordImage{display:none!important}</style>


</head>
<body>

	<script>
	// Early global stub (safe). If you define it later, that one will override.
	window.isKapitelMixMode = window.isKapitelMixMode || function(){
	  try{
		return (window.currentDataset?.key === 'kapitel') &&
			   ((typeof getMode==='function' ? getMode() : window.mode) === 'mix');
	  }catch(_){ return false; }
	};
	</script>


    <div id="mode-switch">
    <button class="mode-btn" data-mode="vocab">Vocab</button>
    <button class="mode-btn" data-mode="verbs">Verbs</button>
    <button class="mode-btn" data-mode="adjadv">Adj/Adv</button>
    <button class="mode-btn" data-mode="preps">Preps</button>
    <button class="mode-btn" data-mode="mix">Mix</button>
  </div>


  <div id="verbs-card" hidden>
    <div class="prompt" id="verbs-english">to go</div>

    <label for="verbs-inf">German infinitive</label>
    <input id="verbs-inf" autocomplete="off" />

    <div class="aux-toggle">
      <span>Auxiliary:</span>
      <button type="button" class="aux-btn" data-aux="haben">haben</button>
      <button type="button" class="aux-btn" data-aux="sein">sein</button>
      <span id="verbs-aux-badge" class="badge" style="display:none;"></span>
    </div>

    <!-- === Verb governance (preposition + reflexive) === -->
    <div id="verbs-gov">
      <div class="gov-row" id="verbs-prep-row">
		  <label for="verbs-prep">Preposition</label>
		  <input id="verbs-prep" list="verbs-prep-options" placeholder="e.g., auf" autocomplete="off" />
		  <datalist id="verbs-prep-options">
			<option value="an"></option>
			<option value="auf"></option>
			<option value="aus"></option>
			<option value="bei"></option>
			<option value="fÃ¼r"></option>
			<option value="gegen"></option>
			<option value="in"></option>
			<option value="mit"></option>
			<option value="nach"></option>
			<option value="Ã¼ber"></option>
			<option value="um"></option>
			<option value="von"></option>
			<option value="zu"></option>
		  </datalist>
		</div>

		<div class="gov-row">
		  <label>Case after verb</label>
		  <div class="case-toggle">
			<button type="button" class="case-btn" data-case="inf">Inf</button>
			<button type="button" class="case-btn" data-case="akk">Akk</button>
			<button type="button" class="case-btn" data-case="dat">Dat</button>
		  </div>
		</div>

    
      <div class="gov-row">
		  <label>Reflexive?</label>
		  <div class="refl-toggle">
			<button type="button" class="refl-btn" data-refl="no">No</button>
			<button type="button" class="refl-btn" data-refl="yes">Yes</button>
		  </div>
		</div>

    </div>

    
    <div class="praesens-list">
      <label for="verbs-p-ich">ich</label>
      <input id="verbs-p-ich" autocomplete="off">
    
      <label for="verbs-p-du">du</label>
      <input id="verbs-p-du" autocomplete="off">
    
      <label for="verbs-p-er">er/sie/es</label>
      <input id="verbs-p-er" autocomplete="off">
    
      <label for="verbs-p-ihr">ihr</label>
      <input id="verbs-p-ihr" autocomplete="off">
    </div>

	<!-- Simple past -->
	<div class="past-row">
	  <label for="verbs-past">PrÃ¤teritum</label>
	  <input id="verbs-past" placeholder="z. B. ging" autocomplete="off">
	</div>

	<!-- Perfekt line -->
    <div class="perfekt">
      ich <span id="verbs-aux-fixed" class="badge">â€”</span>
      <input id="verbs-partizip" placeholder="Partizip II (z. B. gegangen)" autocomplete="off">
    </div>

    <div id="verbs-actions">
      <button id="verbs-check">Check</button>
      <button id="verbs-next">Next</button>
    </div>

    <div id="verbs-feedback"></div>
	
	<div id="verbs-level-indicator" style="margin-top:10px; font-size:12px; opacity:0.8;"></div>

  </div>
  
  <div id="adjadv-card" hidden>
    <div class="prompt" id="adjadv-english">beautiful</div>
  
	<p id="adjadv-example" class="muted"></p>
    <label for="adjadv-german">German word</label>
    <input id="adjadv-german" autocomplete="off" placeholder="z. B. schÃ¶n" />
  
    
  
    <div id="adjadv-actions" style="display:flex;gap:8px;margin-top:12px;">
      <button id="adjadv-check">Check</button>
      <button id="adjadv-next">Next</button>
    </div>
  
    <div id="adjadv-feedback" style="margin-top:10px;font-size:14px;"></div>
  </div>

   <!-- === Prepositions Trainer Card (simple: just the preposition) === -->
      <style>
        #preps-card { border: 1px solid var(--border); border-radius: 10px; padding: 16px; margin: 8px 0 16px; background: var(--card); }
        #preps-card[hidden] { display: none; }
        #preps-sentence { font-size: 20px; line-height: 1.6; margin-bottom: 10px; }
        #preps-input { padding: 8px 10px; border: 1px solid var(--border); border-radius: 8px; background: var(--input); color: var(--text); min-width: 80px; display: inline-block; text-align:center; }
        #preps-input.result-ok { border-color: #29a36a !important; background: #0f1b16 !important; }
        #preps-input.result-bad { border-color: #d9534f !important; background: #1a1111 !important; }
        #preps-english { color: var(--muted); margin: 6px 0 0; }
      </style>
      
      <div id="preps-card" hidden>
        <div id="preps-sentence"></div>
        <p id="preps-english" class="muted"></p>
      
        <div style="display:flex; gap:8px; margin-top:12px;">
          <button id="preps-check">Check</button>
          <button id="preps-next">Next</button>
        </div>
      
        <div id="preps-feedback" style="margin-top:10px;font-size:14px;"></div>
      
        <!-- Autocomplete list (plain prepositions, no + Akk/+ Dat) -->
        <datalist id="preps-options">
          <option value="an"></option>
          <option value="auf"></option>
          <option value="aus"></option>
          <option value="bei"></option>
          <option value="fÃ¼r"></option>
          <option value="gegen"></option>
          <option value="in"></option>
          <option value="mit"></option>
          <option value="nach"></option>
          <option value="Ã¼ber"></option>
          <option value="um"></option>
          <option value="unter"></option>
          <option value="von"></option>
          <option value="vor"></option>
          <option value="zu"></option>
          <option value="ohne"></option>
          <option value="trotz"></option>
        </datalist>
      </div>

  
  <div class="container">
    <div id="vocab-wrapper">
    <h1>German Vocab Trainer</h1>
    <p id="level">Level: 1 (Words 1â€“25)</p>
      <div class="card">
        <p id="englishRow"><strong>English word:</strong> <span id="english"></span> <em id="streakDisplay"></em></p>
  
        <div id="media" style="margin-bottom:8px;">
          <!-- Faster image: async decode + high fetch priority -->
          <img id="wordImage" alt="vocab image" decoding="async" fetchpriority="high"
               style="display:none;width:100%;max-height:220px;object-fit:contain;background:#0d0f14;border:1px solid var(--border);border-radius:10px;padding:8px;" />
        </div>
  
        <div class="button-row">
          <button id="btnDer" class="article-btn">der</button>
          <button id="btnDie" class="article-btn">die</button>
          <button id="btnDas" class="article-btn">das</button>
        </div>
  
        <input type="text" id="german" placeholder="German word" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
        <input type="text" id="plural" placeholder="Plural" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
        <p id="feedback"></p>
        <p id="example"></p>
  
        <br />
        <button id="checkBtn">Check</button>
        <button id="resetBtn">Reset Progress</button>
        <button id="nextBtn">Next word</button>
        <div id="status"></div>

        <label style="display:flex;align-items:center;gap:8px;margin:10px auto 0;max-width:500px;color:var(--muted);font-size:.95em;">
          <input type="checkbox" id="toggleEnglish" checked /> Show English word
        </label>
      </div>
    </div>
  </div>
  
	<!-- ===== Source selector / Kapitel loader ===== -->
	<div id="source-bar" style="max-width:500px;margin:10px auto 8px;display:flex;gap:8px;align-items:center;">
	  <label style="white-space:nowrap;color:#9aa6b2;font-size:14px;">Source:</label>
	  <select id="dataset-selector" style="flex:1;padding:8px;border-radius:8px;border:1px solid #2a3240;background:#0f1620;color:#eaeaea;">
		<option value="default">Default Dataset</option>
	  </select>
	  <button id="btnLoadKapitel" style="padding:8px 12px;border-radius:8px;border:1px solid #2a3240;background:#243042;color:#eaeaea;cursor:pointer;">
		Load Kapitelâ€¦
	  </button>
	</div>
	
	<!-- ===== Sync status / controls ===== -->
	<div id="sync-bar" style="max-width:500px;margin:-2px auto 12px;display:flex;align-items:center;justify-content:space-between;gap:8px;">
	  <div style="font-size:13px;color:#9aa6b2">
		<span id="syncStatus">Sync: Off</span>
	  </div>
	  <div style="display:flex;gap:8px;">
		<button id="btnSyncNow" style="padding:6px 10px;border-radius:8px;border:1px solid #2a3240;background:#243042;color:#eaeaea;cursor:pointer;">Sync now</button>
		<button id="btnSyncSettings" style="padding:6px 10px;border-radius:8px;border:1px solid #2a3240;background:#243042;color:#eaeaea;cursor:pointer;">Sync settings</button>
	  </div>
	</div>

	<!-- ===== Sync modal (splash) ===== -->
	<div id="syncModal" style="position:fixed;inset:0;background:rgba(0,0,0,0.6);display:none;align-items:center;justify-content:center;z-index:9999;">
	  <div style="background:#0f1620;border:1px solid #2a3240;border-radius:12px;max-width:520px;width:92%;padding:16px 16px 14px;color:#eaeaea;">
		<h3 style="margin:0 0 8px 0;font-size:18px;">Cloud Sync (optional)</h3>
		<p style="margin:0 0 12px;color:#9aa6b2;font-size:14px;">
		  Use a simple username to sync progress across browsers/devices. No email or password.
		</p>
		<label style="font-size:14px;color:#cbd5e1;">Username</label>
		<input id="syncUsernameInput" type="text" placeholder="e.g., negm" style="width:100%;margin-top:6px;margin-bottom:10px;padding:10px;border-radius:8px;border:1px solid #2a3240;background:#0b1220;color:#eaeaea;">
		<div style="display:flex;gap:8px;justify-content:flex-end;margin-top:4px;">
		  <button id="syncCancel" style="padding:8px 12px;border-radius:8px;border:1px solid #2a3240;background:#202a38;color:#eaeaea;cursor:pointer;">Skip</button>
		  <button id="syncSave" style="padding:8px 12px;border-radius:8px;border:1px solid #2a3240;background:#3a5c78;color:#eaeaea;cursor:pointer;">Enable sync</button>
		</div>
		<div id="syncNote" style="margin-top:10px;color:#9aa6b2;font-size:12px;">
		  Tip: If a cloud save exists for this username, you can choose to load it on first sync.
		</div>
	  </div>
	</div>

	<!-- Kapitel-complete splash -->
	<div id="kapitelDoneModal" style="position:fixed;inset:0;background:rgba(0,0,0,0.6);display:none;align-items:center;justify-content:center;z-index:10000;">
	  <div style="background:#0f1620;border:1px solid #2a3240;border-radius:12px;max-width:520px;width:92%;padding:18px;color:#eaeaea;">
		<h3 style="margin:0 0 8px 0;font-size:18px;">Kapitel mastered ðŸŽ‰</h3>
		<p style="margin:0 0 12px;color:#9aa6b2;font-size:14px;">
		  Youâ€™ve mastered all vocab, verbs, adjectives/adverbs, and prepositions in this Kapitel.
		</p>
		<div style="display:flex;gap:8px;justify-content:flex-end;">
		  <button id="kapitelDoneClose" style="padding:8px 12px;border-radius:8px;border:1px solid #2a3240;background:#202a38;color:#eaeaea;cursor:pointer;">Close</button>
		  <button id="kapitelDoneReset" style="padding:8px 12px;border-radius:8px;border:1px solid #2a3240;background:#3a5c78;color:#eaeaea;cursor:pointer;">Reset progress</button>
		</div>
	  </div>
	</div>

	
	<div id="dataset-context" style="max-width:500px;margin:-2px auto 12px;color:#9aa6b2;font-size:13px;"></div>

	<!-- hidden file input for zip -->
	<input id="kapitel-zip-input" type="file" accept=".zip" style="display:none" />

	<!-- JSZip (for reading uploaded Kapitel .zip) -->
	<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

	<!-- Dataset bridge (lets existing loaders read from a Kapitel package if selected) -->
	<script>
	  // Current dataset (default == nil files -> fall back to fetch)
	  window.currentDataset = {
		key: 'default',
		title: 'Default Dataset',
		files: null,   // { 'vocab.csv': '...', 'verbs.csv': '...', 'adjadv.csv': '...', 'prepositions.csv': '...', 'manifest.json': '{...}' }
		counts: null   // { vocab: n, verbs: n, adjadv: n, preps: n }
	  };

	  // Persist exactly one loaded Kapitel (v1); weâ€™ll add multi-Kapitel later
	  const KAPITEL_STORE_KEY = 'kapitel_current_v1';

	  function ds_lsGet(key, fallback){ try{ const v = localStorage.getItem(key); return v ? JSON.parse(v) : fallback; }catch{ return fallback; } }
	  function ds_lsSet(key, val){ try{ localStorage.setItem(key, JSON.stringify(val)); }catch{} }
	  function ds_trimCsvCount(csv){
		if(!csv) return 0;
		const lines = csv.trim().split(/\r?\n/);
		if(lines.length === 0) return 0;
		// assume first row is header when it looks like text, skip it
		return Math.max(0, lines.length - 1);
	  }

	  // Core read helper used by our patched loaders
	  async function datasetRead(filename){
		const ds = window.currentDataset;
		if(ds && ds.files && ds.files[filename] != null){
		  return ds.files[filename]; // already a string
		}
		// Fallback to original local CSV fetch
		const res = await fetch(filename, { cache: 'no-store' });
		if(!res.ok) throw new Error('Failed to load ' + filename);
		return await res.text();
	  }

	  function updateDatasetUI(){
		const sel = document.getElementById('dataset-selector');
		const ctx = document.getElementById('dataset-context');
		// Rebuild selector each time (simple)
		sel.innerHTML = '<option value="default">Default Dataset</option>';
		const saved = ds_lsGet(KAPITEL_STORE_KEY, null);
		if(saved){
		  const opt = document.createElement('option');
		  opt.value = 'kapitel';
		  opt.textContent = saved.title || (saved.manifest?.title) || 'Kapitel (loaded)';
		  sel.appendChild(opt);
		}
		// Pre-select current
		sel.value = (window.currentDataset.key === 'kapitel') ? 'kapitel' : 'default';

		// Context line
		if(window.currentDataset.key === 'kapitel'){
		  const c = window.currentDataset.counts || {};
		  const title = window.currentDataset.title || 'Kapitel';
		  ctx.textContent = `Studying: ${title} â€¢ ${c.vocab||0} vocab Â· ${c.verbs||0} verbs Â· ${c.adjadv||0} adj/adv Â· ${c.preps||0} preps`;
		} else {
		  ctx.textContent = '';
		}
	  }

	  async function applyDatasetAndReload(){
		// Re-run all existing loaders so the four modes use the selected dataset
		try{
		  // These functions exist later in the file; we call them after DOM is ready.
		  if(typeof loadCSV === 'function')           await loadCSV();
		  if(typeof loadVerbsData === 'function')     await loadVerbsData();
		  if(typeof aa_loadData === 'function')       await aa_loadData();
		  if(typeof pp_loadData === 'function')       await pp_loadData();
		  // Refresh mode rendering if the app provides it
		  if(typeof renderMode === 'function')        renderMode();
		  console.log('[Mix pools]',
		  { vocab:(window.words||[]).length,
			verbs:(window.verbsState?.data||[]).length,
			adjadv:(window.adjadvState?.data||[]).length,
			preps:(window.prepsState?.data||[]).length });

		  // Optional: if you want to jump to Mix automatically, uncomment:
		  // if(typeof setMode === 'function') setMode('mix');
		}catch(e){ console.error(e); }
	  }

	  async function handleKapitelZip(file){
		const zip = await JSZip.loadAsync(file);
		// Helper: find by file base name anywhere in the zip
		async function readByName(basename){
		  const entry = Object.values(zip.files).find(f => !f.dir && f.name.toLowerCase().endsWith('/'+basename)) 
					 || Object.values(zip.files).find(f => !f.dir && f.name.toLowerCase() === basename.toLowerCase());
		  if(!entry) return null;
		  return await entry.async('string');
		}
		const manifestTxt = await readByName('manifest.json');
		const vocabTxt    = await readByName('vocab.csv');
		const verbsTxt    = await readByName('verbs.csv');
		const adjadvTxt   = await readByName('adjadv.csv');
		const prepsTxt    = await readByName('prepositions.csv');

		if(!vocabTxt && !verbsTxt && !adjadvTxt && !prepsTxt){
		  alert('This ZIP does not contain any of the required CSV files.');
		  return;
		}

		// Build dataset object
		let manifest = null;
		try{ manifest = manifestTxt ? JSON.parse(manifestTxt) : null; }catch{ manifest = null; }
		const title = (manifest && (manifest.title || manifest.kapitel)) || (file.name.replace(/\.zip$/i,''));
		const counts = {
		  vocab:  ds_trimCsvCount(vocabTxt||''),
		  verbs:  ds_trimCsvCount(verbsTxt||''),
		  adjadv: ds_trimCsvCount(adjadvTxt||''),
		  preps:  ds_trimCsvCount(prepsTxt||'')
		};
		const ds = {
		  key: 'kapitel',
		  title,
		  files: {
			'manifest.json': manifestTxt || '',
			'vocab.csv': vocabTxt || '',
			'verbs.csv': verbsTxt || '',
			'adjadv.csv': adjadvTxt || '',
			'prepositions.csv': prepsTxt || ''
		  },
		  counts
		};

		// Save (single current Kapitel)
		ds_lsSet(KAPITEL_STORE_KEY, { title, manifest, files: ds.files, counts });
		window.currentDataset = ds;
		updateDatasetUI();
		await applyDatasetAndReload();
	  }

	  document.addEventListener('DOMContentLoaded', ()=>{
		// Restore previously loaded Kapitel if any
		const saved = ds_lsGet(KAPITEL_STORE_KEY, null);
		if(saved){
		  window.currentDataset = { key:'kapitel', title: saved.title, files: saved.files, counts: saved.counts };
		}
		updateDatasetUI();

		// Wiring: selector change
		const sel = document.getElementById('dataset-selector');
		sel.addEventListener('change', async (e)=>{
		  const v = e.target.value;
		  if(v === 'default'){
			window.currentDataset = { key:'default', title:'Default Dataset', files:null, counts:null };
		  } else if(v === 'kapitel'){
			const s = ds_lsGet(KAPITEL_STORE_KEY, null);
			if(s){
			  window.currentDataset = { key:'kapitel', title: s.title, files: s.files, counts: s.counts };
			} else {
			  // If nothing saved, revert
			  window.currentDataset = { key:'default', title:'Default Dataset', files:null, counts:null };
			  e.target.value = 'default';
			}
		  }
		  updateDatasetUI();
		  await applyDatasetAndReload();
		});

		// Wiring: Load Kapitel button
		document.getElementById('btnLoadKapitel').addEventListener('click', ()=>{
		  document.getElementById('kapitel-zip-input').click();
		});
		document.getElementById('kapitel-zip-input').addEventListener('change', async (ev)=>{
		  const f = ev.target.files && ev.target.files[0];
		  if(!f) return;
		  try{
			await handleKapitelZip(f);
		  }catch(err){
			console.error(err);
			alert('Failed to load Kapitel ZIP: ' + err.message);
		  } finally {
			ev.target.value = '';
		  }
		});
	  });
			  
				// ===== Firebase config â€” REPLACE with your real config from Firebase console =====
		  // FIND THIS BLOCK LATER IF YOU NEED TO UPDATE CONFIG: "FIREBASE_CONFIG_START" â†’ "FIREBASE_CONFIG_END"
		  // FIREBASE_CONFIG_START
		  const firebaseConfig = {
			apiKey: "AIzaSyAvMyNtFyWM3Ajg2sxpWp4uMErfyawEOMc",
			authDomain: "german-52657.firebaseapp.com",
			databaseURL: "https://german-52657-default-rtdb.europe-west1.firebasedatabase.app",
			projectId: "german-52657",
			storageBucket: "german-52657.firebasestorage.app",
			messagingSenderId: "364706857329",
			appId: "1:364706857329:web:97779c21361db2423336d0"
		  };
		  // FIREBASE_CONFIG_END

		  // Initialize Firebase (safe-guard: only once)
		  if (!window._fbApp) {
			try { window._fbApp = firebase.initializeApp(firebaseConfig); } catch(e) { /* ignore if already */ }
		  }
		  const db = firebase.database();

		  // ===== What we sync (same keys we used for export/import)
		  const SYNC_KEYS = [
			'vocabProgress::default',
			'vocabProgress::kapitel',

			// Verbs/AdjAdv/Preps progress keys â€” add more if you already use these:
			'verbs_level','verbs_unlocked_count','verbs_streaks','verbs_index',
			'adjadv_level','adjadv_unlocked_count','adjadv_streaks','adjadv_index',
			'preps_level','preps_unlocked_count','preps_streaks','preps_index',

			// The currently loaded Kapitel package so other browsers load it too
			'kapitel_current_v1'
		  ];

		  function cloudPath(username){ return 'users/' + encodeURIComponent(username); }

		  function cloudSnapshot(){
			const out = {};
			SYNC_KEYS.forEach(k => { out[k] = localStorage.getItem(k) ?? null; });
			// small meta
			out['_meta'] = {
			  updatedAt: Date.now(),
			  datasetKey: (window.currentDataset?.key || 'default'),
			  title: window.currentDataset?.title || 'Default Dataset'
			};
			return out;
		  }

		  async function cloudPull(username){
			const snap = await db.ref(cloudPath(username)).get();
			return snap.exists() ? snap.val() : null;
		  }

		  async function cloudPush(username, data){
			await db.ref(cloudPath(username)).set(data);
		  }

		  function applyCloudData(data){
			if(!data) return;
			Object.keys(data).forEach(k=>{
			  if(k === '_meta') return;
			  const v = data[k];
			  if(v === null || v === undefined) return;
			  try { localStorage.setItem(k, v); } catch {}
			});
			// Re-apply Kapitel package if present
			const saved = ds_lsGet('kapitel_current_v1', null);
			if(saved){
			  window.currentDataset = { key:'kapitel', title:saved.title, files:saved.files, counts:saved.counts };
			} else {
			  window.currentDataset = { key:'default', title:'Default Dataset', files:null, counts:null };
			}
		  }

		  // UI helpers
		  function updateSyncStatus(){
			const el = document.getElementById('syncStatus');
			const u  = localStorage.getItem('syncUsername') || null;
			el.textContent = u ? ('Sync: ' + u) : 'Sync: Off';
		  }

		  // Autosync
		  let _syncTimer = null;
		  let _syncBusy = false;
		  function scheduleSyncSoon(){
			if(!localStorage.getItem('syncUsername')) return;
			if(_syncTimer) clearTimeout(_syncTimer);
			_syncTimer = setTimeout(runSync, 1500);
		  }
		  async function runSync(){
			if(_syncBusy) return;
			const u = localStorage.getItem('syncUsername');
			if(!u) return;
			_syncBusy = true;
			try {
			  await cloudPush(u, cloudSnapshot());
			  // (optional) could update a small "last synced" timestamp UI here
			} catch(e) {
			  console.warn('Cloud sync failed:', e?.message || e);
			} finally {
			  _syncBusy = false;
			}
		  }
		  // Periodic sync as a backup
		  setInterval(()=>{ if(localStorage.getItem('syncUsername')) runSync(); }, 15000);

		  // Wire UI
		  document.addEventListener('DOMContentLoaded', ()=>{
			// First visit splash
			const hasSeen = localStorage.getItem('syncSplashSeen');
			if(!hasSeen){
			  document.getElementById('syncModal').style.display = 'flex';
			}
			document.getElementById('btnSyncSettings').addEventListener('click', ()=>{
			  const input = document.getElementById('syncUsernameInput');
			  input.value = localStorage.getItem('syncUsername') || '';
			  document.getElementById('syncModal').style.display = 'flex';
			});
			document.getElementById('syncCancel').addEventListener('click', ()=>{
			  localStorage.setItem('syncSplashSeen','1');
			  document.getElementById('syncModal').style.display = 'none';
			});
			document.getElementById('syncSave').addEventListener('click', async ()=>{
			  const u = (document.getElementById('syncUsernameInput').value || '').trim();
			  if(!u){ alert('Please enter a username, e.g., negm'); return; }
			  localStorage.setItem('syncSplashSeen','1');

			  // If cloud has data, ask to use it
			  try{
				const remote = await cloudPull(u);
				if(remote){
				  if(confirm('Cloud data found for "'+u+'". Load it and overwrite local?')){
					applyCloudData(remote);
					if(typeof updateDatasetUI === 'function') updateDatasetUI();
					await applyDatasetAndReload?.();
				  }
				}
			  }catch(e){ console.warn('pull failed', e); }

			  localStorage.setItem('syncUsername', u);
			  updateSyncStatus();
			  document.getElementById('syncModal').style.display = 'none';
			  scheduleSyncSoon(); // push current local state
			});

			document.getElementById('btnSyncNow').addEventListener('click', runSync);

			updateSyncStatus();

			// Also sync on leave
			window.addEventListener('beforeunload', ()=>{ try{ navigator.sendBeacon; }catch{}; });
		  });

		  // Every time we load data or change dataset, mark dirty â†’ push soon
		  const _origApplyDatasetAndReload = applyDatasetAndReload;
		  applyDatasetAndReload = async function(){
			if(typeof _origApplyDatasetAndReload === 'function'){
			  await _origApplyDatasetAndReload();
			}
			scheduleSyncSoon();
		  }

	  
	  
	</script>


  <script>
	  document.addEventListener('DOMContentLoaded', () => {
		// ===== State =====
		let words = [];
		let currentWord = null;
		let chosenArticle = '';
		let level = 1;
		const wordsPerLevel = 25;
		const masteryThreshold = 3;
		let pluralEnterCount = 0;
		let lastFocusId = 'german';

		const statusEl = document.getElementById('status');
		const englishRowEl = document.getElementById('englishRow');

		// Show any uncaught error in the UI (helps diagnose blank screens)
		window.addEventListener('error', (e) => {
		  if (statusEl) statusEl.textContent = 'âš ï¸ JS error: ' + (e.error?.message || e.message || String(e));
		});

		// === Image cache & preload ===
		let imageCache = new Map(); // german -> best src or null
		let preloadedNext = null;   // { word, src }

		function status(msg){ if(statusEl) statusEl.textContent = msg || ''; }

		// ===== Mix(Kapitel) helpers =====
		window.isKapitelMixMode = function(){
		  return (window.currentDataset?.key === 'kapitel') &&
				 (typeof getMode==='function') && (getMode()==='mix');
		};

		window.sectionHasUnmastered = function(sectionName){
		  if (sectionName === 'vocab'){
			const arr = words || [];
			return arr.some(w => (w.correctStreak||0) < masteryThreshold);
		  }
		  if (sectionName === 'verbs'){
			const data = (window.verbsState?.data)||[];
			const streaks = (window.verbsState?.streaks)||{};
			return data.some(v => (streaks[v.id]||0) < 3);
		  }
		  if (sectionName === 'adjadv'){
			const data = (window.adjadvState?.data)||[];
			const streaks = (window.adjadvState?.streaks)||{};
			return data.some(x => (streaks[x.id]||0) < 3);
		  }
		  if (sectionName === 'preps'){
			const data = (window.prepsState?.data)||[];
			const streaks = (window.prepsState?.streaks)||{};
			return data.some(x => (streaks[x.id]||0) < 3);
		  }
		  return false;
		};

		window.allKapitelMastered = function(){
		  if (window.currentDataset?.key !== 'kapitel') return false;
		  return !['vocab','verbs','adjadv','preps'].some(window.sectionHasUnmastered);
		};

		window.showKapitelDoneSplash = function(){
		  const m = document.getElementById('kapitelDoneModal');
		  if (m) m.style.display = 'flex';
		};

		window.hideKapitelDoneSplash = function(){
		  const m = document.getElementById('kapitelDoneModal');
		  if (m) m.style.display = 'none';
		};

		window.resetKapitelProgress = function(){
		  try{ localStorage.removeItem('vocabProgress::kapitel'); }catch{}
		  try{
			['verbs_level','verbs_unlocked_count','verbs_streaks','verbs_index',
			 'adjadv_level','adjadv_unlocked_count','adjadv_streaks','adjadv_index',
			 'preps_level','preps_unlocked_count','preps_streaks','preps_index']
			 .forEach(k => localStorage.removeItem(k));
		  }catch{}
		  try{
			(words||[]).forEach(w=>{ w.correctStreak=0; w.answeredCorrect=false; });
			if (window.verbsState){ verbsState.streaks = {}; verbsState.index=0; }
			if (window.adjadvState){ adjadvState.streaks = {}; adjadvState.index=0; }
			if (window.prepsState){ prepsState.streaks = {}; prepsState.index=0; }
		  }catch{}
		  window.hideKapitelDoneSplash();
		  if (typeof renderMode==='function') renderMode();
		};


		document.addEventListener('DOMContentLoaded', ()=>{
		  document.getElementById('kapitelDoneClose')?.addEventListener('click', hideKapitelDoneSplash);
		  document.getElementById('kapitelDoneReset')?.addEventListener('click', resetKapitelProgress);
		});


		// ===== CSV Parser =====
		function parseCSV(text){
		  const rows=[]; let row=[]; let cur=''; let inQuotes=false;
		  for(let i=0;i<text.length;i++){
			const c=text[i];
			if(c==='"'){
			  if(inQuotes && text[i+1]==='"'){ cur+='"'; i++; } else { inQuotes=!inQuotes; }
			} else if(c===',' && !inQuotes){
			  row.push(cur); cur='';
			} else if((c==='\n' || c==='\r') && !inQuotes){
			  if(cur!=='' || row.length){ row.push(cur); rows.push(row); row=[]; cur=''; }
			} else {
			  cur+=c;
			}
		  }
		  if(cur!=='' || row.length){ row.push(cur); rows.push(row); }
		  return rows;
		}

		// ===== Data loading =====
		async function loadCSV(){
		  try{
			status('Loading vocab.csvâ€¦');
			const data = await datasetRead('vocab.csv');
			const lines = parseCSV(data.trim());
			if(lines.length===0){ status('vocab.csv is empty'); return; }
			lines.shift();
			words = lines.map(cols=>{
			  const english=cols[0]||''; const article=cols[1]||''; const german=cols[2]||''; const plural=cols[3]||'';
			  const ex1=cols[4]||''; const ex2=cols[5]||''; const ex3=cols[6]||'';
			  const examples=[ex1,ex2,ex3].filter(x=>x&&x.trim()!=='');
			  return { english, article, german, plural, examples, correctStreak:0, answeredCorrect:false };
			});
			window.words = words; // expose vocab to MIX

			loadProgress();
			updateLevelDisplay();
			await nextWord();          // show first word
			schedulePreloadNext();     // start preloading immediately
			status('');
		  }catch(e){ console.error(e); status('Error: '+e.message); }
		}

		function updateLevelDisplay(){
		  const el = document.getElementById('level');
		  if (!el) return;
		  if (isKapitelMixMode()){
			el.style.display = 'none';
		  } else {
			el.style.display = '';
			el.textContent = `Level: ${level} (Words 1â€“${level*wordsPerLevel})`;
		  }
		}


		function getActiveWords(){
		  if (isKapitelMixMode()){
			// Whole Kapitel is available; weâ€™ll prefer unmastered when picking next
			return words.slice();
		  }
		  return words.slice(0, level*wordsPerLevel);
		}


		function getTierWords(){
		  const active=getActiveWords(); if(active.length===0) return [];
		  const minStreak=Math.min(...active.map(w=>w.correctStreak));
		  return active.filter(w=>w.correctStreak===minStreak && !w.answeredCorrect);
		}

		// ===== Image helpers =====
		function replaceUmlauts(s){
		  return (s||'')
			.replaceAll('Ã¤','ae').replaceAll('Ã„','Ae')
			.replaceAll('Ã¶','oe').replaceAll('Ã–','Oe')
			.replaceAll('Ã¼','ue').replaceAll('Ãœ','Ue')
			.replaceAll('ÃŸ','ss');
		}
		function buildCandidates(german){
		  const baseRaw=(german||'').trim(); const bases=[];
		  if(baseRaw){
			bases.push(baseRaw, baseRaw.toLowerCase(), baseRaw.replaceAll(' ','-'), baseRaw.toLowerCase().replaceAll(' ','-'));
			const uml=replaceUmlauts(baseRaw);
			bases.push(uml, uml.toLowerCase(), uml.replaceAll(' ','-'), uml.toLowerCase().replaceAll(' ','-'));
		  }
		  const exts=['jpg','jpeg','png','webp']; const out=[];
		  bases.forEach(b=>exts.forEach(ext=>out.push('img/'+encodeURIComponent(b)+'.'+ext)));
		  return out;
		}

		function resolveImageSrcForGerman(german){
		  return new Promise((resolve)=>{
			if(!german){ resolve(null); return; }
			if(imageCache.has(german)){ resolve(imageCache.get(german)); return; }

			const candidates = buildCandidates(german);
			let i = 0, done = false;

			const tryNext = ()=>{
			  if(done) return;
			  if(i >= candidates.length){ done = true; imageCache.set(german, null); resolve(null); return; }
			  const src = candidates[i++];
			  const probe = new Image();
			  probe.onload = ()=>{ if(done) return; done = true; imageCache.set(german, src); resolve(src); };
			  probe.onerror = tryNext;
			  probe.src = src;
			};
			tryNext();
		  });
		}

		async function preloadWordImage(word){
		  if(!word || !word.german) return { word, src: null };
		  const src = await resolveImageSrcForGerman(word.german);
		  return { word, src };
		}

		// Faster image: no artificial wait
		function loadImageForCurrent(waitMs = 0){
		  const img = document.getElementById('wordImage');
		  if (img){
			img.style.display='none';
			img.removeAttribute('src');
		  }
		  return; // images disabled
		}


		function pickNextCandidateWord(){
		  const active = getActiveWords();
			if(active.length === 0) return null;

			if (isKapitelMixMode()){
			  const unmastered = active.filter(w => (w.correctStreak||0) < masteryThreshold);
			  if (unmastered.length === 0) return null; // all done -> splash handled by mix picker
			  const minStreak = Math.min(...unmastered.map(w => w.correctStreak||0));
			  const tier = unmastered.filter(w => (w.correctStreak||0) === minStreak && !w.answeredCorrect);
			  const pool = tier.length ? tier : unmastered;
			  return pool[Math.floor(Math.random()*pool.length)];
			}

			// default (level-based)
			const minStreak = Math.min(...active.map(w => w.correctStreak));
			let tier = active.filter(w => w.correctStreak === minStreak && !w.answeredCorrect);
			if(tier.length === 0) tier = active.filter(w => w.correctStreak === minStreak);
			if(tier.length === 0) tier = active;
			return tier[Math.floor(Math.random()*tier.length)];

		}
		async function schedulePreloadNext(){
		  window.preloadedNext = null; // images disabled
		}


		async function nextWord(){
		  const activeWords=getActiveWords(); if(activeWords.length===0) return;

		  let tierWords=getTierWords();
		  if(tierWords.length===0){
			const minStreak=Math.min(...activeWords.map(w=>w.correctStreak));
			activeWords.filter(w=>w.correctStreak===minStreak).forEach(w=>w.answeredCorrect=false);
			tierWords=getTierWords();
		  }
		  const list=(tierWords.length?tierWords:activeWords);
		  currentWord=list[Math.floor(Math.random()*list.length)];

		  const englishEl = document.getElementById('english');
		  const streakEl  = document.getElementById('streakDisplay');
		  const germanEl  = document.getElementById('german');
		  const pluralEl  = document.getElementById('plural');
		  const feedbackEl= document.getElementById('feedback');
		  const exampleEl = document.getElementById('example');
		  const nextBtn   = document.getElementById('nextBtn');

		  if(englishEl) englishEl.textContent=currentWord.english;
		  if(streakEl)  streakEl.textContent=`(${currentWord.correctStreak}/${masteryThreshold})`;
		  if(germanEl)  germanEl.value='';
		  if(pluralEl)  pluralEl.value='';
		  if(feedbackEl)feedbackEl.textContent='';
		  if(exampleEl) exampleEl.textContent='';
		  if(nextBtn)   nextBtn.style.display='none';

		  chosenArticle='';
		  resetArticleButtons();
		  pluralEnterCount=0;

		  applyEnglishVisibility();

		  // Begin resolving image ASAP, then show it
		  await loadImageForCurrent(0);
		  schedulePreloadNext();

		  if(germanEl){
			setTimeout(()=>{
			  germanEl.focus();
			  try{ germanEl.scrollIntoView({ behavior:'smooth', block:'center' }); }catch{}
			},0);
		  }
		    // MIX: rotate to another section after moving to next
		  if ((typeof getMode==='function' ? getMode() : window.mode) === 'mix') {
			const section = pickRandomSection();
			renderForSection(section);
			return;
		  }

		}

		function resetArticleButtons(){
		  const a=document.getElementById('btnDer');
		  const b=document.getElementById('btnDie');
		  const c=document.getElementById('btnDas');
		  if(a) a.classList.remove('selected');
		  if(b) b.classList.remove('selected');
		  if(c) c.classList.remove('selected');
		}

		function chooseArticle(article){
		  chosenArticle=article; resetArticleButtons();
		  if(article==='der') document.getElementById('btnDer')?.classList.add('selected');
		  if(article==='die') document.getElementById('btnDie')?.classList.add('selected');
		  if(article==='das') document.getElementById('btnDas')?.classList.add('selected');

		  const germanEl=document.getElementById('german');
		  if(germanEl){
			lastFocusId='german';
			setTimeout(()=>{
			  germanEl.focus();
			  try{ germanEl.scrollIntoView({ behavior:'smooth', block:'center' }); }catch{}
			},0);
		  }
		}

		function randomExample(examples){ if(!examples||examples.length===0) return ''; const i=Math.floor(Math.random()*examples.length); return examples[i]; }

		function checkAnswer(){
		  if(!currentWord) return;
		  const german=(document.getElementById('german')?.value || '').trim().toLowerCase();
		  const plural=(document.getElementById('plural')?.value || '').trim().toLowerCase();
		  let feedback='';
		  const correctGerman=(currentWord.german||'').toLowerCase();
		  const correctPlural=(currentWord.plural||'').toLowerCase();
		  const pluralCorrect=(plural===correctPlural) || (correctPlural==='â€”' && plural==='');
		  if(chosenArticle===currentWord.article && german===correctGerman && pluralCorrect){
			currentWord.correctStreak++; currentWord.answeredCorrect=true; feedback='<span style="color:var(--ok)">Correct!</span>';
		  } else {
			currentWord.correctStreak=0; currentWord.answeredCorrect=false; feedback=`<span style="color:var(--bad)">Wrong!</span><br>Correct: ${currentWord.article} ${currentWord.german} â€” ${currentWord.plural}`;
		  }
		  const feedbackEl=document.getElementById('feedback');
		  if(feedbackEl) feedbackEl.innerHTML=feedback;
		  const streakEl=document.getElementById('streakDisplay');
		  if(streakEl) streakEl.textContent=`(${currentWord.correctStreak}/${masteryThreshold})`;
		  const ex=randomExample(currentWord.examples);
		  const exampleEl=document.getElementById('example');
		  if(exampleEl) exampleEl.textContent=ex?`ðŸ“ ${ex}`:'';
		  const nextBtn=document.getElementById('nextBtn');
		  if(nextBtn) nextBtn.style.display='inline-block';
		  saveProgress();

		  const activeWords = getActiveWords();
			const allMastered = activeWords.every(w => w.correctStreak>=masteryThreshold);

			if (isKapitelMixMode()){
			  if (allKapitelMastered()) showKapitelDoneSplash();
			} else {
			  if(allMastered && level*wordsPerLevel<words.length){
				level++; activeWords.forEach(w=>{w.correctStreak=0; w.answeredCorrect=false;});
				updateLevelDisplay(); saveProgress();
			  }
			}

		}

		function saveProgress(){
		  try{
			  const dsKey = (window.currentDataset?.key === 'kapitel') ? 'kapitel' : 'default';
			  localStorage.setItem(`vocabProgress::${dsKey}`, JSON.stringify({
				words, level,
				showEnglish: document.getElementById('toggleEnglish')?.checked
			  }));
			}finally{
			  // Mark for cloud sync if enabled
			  if (typeof scheduleSyncSoon === 'function') scheduleSyncSoon();
			}
		}

		function loadProgress(){
		  try{
			const dsKey = (window.currentDataset?.key === 'kapitel') ? 'kapitel' : 'default';
			const saved = localStorage.getItem(`vocabProgress::${dsKey}`);
			const cb=document.getElementById('toggleEnglish');
			if(saved){
			  const data=JSON.parse(saved);
			  level=data.level||1;
			  if(cb) cb.checked = (data.showEnglish!==undefined)? !!data.showEnglish : true;
			  words.forEach((w,i)=>{ if(data.words && data.words[i]){ w.correctStreak=data.words[i].correctStreak||0; w.answeredCorrect=data.words[i].answeredCorrect||false; } });
			} else { if(cb) cb.checked = true; }
		  }catch{}
		}

		function resetProgress(){
		  if(confirm('Are you sure you want to reset progress?')){
			try{
			  const dsKey = (window.currentDataset?.key === 'kapitel') ? 'kapitel' : 'default';
			  localStorage.removeItem(`vocabProgress::${dsKey}`);
			}catch{}
			words.forEach(w=>{ w.correctStreak=0; w.answeredCorrect=false; });
			level=1; updateLevelDisplay(); nextWord();
		  }
		}


		// Input focus + Enter behavior
		document.getElementById('german')?.addEventListener('focus', ()=>{ lastFocusId='german'; });
		document.getElementById('plural')?.addEventListener('focus', ()=>{ lastFocusId='plural'; });

		document.getElementById('german')?.addEventListener('keydown', e=>{ if(e.key==='Enter'){ e.preventDefault(); document.getElementById('plural')?.focus(); }});
		document.getElementById('plural')?.addEventListener('keydown', e=>{
		  if(e.key==='Enter'){
			e.preventDefault();
			pluralEnterCount++;
			if(pluralEnterCount===1) checkAnswer();
			else if(pluralEnterCount===2){ 
			  pluralEnterCount=0; 
			  nextWord(); 
			  setTimeout(()=>{ 
				if (typeof getMode==='function' && getMode()==='mix') pickRandomSectionAndRender(); 
			  }, 0); 
			}

		  }
		});

		// ===== Article buttons â€” keep keyboard up =====
		function bindArticleButton(id, article){
		  const el = document.getElementById(id);
		  if(!el) return;

		  // Prevent the button from stealing focus (so keyboard stays open)
		  const early = (e)=>{ 
			try { e.preventDefault(); } catch {}
			chooseArticle(article);
		  };
		  el.addEventListener('pointerdown', early);
		  el.addEventListener('mousedown', early);
		  el.addEventListener('click', (e)=>{ e.preventDefault(); chooseArticle(article); });
		}
		bindArticleButton('btnDer','der');
		bindArticleButton('btnDie','die');
		bindArticleButton('btnDas','das');

		// Other buttons
		document.getElementById('checkBtn')?.addEventListener('click', checkAnswer);
		document.getElementById('resetBtn')?.addEventListener('click', resetProgress);
		document.getElementById('nextBtn')?.addEventListener('click', nextWord);

		// English toggle
		function applyEnglishVisibility(){
		  const cb=document.getElementById('toggleEnglish');
		  if(!englishRowEl) return;
		  englishRowEl.style.display = cb && cb.checked ? '' : 'none';
		}
		document.getElementById('toggleEnglish')?.addEventListener('change', ()=>{ applyEnglishVisibility(); saveProgress(); });

		// Start
		applyEnglishVisibility();
		loadCSV();
	  });
  </script>
  <script>
        /* =======================
           Verbs Trainer (ADD-ON)
           ======================= */
        
        /* LocalStorage keys (namespaced) */
        const MODE_KEY = 'mode'; // shared selector; defaults to 'vocab'
        const VERBS_LEVEL_KEY = 'verbs_level';
        const VERBS_UNLOCKED_KEY = 'verbs_unlocked_count';
        const VERBS_STREAKS_KEY = 'verbs_streaks';
        const VERBS_INDEX_KEY = 'verbs_index';
        
        /* State */
        const verbsState = {
          data: [],      // array of verbs
          index: 0,      // pointer within unlocked pool
          level: 1,      // 25 items per level
          unlocked: 25,  // how many available = level * 25
          streaks: {}    // id -> 0..3
        };
        window.verbsState = verbsState; // expose verbs to MIX

        /* DOM refs */
        const elModeSwitch = document.getElementById('mode-switch');
        const elVerbsCard  = document.getElementById('verbs-card');
        const elEnglish    = document.getElementById('verbs-english');
        const elInf        = document.getElementById('verbs-inf');
        const elAuxBtns    = Array.from(document.querySelectorAll('.aux-btn'));
        const elAuxBadge   = document.getElementById('verbs-aux-badge');
        const elAuxFixed   = document.getElementById('verbs-aux-fixed');
        const pIch = document.getElementById('verbs-p-ich');
        const pDu  = document.getElementById('verbs-p-du');
        const pEr  = document.getElementById('verbs-p-er');
        const pIhr = document.getElementById('verbs-p-ihr');  
		const elPart = document.getElementById('verbs-partizip');
		// NEW fields must be declared before any use
		const inpPast = document.getElementById('verbs-past');     // PrÃ¤teritum
		const inpPrep = document.getElementById('verbs-prep');     // Preposition input
		const caseBtns = Array.from(document.querySelectorAll('.case-btn')); // Inf/Akk/Dat buttons
        const elCheck = document.getElementById('verbs-check');
        const elNext  = document.getElementById('verbs-next');
        const elFeedback = document.getElementById('verbs-feedback');
        const reflBtns = Array.from(document.querySelectorAll('.refl-btn'));
        const selReflCase = document.getElementById('verbs-refl-case');
		
		// Keep track: after Check is pressed once, second Enter on last field should go Next
		elCheck?.addEventListener('click', ()=> { lastFieldCheckedOnce = true; });
		elNext ?.addEventListener('click', ()=> { lastFieldCheckedOnce = false; });

		// Case buttons + state
		let chosenCase = null;  // 'inf' | 'akk' | 'dat' | null

		let lastFieldCheckedOnce = false; // first Enter on last field triggers Check; second triggers Next


		// Reflexive state (we already had chosenRefl)
		let chosenRefl = null;  // 'yes' | 'no' | null
		
		let chosenAux = null;   // 'haben' | 'sein'

		// remember last focused text input (to keep keyboard open)
		let lastInputFocus = null;
		[elInf, inpPrep, pIch, pDu, pEr, pIhr, inpPast, elPart].forEach(el=>{
		  el?.addEventListener('focus', ()=>{
			lastInputFocus = el;
			scrollFieldIntoView(el);
		  });
		});


      
      
          // The order you want to tab through with Enter:
          function focusChain(){
		  return [elInf, inpPrep, pIch, pDu, pEr, pIhr, inpPast, elPart]
			.filter(el => el && !el.disabled && el.offsetParent !== null);
		}

       
        function focusNextFrom(current){
		  const list = focusChain();
		  const i = list.indexOf(current);
		  if (i >= 0 && i < list.length - 1) {
			const nextEl = list[i+1];
			nextEl.focus({preventScroll:true});
			scrollFieldIntoView(nextEl);
		  } else {
			elCheck?.click();
		  }
		}

        // Add Enter key handler to each input
		[elInf, inpPrep, pIch, pDu, pEr, pIhr, inpPast, elPart].forEach(el => {
		  el?.addEventListener('keydown', (e) => {
			if (e.key === 'Enter') {
			  e.preventDefault();

			  const list   = focusChain();
			  const lastEl = list[list.length - 1];
			  const isLast = (e.target === lastEl);

			  if (isLast) {
				if (!lastFieldCheckedOnce) {
				  // First Enter on last field => CHECK
				  elCheck?.click();
				  e.target.focus({ preventScroll: true });
				  scrollFieldIntoView(e.target);
				} else {
				  // Second Enter on last field => NEXT, then focus first field
				  elNext?.click();
				  setTimeout(() => {
					elInf?.focus({ preventScroll: true });
					scrollFieldIntoView(elInf);
				  }, 150);
				}
			  } else {
				// Normal path: go to next field
				focusNextFrom(e.target);
			  }
			}
		  });
		});

          
        /* Helpers */
        function lsGet(key, fallback) {
          try { const v = localStorage.getItem(key); return v ? JSON.parse(v) : fallback; } catch { return fallback; }
        }
        function lsSet(key, val) { try { localStorage.setItem(key, JSON.stringify(val)); } catch {} }
        function lsGetInt(key, fallback) {
          const v = localStorage.getItem(key); const n = v===null?NaN:parseInt(v,10); return Number.isFinite(n)?n:fallback;
        }
        function lsSetInt(key, n) { try { localStorage.setItem(key, String(n)); } catch {} }
        function norm(s){ return (s||'').trim().toLowerCase().replaceAll('ÃŸ','ss').replaceAll('Ã¤','ae').replaceAll('Ã¶','oe').replaceAll('Ã¼','ue'); }
        function mark(el, ok){ el?.classList.remove('result-ok','result-bad'); el?.classList.add(ok?'result-ok':'result-bad'); }
        
		// Helper: show the correct answer below wrong inputs
		function showCorrect(el, isOK, correctValue){
		  if (!el) return;

		  // remove any old tip element if it exists (harmless if not)
		  const old = el.nextElementSibling;
		  if (old && old.classList && old.classList.contains('correct-tip')) old.remove();

		  // If wrong and we have a correct value, put it directly in the input
		  if (!isOK && correctValue) {
			try { el.value = correctValue; } catch(_) {}
		  }
		}

		
		function updateLevelIndicator(){
		  const el = document.getElementById('verbs-level-indicator');
		  if (!el) return;
		  if (isKapitelMixMode()){
			el.style.display = 'none';
			return;
		  }
		  el.style.display = '';
		  if (!verbsState?.data?.length) return;

		  const level = verbsState.level || 1;
		  const totalUpToLevel = Math.min(level * 25, verbsState.data.length);
		  const idsUpToLevel = verbsState.data.slice(0, totalUpToLevel).map(v => v.id || `${v.lemma}_${v.english}`);
		  const doneUpToLevel = idsUpToLevel.filter(id => (verbsState.streaks?.[id] || 0) >= 3).length;
		  el.textContent = `Level ${level} â€¢ ${doneUpToLevel}/${totalUpToLevel} mastered`;
		}



		//Scroll to focus the text field helper
		function scrollFieldIntoView(el){
		  if (!el) return;
		  // small delay helps on mobile when keyboard pops
		  setTimeout(()=>{ try { el.scrollIntoView({ behavior:'smooth', block:'center' }); } catch(_){} }, 50);
		}

		
        /* Mode switch (non-destructive) */
        function getMode(){ return localStorage.getItem(MODE_KEY) || 'vocab'; }
        function setMode(m){ localStorage.setItem(MODE_KEY, m); renderMode(); }
        function renderMode(){
          const mode = localStorage.getItem(MODE_KEY) || 'vocab';
        
          // Highlight the active mode button
          document.querySelectorAll('#mode-switch .mode-btn').forEach(btn=>{
            btn.classList.toggle('active', btn.dataset.mode === mode);
          });
        
          // Sections we want to show/hide
			const vocab = document.getElementById('vocab-wrapper');
			const verbs = document.getElementById('verbs-card');

			// Show Verbs card only in "verbs" mode
			if (verbs) verbs.hidden = (mode !== 'verbs');

			// Show Vocab only in "vocab" (Mix is handled by the Mix renderer)
			if (vocab) vocab.style.display = (mode === 'vocab') ? '' : 'none';


        
          // If entering verbs, (re)render a fresh card
          if (mode === 'verbs') {
            chosenAux = null;          // from the verbs add-on state
            renderVerbsCard?.();       // safe call in case itâ€™s not defined yet
          }
        }
        elModeSwitch?.addEventListener('click', (e)=>{
          if(e.target.matches('.mode-btn')){
            setMode(e.target.dataset.mode);
          }
        });
        
        /* Load verbs data
           - Tries verbs.csv (same folder) with header:
             id,lemma,english,aux,ich,du,er,wir,ihr,sie,partizip
           - If not found, uses a small mock so you can test UI immediately.
        */
        async function loadVerbsData(){
          let rows = null;
          try {
			const csv = await datasetRead('verbs.csv');
			rows = parseCSV(csv);
          } catch(_) {}
          if (!rows || rows.length===0) {
            rows = [
              { id:'v001', lemma:'gehen',  english:'to go',    aux:'sein',  ich:'gehe', du:'gehst', er:'geht', wir:'gehen', ihr:'geht', sie:'gehen', partizip:'gegangen' },
              { id:'v002', lemma:'machen', english:'to make',  aux:'haben', ich:'mache', du:'machst', er:'macht', wir:'machen', ihr:'macht', sie:'machen', partizip:'gemacht' },
              { id:'v003', lemma:'kommen', english:'to come',  aux:'sein',  ich:'komme', du:'kommst', er:'kommt', wir:'kommen', ihr:'kommt', sie:'kommen', partizip:'gekommen' },
            ];
          }
          verbsState.data = rows;
        }
        
        /* Tiny CSV parser (no deps) */
        function parseCSV(text){
          const lines = text.trim().split(/\r?\n/);
          const headers = lines.shift().split(',').map(h=>h.trim());
          return lines.map(line=>{
            const cells = [];
            let cur = '', inQ=false;
            for (let i=0;i<line.length;i++){
              const ch=line[i];
              if (ch==='\"'){ inQ = !inQ; continue; }
              if (ch===',' && !inQ){ cells.push(cur); cur=''; continue; }
              cur += ch;
            }
            cells.push(cur);
            const obj={};
            headers.forEach((h,i)=>obj[h]= (cells[i]||'').trim());
            // ensure id exists
            if (!obj.id) obj.id = 'v_' + obj.lemma + '_' + Math.random().toString(36).slice(2,7);
            return obj;
          });
        }
        
        /* Initialize state from LS */
        function initVerbsState(){
          verbsState.level   = lsGetInt(VERBS_LEVEL_KEY, 1);
          verbsState.unlocked= lsGetInt(VERBS_UNLOCKED_KEY, verbsState.level*25);
          verbsState.index   = lsGetInt(VERBS_INDEX_KEY, 0);
          verbsState.streaks = lsGet(VERBS_STREAKS_KEY, {});
        }
        
        /* Save state to LS */
        function saveVerbsState(){
          lsSetInt(VERBS_LEVEL_KEY, verbsState.level);
          lsSetInt(VERBS_UNLOCKED_KEY, verbsState.unlocked);
          lsSetInt(VERBS_INDEX_KEY, verbsState.index);
          lsSet(VERBS_STREAKS_KEY, verbsState.streaks);
        }
        
        /* Render current verb card */
        function currentVerb(){
		  let pool;
		  if (isKapitelMixMode()){
			const data = verbsState.data.slice();
			const streaks = verbsState.streaks||{};
			const unmastered = data.filter(v => (streaks[v.id]||0) < 3);
			pool = unmastered.length ? unmastered : data; // if all done, let MIX show splash
		  } else {
			pool = verbsState.data.slice(0, Math.min(verbsState.unlocked, verbsState.data.length));
		  }
		  if (!pool.length) return null;
		  const i = Math.max(0, Math.min(verbsState.index % pool.length, pool.length-1));
		  return pool[i];
		}

        
        function clearFieldStyles(){
          [elInf, pIch, pDu, pEr, pIhr, elPart].forEach(el=>el?.classList.remove('result-ok','result-bad'));
        }
        
        function renderVerbsCard(){
          const v = currentVerb();
          if (!v) { elVerbsCard.hidden = true; return; }
		  // --- Show/Hide the Preposition field depending on the verb ---
			const prepRow = document.getElementById('verbs-prep-row');
			if (prepRow) {
			  const hasPrep = !!String(v.preps || '').trim();  // does CSV have any preposition?
			  prepRow.style.display = hasPrep ? '' : 'none';

			  // optional: use first preposition as a placeholder example
			  if (hasPrep && inpPrep) {
				const first = String(v.preps).split(';').map(s => s.trim()).filter(Boolean)[0] || 'auf';
				inpPrep.placeholder = 'e.g., ' + first;
			  } else if (inpPrep) {
				inpPrep.placeholder = 'e.g., auf';
			  }
			}
          clearFieldStyles();
          elEnglish.textContent = v.english || '';
          elInf.value = '';
          elPart.value = '';
          [pIch,pDu,pEr,pIhr].forEach(el=>{ if(el) el.value=''; });
		  
		  // Enter-behavior state reset for the last field
			lastFieldCheckedOnce = false;

      
          if (inpPrep) inpPrep.value = '';
		  
		  // --- NEW: reset extra governance fields for each new card ---

			// Preposition input (just the preposition, e.g., "auf")
			if (inpPrep) inpPrep.value = '';

			// Past (PrÃ¤teritum) input (e.g., "ging")
			if (inpPast) inpPast.value = '';

			// Case buttons (Inf/Akk/Dat)
			chosenCase = null;
			caseBtns.forEach(b => b.classList.remove('selected'));

			// Reflexive buttons (Yes/No)
			chosenRefl = null;
			reflBtns.forEach(b => b.classList.remove('selected'));
      
			// -- reset field and button colors for a fresh card --
			[elInf, inpPrep, pIch, pDu, pEr, pIhr, inpPast, elPart].forEach(el=>{
			  el?.classList.remove('result-ok','result-bad');
			});

			// keep selections (user's choice) but clear correctness coloring
			[...elAuxBtns, ...caseBtns, ...reflBtns].forEach(btn=>{
			  btn.classList.remove('result-ok','result-bad','choice-correct','choice-wrong');
			});

		  
          // Reset preposition & reflexive UI (new feature)
          if (inpPrep) inpPrep.value = '';               // reset preposition dropdown
          chosenRefl = null;                             // forget previous yes/no choice
          reflBtns.forEach(b=>b.classList.remove('selected'));  // unselect both buttons
          if (selReflCase) { 
            selReflCase.value = 'Akk';                   // set default case to Akkusativ
            selReflCase.disabled = true;                 // keep it disabled until "Yes" is clicked
          }
      
          // aux UI reset
          elAuxBtns.forEach(btn=>btn.classList.remove('selected'));
          elAuxBadge.style.display='none';
          elAuxBadge.textContent='';
          elAuxFixed.textContent='â€”';
          elFeedback.textContent='';
		  
		  // remove any old correct tips
			document.querySelectorAll('.correct-tip').forEach(tip => tip.remove());

			updateLevelIndicator();


        }
        
        // Function to select auxiliary (haben/sein)
        function selectAux(aux){ // 'haben' or 'sein'
          chosenAux = aux;
          elAuxBtns.forEach(b=>b.classList.toggle('selected', b.dataset.aux === aux));
          elAuxBadge.style.display='inline-block';
          elAuxBadge.textContent = aux;
          elAuxFixed.textContent = (aux === 'haben') ? 'habe' : 'bin';
        }
        
        // Make sure clicking buttons doesnâ€™t close the keyboard
        elAuxBtns.forEach(btn=>{
          // On touch or click, prevent the input from losing focus
          btn.addEventListener('mousedown', (e)=>{ 
            e.preventDefault();            // stop losing focus
            selectAux(btn.dataset.aux);    // handle logic
            if (lastInputFocus) lastInputFocus.focus({preventScroll:true}); // refocus
          });
          btn.addEventListener('touchstart', (e)=>{ 
            e.preventDefault(); 
            selectAux(btn.dataset.aux);
            if (lastInputFocus) lastInputFocus.focus({preventScroll:true});
          }, {passive:false});
          // Also handle desktop clicks normally
          btn.addEventListener('click', ()=> selectAux(btn.dataset.aux));
        });
      
		// === CASE BUTTONS (Inf / Akk / Dat) ===

		// function to remember which case you picked
		function selectCase(val){ // 'inf' | 'akk' | 'dat'
		  chosenCase = val;
		  caseBtns.forEach(b => 
			b.classList.toggle('selected', b.dataset.case === val)
		  );
		}

		// these make sure tapping buttons on mobile doesn't close keyboard
		caseBtns.forEach(btn=>{
		  btn.addEventListener('mousedown', (e)=>{
			e.preventDefault();                     // stop losing focus
			selectCase(btn.dataset.case);           // mark this case as chosen
			if (lastInputFocus)                     // if a text field was focused...
			  lastInputFocus.focus({preventScroll:true}); // ...keep it focused
		  });

		  btn.addEventListener('touchstart', (e)=>{
			e.preventDefault(); 
			selectCase(btn.dataset.case);
			if (lastInputFocus)
			  lastInputFocus.focus({preventScroll:true});
		  }, {passive:false});

		  // desktop fallback (works even if you donâ€™t need it)
		  btn.addEventListener('click', ()=> selectCase(btn.dataset.case));
		});
	  
	  
          // Function to choose reflexive yes/no
          function selectRefl(val){ // 'yes' or 'no'
            chosenRefl = val;
            reflBtns.forEach(b=>b.classList.toggle('selected', b.dataset.refl === val));
            if (selReflCase) selReflCase.disabled = (val !== 'yes');

          }
          
            // Prevent losing focus so keyboard stays up
            reflBtns.forEach(btn=>{
              btn.addEventListener('mousedown', (e)=>{ 
                e.preventDefault();
                selectRefl(btn.dataset.refl);
                if (lastInputFocus) lastInputFocus.focus({preventScroll:true});
              });
              btn.addEventListener('touchstart', (e)=>{ 
                e.preventDefault();
                selectRefl(btn.dataset.refl);
                if (lastInputFocus) lastInputFocus.focus({preventScroll:true});
              }, {passive:false});
              btn.addEventListener('click', ()=> selectRefl(btn.dataset.refl));
            });
      
      
        
        /* Check logic: full card must be correct to increment streak (3x target) */
		function checkVerbsCard(){
		  const v = currentVerb();
		  if (!v) return;

		  // --- 1) Basic checks (infinitive, aux, PrÃ¤sens, past, partizip) ---
		  const okInf  = norm(elInf.value)   === norm(v.lemma || '');
		  // AUX supports "sein" or "haben" or "sein/haben" in CSV
		  const allowedAux = String(v.aux || '').toLowerCase().split('/').map(s=>s.trim()).filter(Boolean);
		  const okAux  = allowedAux.includes((chosenAux || '').toLowerCase());

		  const okIch  = norm(pIch.value)    === norm(v.ich || '');
		  const okDu   = norm(pDu.value)     === norm(v.du || '');
		  const okEr   = norm(pEr.value)     === norm(v.er || '');
		  const okIhr  = norm(pIhr.value)    === norm(v.ihr || '');

		  const okPast = norm((inpPast?.value)||'') === norm(v.past || '');
		  const okPart = norm(elPart.value)  === norm(v.partizip || '');

		  // Mark the text inputs green/red
		  mark(elInf, okInf);
		  // Aux buttons visual
		  // Aux buttons: user's wrong pick = red, correct pick(s) = orange, right pick = green
			elAuxBtns.forEach(b=>{
			  b.classList.remove('result-ok','result-bad','choice-correct','choice-wrong');
			  const btnAux = (b.dataset.aux || '').toLowerCase();
			  const isUserPick  = (chosenAux || '').toLowerCase() === btnAux;
			  const isCorrectOp = allowedAux.includes(btnAux);

			  if (okAux && isUserPick) {
				// user picked a correct one -> green
				b.classList.add('result-ok');
			  } else if (!okAux) {
				// user is wrong: mark their pick red, and show the correct option(s) in orange
				if (isUserPick) b.classList.add('choice-wrong');
				if (!isUserPick && isCorrectOp) b.classList.add('choice-correct');
			  }
			});

		  
		  
		  mark(pIch, okIch); mark(pDu, okDu); mark(pEr, okEr); mark(pIhr, okIhr);
		  mark(inpPast, okPast); mark(elPart, okPart);
		  
		  
		  // --- 2) Preposition (CSV now has ONLY the preposition(s)) ---
		  // CSV: preps = "auf;an;mit" or "" (empty means: no preposition requirement)
		  let okPrep = true;
		  const csvPreps = String(v.preps || '').split(';').map(s=>s.trim().toLowerCase()).filter(Boolean); // ["auf","an"]
		  if (csvPreps.length) {
			const userPrep = (inpPrep?.value || '').trim().toLowerCase();
			okPrep = csvPreps.includes(userPrep);
			if (inpPrep) {
			  inpPrep.classList.remove('result-ok','result-bad');
			  inpPrep.classList.add(okPrep ? 'result-ok' : 'result-bad');
			}
		  }

		  // --- 3) Case after the verb (buttons: Inf / Akk / Dat) ---
		  // CSV: case = "Inf" | "Akk" | "Dativ" (or empty)
		  let okCase = true;
		  const csvCaseRaw = String(v.case || '').trim().toLowerCase(); // "inf" | "akk" | "dativ"
		  // normalize variants
		  const csvCase = csvCaseRaw
			.replace('akkusativ','akk')
			.replace('dativ','dat')
			.replace('infinitiv','inf');
		  if (csvCase) {
			okCase = (chosenCase === csvCase); // chosenCase is 'inf' | 'akk' | 'dat'
			// Case buttons: chosenCase vs csvCase ('inf' | 'akk' | 'dat')
			caseBtns.forEach(b=>{
			  b.classList.remove('result-ok','result-bad','choice-correct','choice-wrong');
			  if (!csvCase) return; // nothing to check for this verb

			  const btnVal = (b.dataset.case || '').toLowerCase(); // 'inf' | 'akk' | 'dat'
			  const isUserPick  = chosenCase === btnVal;
			  const isCorrectOp = (btnVal === csvCase);

			  if (okCase && isUserPick) {
				b.classList.add('result-ok');
			  } else if (!okCase) {
				if (isUserPick) b.classList.add('choice-wrong');
				if (!isUserPick && isCorrectOp) b.classList.add('choice-correct');
			  }
			});

		  }

		  // --- 4) Reflexive (Yes/No only) ---
		  // CSV: reflexive = True/False (boolean-ish)
		  let okRefl = true;
		  const needRefl = String(v.reflexive || '').toLowerCase(); // "true" | "false" | ""
		  if (needRefl === 'true') {
			okRefl = (chosenRefl === 'yes');
		  } else if (needRefl === 'false') {
			// allow 'no' or untouched (null) to count as correct non-reflexive
			okRefl = (chosenRefl === 'no' || chosenRefl === null);
		  }
			// Reflexive buttons: csv 'true' => yes is correct, 'false' => no is correct, '' => not checked
			reflBtns.forEach(b=>{
			  b.classList.remove('result-ok','result-bad','choice-correct','choice-wrong');
			  if (!needRefl) return; // no reflexive requirement for this verb

			  const btnVal = (b.dataset.refl || '').toLowerCase(); // 'yes' | 'no'
			  const correctVal = (needRefl === 'true') ? 'yes' : 'no';
			  const isUserPick  = (chosenRefl || 'no') === btnVal; // null counts like 'no' here
			  const isCorrectOp = (btnVal === correctVal);

			  if (okRefl && isUserPick) {
				b.classList.add('result-ok');
			  } else if (!okRefl) {
				if (isUserPick) b.classList.add('choice-wrong');
				if (!isUserPick && isCorrectOp) b.classList.add('choice-correct');
			  }
			});

		  
		  // --- show correct answers under wrong fields ---
			showCorrect(elInf, okInf, v.lemma);
			showCorrect(pIch, okIch, v.ich);
			showCorrect(pDu, okDu, v.du);
			showCorrect(pEr, okEr, v.er);
			showCorrect(pIhr, okIhr, v.ihr);
			showCorrect(inpPast, okPast, v.past);
			showCorrect(elPart, okPart, v.partizip);
			showCorrect(inpPrep, okPrep, v.preps);

		  // --- 5) Final pass/fail & scoring ---
		  const allOK =
			okInf && okAux &&
			okIch && okDu && okEr && okIhr &&
			okPast && okPart && okPrep && okCase && okRefl;

		  // Base fields we always check now: 8
		  // (inf, aux, ich, du, er, ihr, past, partizip)
		  let total = 8;
		  if (csvPreps.length) total += 1;       // preposition present in CSV
		  if (csvCase)          total += 1;       // case present in CSV
		  if (needRefl)         total += 1;       // reflexive requirement present

		  // Update per-verb streak
		  const id = v.id || `${v.lemma}_${v.english}`;
		  const cur = verbsState.streaks[id] || 0;
		  verbsState.streaks[id] = allOK ? Math.min(3, cur + 1) : 0;

		  // Unlock next levels if needed
		  if (!isKapitelMixMode()){
			  maybeUnlockNextVerbsLevel();
			}
			saveVerbsState();


		  // Feedback
		  elFeedback.textContent = allOK
			? `âœ… Perfect! Streak for "${v.lemma}" is now ${verbsState.streaks[id]}/3.`
			: `âŒ Not quite. Streak for "${v.lemma}" reset to 0.`;
			updateLevelIndicator();


		  // Optional global hook (if you had one)
		  try {
			if (typeof updateStreak === 'function') {
			  updateStreak({ mode: 'verbs', passed: allOK, correctFields: allOK?total:0, totalFields: total });
			}
		  } catch(_) {}
		}

        
        /* Unlock logic identical shape to your vocab levels */
        function allVerbsInCurrentLevelComplete(){
          const need = verbsState.level * 25;
          const ids = verbsState.data.slice(0, Math.min(need, verbsState.data.length)).map(v=>v.id);
          return ids.length>0 && ids.every(id => (verbsState.streaks[id]||0) >= 3);
        }
        function maybeUnlockNextVerbsLevel(){
          if (allVerbsInCurrentLevelComplete()){
            verbsState.level += 1;
            verbsState.unlocked = Math.min(verbsState.level * 25, verbsState.data.length);
            // You can show a toast here if you have one
          }
        }
        
        /* Navigation */
        function nextVerb(){
          // Prefer items that are < 3 streak within unlocked set
          let pool;
			if (isKapitelMixMode()){
			  const data = verbsState.data.slice();
			  const streaks = verbsState.streaks||{};
			  const unmastered = data.filter(v => (streaks[v.id]||0) < 3);
			  pool = unmastered.length ? unmastered : data;
			} else {
			  pool = verbsState.data.slice(0, Math.min(verbsState.unlocked, verbsState.data.length));
			}
			if (!pool.length) return;

			let nextIdx = (verbsState.index + 1) % pool.length;
			const start = nextIdx;
			do{
			  const id = pool[nextIdx].id;
			  if ((verbsState.streaks[id]||0) < 3) break;
			  nextIdx = (nextIdx + 1) % pool.length;
			}while(nextIdx !== start);

			verbsState.index = nextIdx;
          saveVerbsState();
          chosenAux = null;
          renderVerbsCard();
		    // MIX: rotate to another section after moving to next
		  if ((typeof getMode==='function' ? getMode() : window.mode) === 'mix') {
			const section = pickRandomSection();
			renderForSection(section);
			return;
		  }

        }
        
        /* Wire buttons */
        elCheck?.addEventListener('click', checkVerbsCard);
        elNext ?.addEventListener('click', nextVerb);
        
        /* Boot */
        (async function initVerbs(){
          document.body.classList.add('dark'); // enables black mode
          
          await loadVerbsData();
          initVerbsState();
          renderMode();
		  updateLevelIndicator();

        
          // If first time and no mode saved, keep your site behavior (vocab default).
          if (!localStorage.getItem(MODE_KEY)) localStorage.setItem(MODE_KEY, 'vocab');
        
          if (getMode() === 'verbs') renderVerbsCard();
        
          // Re-render verbs card whenever switching to verbs mode
          const obs = new MutationObserver(()=>{ if(getMode()==='verbs') renderVerbsCard(); });
          obs.observe(document.getElementById('mode-switch'), { attributes:true, childList:true, subtree:true });
        })();

       
     /* ============================================
     Adjectives & Adverbs (Adj/Adv) â€” simple trainer
     ============================================= */
        
        /* LocalStorage keys */
        const ADJADV_LEVEL_KEY   = 'adjadv_level';
        const ADJADV_UNLOCKED_KEY= 'adjadv_unlocked_count';
        const ADJADV_INDEX_KEY   = 'adjadv_index';
        const ADJADV_STREAKS_KEY = 'adjadv_streaks';
        
        /* State */
        const adjadvState = {
          data: [],     // {id, english, german, example}
          index: 0,
          level: 1,     // 25 per level
          unlocked: 25,
          streaks: {}   // id -> 0..3
        };
        window.adjadvState = adjadvState; // expose adj/adv to MIX

        /* DOM refs */
        const elAdjAdvCard   = document.getElementById('adjadv-card');
        const elAdjAdvEn     = document.getElementById('adjadv-english');
        const elAdjAdvDe     = document.getElementById('adjadv-german');
        const elAdjAdvEx     = document.getElementById('adjadv-example');
        const elAdjAdvCheck  = document.getElementById('adjadv-check');
        const elAdjAdvNext   = document.getElementById('adjadv-next');
        const elAdjAdvFb     = document.getElementById('adjadv-feedback');
        
        /* Helpers */
        function aa_lsGet(key, fallback){ try{const v=localStorage.getItem(key); return v?JSON.parse(v):fallback;}catch{ return fallback; } }
        function aa_lsSet(key, val){ try{ localStorage.setItem(key, JSON.stringify(val)); }catch{} }
        function aa_lsGetInt(key, fallback){ const v=localStorage.getItem(key); const n=v===null?NaN:parseInt(v,10); return Number.isFinite(n)?n:fallback; }
        function aa_lsSetInt(key, n){ try{ localStorage.setItem(key, String(n)); }catch{} }
        function aa_norm(s){ return (s||'').trim().toLowerCase().replaceAll('ÃŸ','ss').replaceAll('Ã¤','ae').replaceAll('Ã¶','oe').replaceAll('Ã¼','ue'); }
        
        function aa_initState(){
          adjadvState.level    = aa_lsGetInt(ADJADV_LEVEL_KEY, 1);
          adjadvState.unlocked = aa_lsGetInt(ADJADV_UNLOCKED_KEY, 25);
          adjadvState.index    = aa_lsGetInt(ADJADV_INDEX_KEY, 0);
          adjadvState.streaks  = aa_lsGet(ADJADV_STREAKS_KEY, {});
        }
        function aa_saveState(){
          aa_lsSetInt(ADJADV_LEVEL_KEY, adjadvState.level);
          aa_lsSetInt(ADJADV_UNLOCKED_KEY, adjadvState.unlocked);
          aa_lsSetInt(ADJADV_INDEX_KEY, adjadvState.index);
          aa_lsSet(ADJADV_STREAKS_KEY, adjadvState.streaks);
        }
        
        /* Load data from adjadv.csv (english,german,example) */
        async function aa_loadData(){
		  try {
			const csv  = await datasetRead('adjadv.csv');
			const rows = parseCSV(csv);

			// Normalize to objects we expect: {id, english, german, example}
			if (Array.isArray(rows) && rows.length) {
			  // rows might already be objects (when CSV had headers)
			  if (typeof rows[0] === 'object' && ('english' in rows[0] || 'german' in rows[0])) {
				adjadvState.data = rows.map((r,i)=>({
				  id: r.id || ('aa_' + (r.german || r.english || ('i'+i)).replace(/\s+/g,'_') + '_' + i),
				  english: r.english || '',
				  german:  r.german  || '',
				  example: r.example || ''
				}));
			  } else {
				// rows might be arrays (no headers) â†’ [english,german,example]
				adjadvState.data = rows.map((cols,i)=>({
				  id: 'aa_' + i,
				  english: (cols[0]||'').trim(),
				  german:  (cols[1]||'').trim(),
				  example: (cols[2]||'').trim()
				}));
			  }
			} else {
			  // Fallback demo data if CSV empty
			  adjadvState.data = [
				{ id:'aa001', english:'beautiful', german:'schÃ¶n',     example:'Das ist ein schÃ¶nes Haus.' },
				{ id:'aa002', english:'slow',      german:'langsam',   example:'Er fÃ¤hrt langsam.' },
				{ id:'aa003', english:'quickly',   german:'schnell',   example:'Sie lÃ¤uft schnell.' }
			  ];
			}
		  } catch {
			// Fallback if file missing or parse failed
			adjadvState.data = [
			  { id:'aa001', english:'beautiful', german:'schÃ¶n',   example:'Das ist ein schÃ¶nes Haus.' },
			  { id:'aa002', english:'slow',      german:'langsam', example:'Er fÃ¤hrt langsam.' }
			];
		  }
		}
        
        /* Current item helpers */
        function aa_pool(){
		  if (isKapitelMixMode()) return adjadvState.data.slice();
		  return adjadvState.data.slice(0, Math.min(adjadvState.unlocked, adjadvState.data.length));
		}

        function aa_current(){
          const p = aa_pool(); if(!p.length) return null;
          const i = Math.max(0, Math.min(adjadvState.index % p.length, p.length-1));
          return p[i];
        }
        
        /* Render & actions */
        function aa_clearStyles(){ elAdjAdvDe?.classList.remove('result-ok','result-bad'); }
        function aa_render(){
          const it = aa_current();
          if(!it){ elAdjAdvCard.hidden = true; return; }
          aa_clearStyles();
          elAdjAdvCard.hidden = false;
          elAdjAdvEn.textContent = it.english || '';
		  elAdjAdvEx.textContent = it.example ? 'ðŸ“ ' + it.example : '';
          elAdjAdvDe.value = '';
          elAdjAdvFb.textContent = '';
		  adjadvEnterCount = 0; // reset Enter counter each time a new word loads
          setTimeout(()=>{ elAdjAdvDe?.focus(); }, 0);
        }
        
        function aa_allInLevelMastered(){
          const need = adjadvState.level * 25;
          const ids = adjadvState.data.slice(0, Math.min(need, adjadvState.data.length)).map(x=>x.id);
          return ids.length>0 && ids.every(id => (adjadvState.streaks[id]||0) >= 3);
        }
        function aa_maybeUnlockNext(){
          if(aa_allInLevelMastered()){
            adjadvState.level += 1;
            adjadvState.unlocked = Math.min(adjadvState.level * 25, adjadvState.data.length);
          }
        }
        
        function aa_check(){
          const it = aa_current(); if(!it) return;
          const ok = aa_norm(elAdjAdvDe.value) === aa_norm(it.german);
          elAdjAdvDe.classList.add(ok ? 'result-ok' : 'result-bad');
          const cur = adjadvState.streaks[it.id] || 0;
          adjadvState.streaks[it.id] = ok ? Math.min(3, cur+1) : 0;
          aa_maybeUnlockNext();
          aa_saveState();
          elAdjAdvFb.textContent = ok
            ? `âœ… Correct! Streak for "${it.german}" is now ${adjadvState.streaks[it.id]}/3.`
            : `âŒ Wrong. Correct: ${it.german}`;
        }
        function aa_next(){
          const p = aa_pool(); if(!p.length) return;
          // Prefer items with streak < 3
          let next = (adjadvState.index + 1) % p.length;
          const start = next;
          do{
            const id = p[next].id;
            if ((adjadvState.streaks[id]||0) < 3) break;
            next = (next + 1) % p.length;
          }while(next !== start);
          adjadvState.index = next;
          aa_saveState();
          aa_render();
		  
		    // MIX: rotate to another section after moving to next
			  if ((typeof getMode==='function' ? getMode() : window.mode) === 'mix') {
				const section = pickRandomSection();
				renderForSection(section);
				return;
			  }
        }
        
        /* Wire buttons */
        elAdjAdvCheck?.addEventListener('click', aa_check);
        elAdjAdvNext ?.addEventListener('click', ()=>{
          aa_next();
          // if MIX mode, after moving within this pool, switch to a random section
          if (getMode()==='mix') pickRandomSectionAndRender();
        });
		// Two-step Enter behavior: first Enter = check, second = next
		let adjadvEnterCount = 0;

		elAdjAdvDe?.addEventListener('keydown', (e)=>{
		  if (e.key === 'Enter') {
			e.preventDefault();
			adjadvEnterCount++;
			if (adjadvEnterCount === 1) {
			  aa_check();
			} else if (adjadvEnterCount === 2) {
			  adjadvEnterCount = 0;
			  aa_next();
			  // If in Mix mode, switch to another section after next
			  if (getMode() === 'mix') {
				pickRandomSectionAndRender();
			  }
			}
		  }
		});

        
        /* ===== Mix integration =====
           When in MIX, we show one section at a time (vocab/verbs/adjadv).
           - On entering MIX -> pick random section and render.
           - On any "Next" click of the visible section -> advance that pool, then randomly switch section.
        */
		/* MIX can include all trainers. Default = equal weights; tweakable via localStorage 'mix_weights' = {"vocab":1,"verbs":1,"adjadv":1,"preps":1} */
		const MIX_SECTIONS = ['vocab','verbs','adjadv','preps'];

		// Balanced picker that rotates across eligible sections
		function pickNextSectionBalanced(){
		  // Helpers
		  function sectionHasData(s){
			if (s==='vocab')  return Array.isArray(window.words) && window.words.length>0;
			if (s==='verbs')  return Array.isArray(window.verbsState?.data) && window.verbsState.data.length>0;
			if (s==='adjadv') return Array.isArray(window.adjadvState?.data) && window.adjadvState.data.length>0;
			if (s==='preps')  return Array.isArray(window.prepsState?.data) && window.prepsState.data.length>0;
			return false;
		  }

		  // Build candidate list
		  let cand = MIX_SECTIONS.filter(sectionHasData);

		  // In Kapitel+Mix â†’ only unmastered sections
		  if (typeof isKapitelMixMode === 'function' && isKapitelMixMode()) {
			cand = cand.filter(s => (typeof sectionHasUnmastered==='function') ? sectionHasUnmastered(s) : true);
		  }

		  // If nothing left, show splash (Kapitel) or fall back to vocab
		  if (!cand.length){
			if (typeof allKapitelMastered==='function' && isKapitelMixMode() && allKapitelMastered()){
			  if (typeof showKapitelDoneSplash==='function') showKapitelDoneSplash();
			}
			return 'vocab';
		  }

		  // Avoid repeating the same section when another exists
		  const last = window.__mix_last_section || null;
		  if (cand.length>1 && last){
			const alt = cand.filter(s => s !== last);
			if (alt.length) cand = alt;
			  // Round-robin index + remember last pick
			  window.__mix_rr_i = ((window.__mix_rr_i || 0) + 1) % cand.length;
			  const pick = cand[window.__mix_rr_i];
			  window.__mix_last_section = pick;
			  return pick;

		  }

		  // Rotate by round-robin index
		  window.__mix_rr_i = ((window.__mix_rr_i||0) + 1) % cand.length;
		  const pick = cand[window.__mix_rr_i];
		    window.__mix_last_section = pick;
			  console.log('[Mix pick]', pick, {cand, last, rr:window.__mix_rr_i, pools:{
				vocab:(window.words||[]).length,
				verbs:(window.verbsState?.data||[]).length,
				adjadv:(window.adjadvState?.data||[]).length,
				preps:(window.prepsState?.data||[]).length
			  }}, 't='+(Date.now()-__before)+'ms');
			  return pick;

		}

		// === Balanced MIX picker (round-robin, no repeats, Kapitel=only unmastered, skips empty) ===
		function pickWeightedRandomSection(){
			const __before = Date.now();

		  const sections = (typeof MIX_SECTIONS!=='undefined' && Array.isArray(MIX_SECTIONS))
			? MIX_SECTIONS.slice() : ['vocab','verbs','adjadv','preps'];

		  // has any data?
		  function hasData(s){
			if (s==='vocab')  return Array.isArray(window.words) && window.words.length>0;
			if (s==='verbs')  return Array.isArray(window.verbsState?.data) && window.verbsState.data.length>0;
			if (s==='adjadv') return Array.isArray(window.adjadvState?.data) && window.adjadvState.data.length>0;
			if (s==='preps')  return Array.isArray(window.prepsState?.data) && window.prepsState.data.length>0;
			return false;
		  }

		  // unmastered check (self-contained; no external helpers needed)
		  function hasUnmastered(s){
			const thr = window.masteryThreshold || 3;

			if (s==='vocab'){
			  const arr = window.words || [];
			  return arr.some(w => (w.correctStreak||0) < thr);
			}
			if (s==='verbs'){
			  const data = window.verbsState?.data || [];
			  const streaks = window.verbsState?.streaks || {};
			  return data.some(v => (streaks[v.id]||0) < 3);
			}
			if (s==='adjadv'){
			  const data = window.adjadvState?.data || [];
			  const streaks = window.adjadvState?.streaks || {};
			  return data.some(x => (streaks[x.id]||0) < 3);
			}
			if (s==='preps'){
			  const data = window.prepsState?.data || [];
			  const streaks = window.prepsState?.streaks || {};
			  return data.some(x => (streaks[x.id]||0) < 3);
			}
			return false;
		  }

		  // start from sections that actually have data
		  let cand = sections.filter(hasData);

		  // if Kapitel+Mix, only keep sections with unmastered items
		  const inKapitelMix = (window.currentDataset?.key === 'kapitel') && ((typeof getMode==='function' ? getMode() : window.mode) === 'mix');
		  if (inKapitelMix) cand = cand.filter(hasUnmastered);

		  // nothing left â†’ just fall back to vocab (your renderMode handles â€œdoneâ€ UX)
		  if (!cand.length) return 'vocab';

		  // avoid repeating last section if alternatives exist
		  const last = window.__mix_last_section || null;
		  if (cand.length>1 && last){
			const alt = cand.filter(s => s !== last);
			if (alt.length) cand = alt;
		  }

		}


		function pickRandomSection(){  // keep old name for existing calls
		  return pickWeightedRandomSection();
		}

        function showOnly(section){ // hide/show sections
		  const vocab = document.getElementById('vocab-wrapper');
		  const verbs = document.getElementById('verbs-card');
		  const adjad = document.getElementById('adjadv-card');
		  const preps = document.getElementById('preps-card');

		  if (section==='vocab'){
			if(vocab) vocab.style.display='';
			if(verbs) verbs.hidden=true;
			if(adjad) adjad.hidden=true;
			if(preps) preps.hidden=true;
		  } else if (section==='verbs'){
			if(vocab) vocab.style.display='none';
			if(verbs) verbs.hidden=false;
			if(adjad) adjad.hidden=true;
			if(preps) preps.hidden=true;
		  } else if (section==='adjadv'){
			if(vocab) vocab.style.display='none';
			if(verbs) verbs.hidden=true;
			if(adjad) adjad.hidden=false;
			if(preps) preps.hidden=true;
		  } else if (section==='preps'){
			if(vocab) vocab.style.display='none';
			if(verbs) verbs.hidden=true;
			if(adjad) adjad.hidden=true;
			if(preps) preps.hidden=false;
		  }
		}

        function renderForSection(section){
		  if (section==='vocab'){
			try { nextWord(); } catch {}
		  } else if (section==='verbs'){
			try { renderVerbsCard(); } catch {}
		  } else if (section==='adjadv'){
			try { aa_render(); } catch {}
		  } else if (section==='preps'){
			try { if (typeof pp_render === 'function') pp_render(); } catch {}
		  }
		  showOnly(section);
		}

        function pickRandomSectionAndRender(){
          const s = pickRandomSection();
          renderForSection(s);
        }
        
        /* Extend existing renderMode to include adjadv + mix */
        const _origRenderMode = renderMode;
        renderMode = function(){
          _origRenderMode(); // keeps original show/hide for vocab & verbs
          const mode = getMode();
        
          const vocab = document.getElementById('vocab-wrapper');
          const verbs = document.getElementById('verbs-card');
          const adjad = document.getElementById('adjadv-card');
        
          // Show Adj/Adv only in "adjadv" mode
          if (adjad) adjad.hidden = !(mode==='adjadv' || mode==='mix');
        
          // For "vocab": (keep original) -> vocab visible, others hidden by original code
          // For "verbs": (keep original) -> verbs visible
          // For "adjadv": hide vocab & verbs, show adjadv
          if (mode==='adjadv'){
            if(vocab) vocab.style.display='none';
            if(verbs) verbs.hidden = true;
            if(adjad) { adjad.hidden = false; aa_render(); }
          }
        
          // For "mix": pick one section randomly and render only that
          if (mode==='mix'){
		  // Hide any level badges when studying Kapitel
		  if (isKapitelMixMode()){
			const lvl = document.getElementById('level'); if (lvl) lvl.style.display='none';
			const vi  = document.getElementById('verbs-level-indicator'); if (vi) vi.style.display='none';
		  }

		  if (allKapitelMastered()){ showKapitelDoneSplash(); return; }

		  const section = pickRandomSection();
		  renderForSection(section);
        
            // Also tweak each card's Next to jump to a new random section after it advances:
            // (Vocab) â€” hook its Next button (id="nextBtn")
            const vbNext = document.getElementById('nextBtn');
            if (vbNext && !vbNext._mixHooked){
              vbNext._mixHooked = true;
              const orig = vbNext.onclick;
              vbNext.addEventListener('click', ()=>{
                setTimeout(()=>{ if(getMode()==='mix') pickRandomSectionAndRender(); }, 0);
              });
            }
            // (Verbs) â€” already hooked above in elNext listener (added set for mix)
            // (Adj/Adv) â€” already hooked above in elAdjAdvNext listener
          }
        };
        
		/* (Preps) â€” after Next, reset Enter phase and jump to a fresh random section in MIX */
		const ppNext = document.getElementById('preps-next');
		if (ppNext && !ppNext._mixHooked){
		  ppNext._mixHooked = true;
		  ppNext.addEventListener('click', ()=>{
			window.ppEnterPhase = 0; // reset so first Enter = check again
			setTimeout(()=>{ if (typeof getMode==='function' && getMode()==='mix') pickRandomSectionAndRender(); }, 0);
		  });
		}

		/* Preps Enter behavior: first Enter checks, second Enter goes next */
		(function(){
		  // global-ish flag
		  if (typeof window.ppEnterPhase === 'undefined') window.ppEnterPhase = 0;

		  function qsPrepsInput(){
			// Try common ids/selectors for the preps answer field
			return document.getElementById('preps-input')
				|| document.getElementById('preps-answer')
				|| document.querySelector('#preps-card input[type="text"], #preps-card input');
		  }
		  function btnPrepsCheck(){
			return document.getElementById('preps-check')
				|| document.querySelector('#preps-card [data-role="preps-check"], #preps-card [data-action="check"]')
				|| Array.from(document.querySelectorAll('#preps-card button'))
					  .find(b => /check|prÃ¼fen|Ã¼berprÃ¼fen/i.test(b.textContent||''));
		  }
		  function btnPrepsNext(){
			return document.getElementById('preps-next')
				|| document.querySelector('#preps-card [data-role="preps-next"], #preps-card [data-action="next"]')
				|| Array.from(document.querySelectorAll('#preps-card button'))
					  .find(b => /next|weiter|nÃ¤chste/i.test(b.textContent||''));
		  }

		  function ensurePrepsEnterWiring(){
			const input = qsPrepsInput();
			if (!input || input._ppEnterWired) return;
			input._ppEnterWired = true;

			input.addEventListener('keydown', (e)=>{
			  if (e.key !== 'Enter') return;

			  // Always stop the default so we control the flow
			  e.preventDefault();
			  e.stopPropagation();

			  const checkBtn = btnPrepsCheck();
			  const nextBtn  = btnPrepsNext();

			  // first Enter â†’ check (if there is a check button), second Enter â†’ next
			  if (window.ppEnterPhase === 0){
				// if no explicit check button, fall back to "Next" (some UIs auto-check on next)
				if (checkBtn) { checkBtn.click(); }
				else if (nextBtn) { nextBtn.click(); }
				window.ppEnterPhase = 1;
			  } else {
				if (nextBtn) { nextBtn.click(); }
				window.ppEnterPhase = 0; // reset for the next item
			  }
			});

			// If the user edits the input again, go back to "first Enter = check"
			input.addEventListener('input', ()=> { window.ppEnterPhase = 0; });
		  }

		  // Run now and also whenever Preps card becomes visible
		  document.addEventListener('DOMContentLoaded', ensurePrepsEnterWiring);
		  const prepsCard = document.getElementById('preps-card');
		  if (prepsCard){
			const obs = new MutationObserver(()=> ensurePrepsEnterWiring());
			obs.observe(prepsCard, { childList:true, subtree:true, attributes:true });
		  }
		})();



		/* (Verbs) â€” after Next, jump to a fresh random section in MIX */
		(function(){
		  const vc = document.getElementById('verbs-card');
		  if (!vc || vc._mixHooked) return;
		  vc._mixHooked = true;

		  // Click: catch any plausible "Next" button inside verbs-card
		  vc.addEventListener('click', (e)=>{
			const t = e.target;
			if (!t) return;
			const isNext =
			  t.id === 'verbs-next' ||
			  t.id === 'vb-next' ||
			  (t.matches && t.matches('[data-role="verbs-next"], [data-action="next"]')) ||
			  (t.tagName === 'BUTTON' && /next/i.test(t.textContent || ''));
			if (isNext){
			  setTimeout(()=>{ if (typeof getMode==='function' && getMode()==='mix') pickRandomSectionAndRender(); }, 0);
			}
		  }, true);
		})();

		/* MIX wrappers: if the app has explicit next functions, wrap them so MIX rotates only after real advances. */
		(function(){
			function wrapNext(fnName){
			  const w = (globalThis || window);
			  if (typeof w[fnName] === 'function' && !w[fnName]._mixWrapped){
				const orig = w[fnName];
				w[fnName] = function(){
				  const out = orig.apply(this, arguments);
				  // New item loaded â†’ reset Enter phase to "check first"
				  window.ppEnterPhase = 0;
				  setTimeout(()=>{ if (typeof getMode==='function' && getMode()==='mix') pickRandomSectionAndRender(); }, 0);
				  return out;
				};
				w[fnName]._mixWrapped = true;
			  }
			}



		  // Try common names you might be using:
		  wrapNext('verbsNext');      // e.g., called when Verbs goes to the next item
		  wrapNext('nextVerb');       // alternative common name
		  wrapNext('renderVerbsNext'); // if you made a specific renderer for next
		  wrapNext('pp_next');        // Preps: your Next handler if named like this
		  wrapNext('prepsNext');      // alternative
		})();

		
        /* Boot Adj/Adv together with verbs init */
        (async function initAdjAdv(){
          await aa_loadData();
          aa_initState();
          // If user switches to adjadv later, aa_render() will run via renderMode().
        })();
   

  </script>
  
  <script>
		/* ===========================================================================================================
		   Prepositions Trainer â€” CSV: prep,forms,de1..de10
		   - "forms" is optional; list variants like: an;am;ans  |  in;im;ins  |  zu;zum;zur  |  bei;beim  |  von;vom
		   - We pick a random non-empty sentence per row.
		   - We blank the FIRST whole-word match from forms (or prep if forms empty).
		   - The ONLY correct answer is the exact surface form found in that sentence (e.g., "am", not "an").
		============================================================================================================= */

		const PREPS_LEVEL_KEY    = 'preps_level';
		const PREPS_UNLOCKED_KEY = 'preps_unlocked_count';
		const PREPS_INDEX_KEY    = 'preps_index';
		const PREPS_STREAKS_KEY  = 'preps_streaks';

		const prepsState = {
		  data: [],       // [{ id, prep, formsArr, sentences: [de1..de10], lastSlot: {left,right,correct,formsArrUsed} }]
		  index: 0,
		  level: 1,
		  unlocked: 25,
		  streaks: {}     // id -> 0..3
		};
		window.prepsState = prepsState; // expose prepositions to MIX

		const elPrepsCard     = document.getElementById('preps-card');
		const elPrepsSentence = document.getElementById('preps-sentence');
		const elPrepsEn       = document.getElementById('preps-english'); // we keep it for layout; we won't show EN now
		const elPrepsCheck    = document.getElementById('preps-check');
		const elPrepsNext     = document.getElementById('preps-next');
		const elPrepsFb       = document.getElementById('preps-feedback');

		/* === Small helpers === */
		function pp_lsGet(key, fallback){ try{const v=localStorage.getItem(key); return v?JSON.parse(v):fallback;}catch{ return fallback; } }
		function pp_lsSet(key, val){ try{ localStorage.setItem(key, JSON.stringify(val)); }catch{} }
		function pp_lsGetInt(key, fallback){ const v=localStorage.getItem(key); const n=v===null?NaN:parseInt(v,10); return Number.isFinite(n)?n:fallback; }
		function pp_lsSetInt(key, n){ try{ localStorage.setItem(key, String(n)); }catch{} }
		function pp_norm(s){ return (s||'').trim().toLowerCase().replaceAll('ÃŸ','ss').replaceAll('Ã¤','ae').replaceAll('Ã¶','oe').replaceAll('Ã¼','ue'); }

		/* CSV -> objects (expects headers) */
		function pp_parseCSV(text){
		  const lines = text.trim().split(/\r?\n/);
		  if(!lines.length) return [];
		  const headers = lines[0].split(',').map(h=>h.trim());
		  return lines.slice(1).map(line=>{
			const cells = []; let cur = '', inQ=false;
			for(let i=0;i<line.length;i++){
			  const ch=line[i];
			  if(ch === '"'){ inQ = !inQ; continue; }
			  if(ch === ',' && !inQ){ cells.push(cur); cur=''; continue; }
			  cur += ch;
			}
			cells.push(cur);
			const obj={};
			headers.forEach((h,i)=> obj[h] = (cells[i]||'').trim());
			return obj;
		  });
		}

		/* Find first whole-word match of any token (prefer longer first) */
		function firstMatchTokenInSentence(formsStr, basePrep, sentence){
		  const base = (basePrep||'').trim();
		  const variants = (formsStr && formsStr.trim())
			  ? formsStr.split(';').map(s=>s.trim()).filter(Boolean)
			  : (base ? [base] : []);
		  const tokens = variants.sort((a,b)=> b.length - a.length);
		  for (const t of tokens){
			if(!t) continue;
			const re = new RegExp(`\\b${t.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\$&')}\\b`, 'i');
			const m = sentence.match(re);
			if (m) return { token: m[0], index: m.index, length: m[0].length, tried: tokens };
		  }
		  return null;
		}

		/* Replace matched token with an inline input */
		function renderSentenceWithBlank(prep, forms, sentence){
		  const hit = firstMatchTokenInSentence(forms, prep, sentence);
		  if (!hit) return null;
		  const left  = sentence.slice(0, hit.index);
		  const right = sentence.slice(hit.index + hit.length);
		  return { left, right, correct: hit.token, formsArrUsed: hit.tried };
		}

		/* === Load data (new CSV shape) === */
		async function pp_loadData(){
		  let rows = null;
		  try{
			const csv = await datasetRead('prepositions.csv');
			rows = pp_parseCSV(csv);

		  }catch(_){}
		  if(!rows || !rows.length){
			// tiny fallback
			rows = [
			  { prep:'an',  forms:'an;am;ans', de1:'Ich warte am Bahnhof', de2:'Er geht ans Fenster' },
			  { prep:'in',  forms:'in;im;ins', de1:'Sie geht ins Kino', de2:'Er wohnt im Haus' },
			  { prep:'zu',  forms:'zu;zum;zur', de1:'Ich gehe zum Arzt' },
			];
		  }

		  // Normalize into our objects
		  prepsState.data = rows.map((r,i)=>{
			const prep = (r.prep||'').trim();
			const forms = (r.forms||'').trim();
			const sentences = [];
			for (let n=1;n<=10;n++){
			  const s = (r['de'+n]||'').trim();
			  if (s) sentences.push(s);
			}
			return {
			  id: 'pp_'+ (prep || 'row') +'_'+ i,
			  prep,
			  formsArr: forms ? forms.split(';').map(s=>s.trim()).filter(Boolean) : [],
			  sentences,
			  lastSlot: null
			};
		  }).filter(x => x.prep && x.sentences && x.sentences.length);
		}

		/* === State init/save === */
		function pp_initState(){
		  prepsState.level    = pp_lsGetInt(PREPS_LEVEL_KEY, 1);
		  prepsState.unlocked = pp_lsGetInt(PREPS_UNLOCKED_KEY, 25);
		  prepsState.index    = pp_lsGetInt(PREPS_INDEX_KEY, 0);
		  prepsState.streaks  = pp_lsGet(PREPS_STREAKS_KEY, {});
		}
		function pp_saveState(){
		  pp_lsSetInt(PREPS_LEVEL_KEY, prepsState.level);
		  pp_lsSetInt(PREPS_UNLOCKED_KEY, prepsState.unlocked);
		  pp_lsSetInt(PREPS_INDEX_KEY, prepsState.index);
		  pp_lsSet(PREPS_STREAKS_KEY, prepsState.streaks);
		}

		/* Pool + current row */
		function pp_pool(){
		  if (isKapitelMixMode()) return prepsState.data.slice();
		  return prepsState.data.slice(0, Math.min(prepsState.unlocked, prepsState.data.length));
		}
		function pp_current(){
		  const p = pp_pool(); if(!p.length) return null;
		  const i = Math.max(0, Math.min(prepsState.index % p.length, p.length-1));
		  return p[i];
		}

		/* === Render round === */
		function pp_render(){
		  const row = pp_current();
		  if(!row){ elPrepsCard.hidden = true; return; }
		  elPrepsCard.hidden = false;
		  elPrepsFb.textContent = '';
		  if (elPrepsEn) elPrepsEn.textContent = ''; // (no EN for now)

		  // Pick a random sentence that actually contains a match
		  let tries = 0, slot = null, chosen = null;
		  const shuffled = row.sentences.slice().sort(()=>Math.random()-0.5);
		  for (const s of shuffled){
			slot = renderSentenceWithBlank(row.prep, row.formsArr.join(';'), s);
			if (slot){ chosen = s; break; }
			if (++tries > row.sentences.length) break;
		  }
		  if (!slot){
			// No safe blank found (e.g., malformed row). Skip gracefully.
			elPrepsSentence.textContent = '(No place to blank in this sentence.)';
			row.lastSlot = null;
			return;
		  }
		  row.lastSlot = slot;

		  // Build input
			const input = document.createElement('input');
			input.id = 'preps-input';
			input.value = '';                 // make sure it starts empty
			input.placeholder = '';           // no hints that give it away
			input.autocomplete = 'off';
			input.autocapitalize = 'off';
			input.spellcheck = false;

		  // Use per-row forms for better suggestions; else fall back to global datalist:
		  if (row.formsArr && row.formsArr.length){
			const dlId = 'preps-options-dyn';
			let dl = document.getElementById(dlId);
			if(!dl){
			  dl = document.createElement('datalist');
			  dl.id = dlId;
			  document.body.appendChild(dl);
			}
			dl.innerHTML = row.formsArr.map(o=>`<option value="${o}"></option>`).join('');
			input.setAttribute('list', dlId);
		  } else {
			input.setAttribute('list', 'preps-options');
		  }
		  input.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); pp_check(); } });

		  // Render sentence: left [input] right
		  elPrepsSentence.innerHTML = '';
		  elPrepsSentence.append(document.createTextNode(slot.left), input, document.createTextNode(slot.right));

		  // Focus
		  setTimeout(()=>{ input.focus(); }, 0);
		}

		/* Leveling like other trainers */
		function pp_allInLevelMastered(){
		  const need = prepsState.level * 25;
		  const ids = prepsState.data.slice(0, Math.min(need, prepsState.data.length)).map(x=>x.id);
		  return ids.length>0 && ids.every(id => (prepsState.streaks[id]||0) >= 3);
		}
		function pp_maybeUnlockNext(){
		  if(pp_allInLevelMastered()){
			prepsState.level += 1;
			prepsState.unlocked = Math.min(prepsState.level * 25, prepsState.data.length);
		  }
		}

		/* === Check === */
		function pp_check(){
		  const row = pp_current();
		  if(!row || !row.lastSlot) return;
		  const input = document.getElementById('preps-input');
		  const val = (input?.value || '').trim();
		  const correct = row.lastSlot.correct;           // exact surface form found in sentence
		  const ok = val.toLowerCase() === correct.toLowerCase();

		  input?.classList.remove('result-ok','result-bad');
		  input?.classList.add(ok ? 'result-ok' : 'result-bad');

		  const cur = prepsState.streaks[row.id] || 0;
		  prepsState.streaks[row.id] = ok ? Math.min(3, cur+1) : 0;
		  pp_maybeUnlockNext();
		  pp_saveState();

		  elPrepsFb.textContent = ok
			? `âœ… Correct! Streak now ${prepsState.streaks[row.id]}/3.`
			: `âŒ Wrong. Correct: ${correct}`;
		}

		/* === Next === */
		function pp_next(){
		  const p = pp_pool(); if(!p.length) return;
		  let next = (prepsState.index + 1) % p.length;
		  const start = next;
		  do{
			const id = p[next].id;
			if ((prepsState.streaks[id]||0) < 3) break;
			next = (next + 1) % p.length;
		  }while(next !== start);
		  prepsState.index = next;
		  pp_saveState();
		  pp_render();
		    // MIX: rotate to another section after moving to next
		  if ((typeof getMode==='function' ? getMode() : window.mode) === 'mix') {
			const section = pickRandomSection();
			renderForSection(section);
			return;
		  }

		}

		/* Wire buttons */
		elPrepsCheck?.addEventListener('click', pp_check);
		elPrepsNext ?.addEventListener('click', pp_next);

		/* Load + init */
		(async function initPreps(){
		  await pp_loadData();
		  pp_initState();
		})();

		/* Hook into renderMode so 'preps' shows this card */
		const _renderMode_preps = renderMode;  // keep previous behavior
		renderMode = function(){
		  _renderMode_preps();

		  const mode = getMode();
		  const vocab = document.getElementById('vocab-wrapper');
		  const verbs = document.getElementById('verbs-card');
		  const adjad = document.getElementById('adjadv-card');
		  const preps = document.getElementById('preps-card');

		  if (mode === 'preps'){
			if (vocab) vocab.style.display = 'none';
			if (verbs) verbs.hidden = true;
			if (adjad) adjad.hidden = true;
			if (preps) { preps.hidden = false; pp_render(); }
		  } else {
			if (preps) preps.hidden = true;
		  }
		};
	</script>



  
</body>
</html>
