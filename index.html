<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"/>
<title>German Trainer</title>

<!-- JSZip for Kapitel package loading -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

<!-- Firebase (optional username-only sync; safe if unused) -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
<!-- FIND â†’ PASTE BELOW: put your Firebase config here -->
<script>
  // Replace the placeholder values with your project's config
  window.firebaseConfig = window.firebaseConfig || {
    apiKey: "AIzaSyAvMyNtFyWM3Ajg2sxpWp4uMErfyawEOMc",
    authDomain: "german-52657.firebaseapp.com",
    databaseURL: "https://german-52657-default-rtdb.europe-west1.firebasedatabase.app",
    projectId: "german-52657",
    storageBucket: "german-52657.firebasestorage.app",
    messagingSenderId: "364706857329",
    appId: "1:364706857329:web:97779c21361db2423336d0"
  };
</script>
<style>
  :root{
    --bg:#0b0e12; --card:#12161d; --text:#e9eef5; --muted:#9aacbf; --border:#243041; --accent:#6aa6ff;
    --good:#22c55e; --bad:#ef4444; --btn:#1a2230; --btn2:#1e2a3c; --hole:#0f141c;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--text);font:16px/1.5 system-ui,-apple-system,Segoe UI,Inter,Roboto,Arial,sans-serif;}
  html{-webkit-text-size-adjust:100%}
  body{touch-action:manipulation}
  a{color:var(--accent)}
  .wrap{max-width:720px;margin:0 auto;padding:14px}
  .bar{display:flex;gap:8px;align-items:center;margin:6px auto 10px;max-width:720px}
  .bar select,.bar button{background:var(--btn);color:var(--text);border:1px solid var(--border);border-radius:10px;padding:10px 12px}
  .bar button:hover{background:var(--btn2)}
  .mode-tabs{display:flex;gap:6px;flex-wrap:wrap;margin:6px 0 12px}
  .mode-btn{border:1px solid var(--border);background:var(--btn);color:var(--text);padding:8px 10px;border-radius:10px;cursor:pointer}
  .mode-btn.active{outline:2px solid var(--accent);background:#0f1420}
  .card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:14px;box-shadow:0 6px 20px rgba(0,0,0,.25)}
  .row{display:grid;grid-template-columns:120px 1fr;gap:10px;align-items:center;margin:8px 0}
  input[type="text"],input[type="search"],input[type="number"],select,textarea{
    width:100%;padding:10px;border:1px solid var(--border);border-radius:10px;background:var(--hole);color:var(--text);
    font-size:16px; /* prevent iOS zoom */
}
  .muted{color:var(--muted)}
  .small{font-size:12px}
  .good{color:var(--good)} .bad{color:var(--bad)}
    /* Verb correctness highlights */
  .good-field{
    border-color: var(--good) !important;
    box-shadow:0 0 0 1px rgba(34,197,94,.45);
  }
  .bad-field{
    border-color: var(--bad) !important;
    box-shadow:0 0 0 1px rgba(239,68,68,.45);
  }
  .article-btn.good-btn{
    border-color: var(--good) !important;
    color:var(--good) !important;
  }
  .article-btn.bad-btn{
    border-color: var(--bad) !important;
    color:var(--bad) !important;
  }

  .pill{display:inline-block;border:1px solid var(--border);border-radius:999px;padding:3px 8px;font-size:12px;color:var(--muted)}
  .actions{display:flex;gap:8px;margin-top:10px}
  .actions button{background:var(--btn);border:1px solid var(--border);border-radius:10px;padding:10px 12px;color:var(--text);cursor:pointer}
  .actions button:hover{background:var(--btn2)}
  .hole{display:inline-block;min-width:64px;padding:6px 8px;border:1px dashed var(--border);border-radius:8px;background:#0b1017}
  .center{display:flex;justify-content:center;align-items:center}
  .hidden{display:none !important}
  .label{opacity:.9}

  /* Kapitel Mix modern screen */
  .kmx{display:grid;gap:10px}
  .kmx .big-card{padding:18px;border-radius:16px}
  .kmx .title{font-weight:700;font-size:18px}
  .kmx .sub{color:var(--muted);font-size:13px}
  .kmx .quiet{opacity:.85}
  .kmx .badge{border:1px solid var(--accent);color:var(--accent);padding:2px 8px;border-radius:999px;font-size:12px}

  /* Debug HUD */
  /* Sidebar helpers */
  #side{ transform:translateX(-100%); }   /* hidden to the LEFT */
  #sideMask{ display:none; }                    /* default hidden */
  .side-open #side{ transform:translateX(0) !important; }
  .side-open #sideMask{ display:block !important; }
  #debugHUD{position:fixed;right:8px;bottom:8px;background:#0b111a;border:1px solid var(--border);border-radius:10px;padding:8px 10px;color:#b7c6d8;font-size:12px;min-width:220px;z-index:9999;display:none}
  #debugHUD code{font-size:12px}
  #debugHUD .row{grid-template-columns:100px 1fr}

  /* Simple helper for article buttons */
  .article-bar{display:flex;gap:8px;margin:8px 0}
  .article-btn{flex:1;border:1px solid var(--border);border-radius:10px;background:var(--btn);color:var(--text);padding:10px 12px}
  .article-btn.active{outline:2px solid var(--accent)}
  /* Article color accents */
  .article-btn.art-der.active  { background:#0f1420; border-color:#2b63ff; color:#a8c4ff; outline-color:#2b63ff; }
  .article-btn.art-die.active  { background:#201018; border-color:#ff4d6d; color:#ff99ad; outline-color:#ff4d6d; }
  .article-btn.art-das.active  { background:#0f1a13; border-color:#22c55e; color:#9bf2c4; outline-color:#22c55e; }

  /* Splash modal */
  .modal{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;z-index:10000}
  .modal .box{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:16px;max-width:520px;width:92%}
</style>
</head>
<body>

<div class="wrap">
  <!-- Header + Sidebar trigger -->
	<div class="bar" style="justify-content:space-between;">
	  <div style="display:flex;align-items:center;gap:10px">
		<button id="btnSide" class="mode-btn" style="padding:8px 10px">â˜°</button>
		<strong>German Trainer</strong>
	  </div>
	  <span id="datasetCtx" class="muted small"></span>
	</div>

	<!-- Slide-out Sidebar -->
	<aside id="side" style="position:fixed;inset:0 auto 0 0; width:300px; max-width:85%; background:var(--card); border-right:1px solid var(--border); box-shadow:18px 0 30px rgba(0,0,0,.35); transition:transform .22s ease; z-index:20000; padding:14px; display:flex; flex-direction:column; gap:12px">
	  <div style="display:flex;justify-content:space-between;align-items:center">
		<strong>Settings</strong>
		<button id="btnSideClose" class="mode-btn" style="padding:6px 10px">âœ•</button>
	  </div>

	  <div class="card" style="padding:12px">
		<div class="small muted" style="margin-bottom:6px">Dataset</div>
		<select id="datasetSel" title="Dataset" style="width:100%">
		  <option value="default">Default</option>
		</select>
		<button id="btnLoadKapitel" style="width:100%; margin-top:8px">Load Kapitelâ€¦</button>
	  </div>

	  <div class="card" style="padding:12px">
		<div class="small muted" style="margin-bottom:6px">Cloud</div>
		<button id="btnSyncSide" title="Cloud Sync" style="width:100%">Sync</button>
		<div id="syncStatusSide" class="muted small" style="margin-top:6px">Sync: Off</div>
	  </div>
    
      <div class="card" style="padding:12px">
      <div class="small muted" style="margin-bottom:6px">Verbs</div>
      <label class="small muted" style="display:flex;align-items:center;gap:6px;">
        <input type="checkbox" id="verbsPastToggle" checked>
        include PrÃ¤teritum field
      </label>
    </div>

	  <div class="card" style="padding:12px">
		<div class="small muted" style="margin-bottom:6px">Debug</div>
		<button id="btnDebugSide" style="width:100%">Debug HUD</button>
	  </div>
	</aside>
	<div id="sideMask" style="position:fixed;inset:0;background:rgba(0,0,0,.45);z-index:19000;"></div>


   <div class="mode-tabs" id="modeTabs">
    <button class="mode-btn" data-mode="vocab">Vocab</button>
    <button class="mode-btn" data-mode="top5k">5k Words</button>
    <button class="mode-btn" data-mode="verbs">Verbs</button>
    <button class="mode-btn" data-mode="adjadv">Adj/Adv</button>
    <button class="mode-btn" data-mode="preps">Preps</button>
    <button class="mode-btn" data-mode="mix">Mix</button>
    <button class="mode-btn" data-mode="kapitelMix" id="btnKapitelMix" disabled>Kapitel Mix</button>
  </div>

  <!-- ====== 5K CORE WORDS ====== -->
  <section id="top5k" class="card hidden">
    <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;">
      <div style="flex:1">
        <div class="muted small" id="coreEnLabel">English word</div>
        <strong id="coreEn"></strong>
      </div>

      <div style="display:flex;align-items:center;gap:10px;">
        <label class="muted small" style="display:flex;align-items:center;gap:6px;white-space:nowrap;">
          <input type="checkbox" id="coreSentenceMode">
          sentence mode
        </label>
        <div id="coreLevel" class="pill"></div>
      </div>
    </div>

    <div id="coreEnSentence" class="muted small" style="margin-top:4px;"></div>
    <div id="coreMasri" class="muted small" style="margin-top:4px;"></div>

    <div class="row" style="margin-top:10px;">
      <div class="label">German</div>
      <div>
        <input id="coreDe" type="text" autocomplete="off">
        <textarea id="coreDeSent" class="hidden" rows="3" style="margin-top:8px;resize:vertical" placeholder="Write the full German sentence..."></textarea>
      </div>
    </div>

    <div id="coreDiff" class="small" style="margin-top:6px;"></div>


    <div id="coreDeSentence" class="muted small" style="margin-top:4px;"></div>

    <div id="coreFeedback" class="small" style="margin-top:8px;"></div>

    <div class="actions">
      <button id="coreCheck">Check</button>
      <button id="coreNext">Next</button>
      <button id="coreReset" class="muted">Reset</button>
    </div>
	
	    <div style="margin-top:8px">
      <div style="width:100%;height:6px;background:#1a2230;border-radius:4px;">
        <div id="coreProgBar" style="height:100%;width:0%;background:var(--accent);border-radius:4px;transition:width .3s;"></div>
      </div>
      <div id="coreProgText" class="small muted" style="margin-top:4px;text-align:right"></div>
    </div>

  </section>


  <!-- ====== VOCAB ====== -->
  <section id="vocab" class="card hidden">
    <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;">
      <div><strong id="vocabEn" class="muted"></strong> <span id="vocabStreak" class="pill"></span></div>
      <div id="vocabLevel" class="pill"></div>
    </div>

    <div class="article-bar">
      <button class="article-btn" data-a="der">der</button>
      <button class="article-btn" data-a="die">die</button>
      <button class="article-btn" data-a="das">das</button>
    </div>

    <div class="row"><div class="label">German</div><div><input id="vocabDe" type="text" autocomplete="off"></div></div>
    <div class="row"><div class="label">Plural</div><div><input id="vocabPl" type="text" autocomplete="off"></div></div>
    <div id="vocabExamples" class="muted small"></div>

    <div id="vocabFeedback" class="small" style="margin-top:8px"></div>
    <div class="actions">
      <button id="vocabCheck">Check</button>
      <button id="vocabNext">Next</button>
      <button id="vocabReset" class="muted">Reset</button>
      <label class="muted small" style="margin-left:auto;display:flex;align-items:center;gap:6px"><input id="vocabShowEn" type="checkbox" checked>show English</label>
    </div>
  </section>

    <!-- ====== VERBS ====== -->
  <section id="verbs" class="card hidden">
    <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;">
      <div><strong id="verbEn" class="muted"></strong> <span id="verbsLevel" class="pill"></span></div>
      <div class="pill">Streak target: 3</div>
    </div>

    <!-- Controls first: Aux, Case, Reflexive -->
    <div class="row"><div class="label">Aux</div>
      <div style="display:flex;gap:8px;flex-wrap:wrap">
        <button class="article-btn" data-aux="haben">haben</button>
        <button class="article-btn" data-aux="sein">sein</button>
        <button class="article-btn" data-aux="haben/sein">haben/sein</button>
        <span id="auxHint" class="pill"></span>
      </div>
    </div>
    <div class="row"><div class="label">Case</div>
      <div style="display:flex;gap:8px;flex-wrap:wrap">
        <button class="article-btn" data-case="inf">inf</button>
        <button class="article-btn" data-case="akk">akk</button>
        <button class="article-btn" data-case="dat">dat</button>
        <span id="caseHint" class="pill"></span>
      </div>
    </div>
    <div class="row"><div class="label">Reflexive</div>
      <div style="display:flex;gap:8px;flex-wrap:wrap">
        <button class="article-btn" data-refl="true">true</button>
        <button class="article-btn" data-refl="false">false</button>
      </div>
    </div>

    <!-- Then verb forms -->
    <div class="row"><div class="label">Infinitive</div><div><input id="vInf" type="text" autocomplete="off"></div></div>
    <div class="row"><div class="label">ich</div><div><input id="pIch" type="text"></div></div>
    <div class="row"><div class="label">du</div><div><input id="pDu" type="text"></div></div>
    <div class="row"><div class="label">er/sie/es</div><div><input id="pEr" type="text"></div></div>
    <div class="row"><div class="label">ihr</div><div><input id="pIhr" type="text"></div></div>

    <div class="row"><div class="label">Partizip II</div><div><input id="vPart" type="text" placeholder="z. B. gegangen"></div></div>
    <div class="row" id="rowPast"><div class="label">PrÃ¤teritum</div><div><input id="vPast" type="text" placeholder="z. B. ging"></div></div>

    <div class="row" id="rowPrep">
	  <div class="label">Preposition(s)</div>
	  <div><input id="vPrep" type="text" placeholder="auf;Ã¼ber;mit (optional)"></div>
	</div>


    <div id="verbsFeedback" class="small" style="margin-top:8px"></div>
    <div class="actions">
      <button id="verbsCheck">Check</button>
      <button id="verbsNext">Next</button>
      <button id="verbsReset" class="muted">Reset</button>
    </div>
  </section>

  <!-- ====== ADJ/ADV ====== -->
  <section id="adjadv" class="card hidden">
    <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;">
      <div><strong id="aaEn" class="muted"></strong> <span id="aaLevel" class="pill"></span></div>
      <div class="pill">Streak target: 3</div>
    </div>
    <p id="aaExample" class="muted small"></p>
    <div class="row"><div class="label">German</div><div><input id="aaDe" type="text" autocomplete="off"></div></div>
    <div id="aaFeedback" class="small" style="margin-top:8px"></div>
    <div class="actions">
      <button id="aaCheck">Check</button>
      <button id="aaNext">Next</button>
      <button id="aaReset" class="muted">Reset</button>
    </div>
  </section>

  <!-- ====== PREPOSITIONS (cloze) ====== -->
  <section id="preps" class="card hidden">
    <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;">
      <div><strong id="ppHeader" class="muted">Fill the blank with exact surface form</strong> <span id="ppLevel" class="pill"></span></div>
      <div class="pill">Streak target: 3</div>
    </div>
    <p id="ppSentence" style="font-size:18px;line-height:1.6"></p>
    <p id="ppEnglish" class="muted small"></p>
    <div class="actions">
      <button id="ppCheck">Check</button>
      <button id="ppNext">Next</button>
      <button id="ppReset" class="muted">Reset</button>
    </div>
    <div id="ppFeedback" class="small" style="margin-top:8px"></div>
  </section>

  <!-- ====== DEFAULT MIX (round-robin, level-gated) ====== -->
  <section id="mix" class="card hidden">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div><strong>Mix</strong> <span class="muted small">round-robin â€¢ prefers streak&lt;3 â€¢ respects levels</span></div>
      <div class="pill" id="mixInfo"></div>
    </div>
    <div id="mixMount" style="margin-top:8px"></div>
    <div class="small muted" style="margin-top:8px">Tip: press Enter to check; Enter again to advance.</div>
  </section>

  <!-- ====== KAPITEL MIX (separate UI) ====== -->
  <section id="kapitelMix" class="card hidden">
    <div class="kmx">
      <div class="big-card">
        <div class="title">Kapitel Mix</div>
        <div style="margin-top:8px;">
        <div id="kmxProgressOuter" style="width:100%;height:6px;background:#1a2230;border-radius:4px;">
          <div id="kmxProgressInner" style="height:100%;width:0%;background:var(--accent);border-radius:4px;transition:width .3s;"></div>
        </div>
        <div id="kmxProgressText" class="small muted" style="margin-top:4px;text-align:right">0%</div>
      </div>
      </div>
      <div id="kmxMount"></div>
      <div class="actions">
        <button id="kmxNext">Next</button>
        <button id="kmxReset" class="muted">Reset Kapitel progress</button>
        <span id="kmxAllDone" class="badge hidden">Kapitel mastered ðŸŽ‰</span>
      </div>
    </div>
  </section>

  <div class="bar" style="margin-top:8px">
    <button id="btnSync" title="Cloud Sync">Sync</button>
    <span id="syncStatus" class="muted small">Sync: Off</span>
    <button id="btnDebug" style="margin-left:auto">Debug HUD</button>
  </div>
</div>

<!-- Debug HUD -->
<div id="debugHUD">
  <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px">
    <strong>Debug</strong>
    <button id="dbgDump" class="mode-btn" style="padding:4px 8px">dump</button>
  </div>
  <div class="row"><div>dataset</div><div><code id="dbgDataset"></code></div></div>
  <div class="row"><div>mode</div><div><code id="dbgMode"></code></div></div>
  <div class="row"><div>sizes</div><div><code id="dbgSizes"></code></div></div>
  <div class="row"><div>last pick</div><div><code id="dbgPick"></code></div></div>
</div>

<!-- Simple Sync modal -->
<div id="syncModal" class="modal">
  <div class="box">
    <h3 style="margin:.2rem 0 .4rem">Cloud Sync (optional)</h3>
    <p class="muted small">Use a simple username to push/pull your local progress to Firebase Realtime DB.</p>
    <div class="row"><div class="label">Username</div><div><input id="syncUser" type="text" placeholder="e.g., negm"></div></div>
    <div class="actions" style="justify-content:flex-end">
      <button id="syncCancel">Cancel</button>
      <button id="syncEnable">Enable</button>
    </div>
  </div>
</div>

<script>
/* ===========================================================
   GERMAN TRAINER â€” STABLE CORE SCRIPT (no dangling blocks)
   =========================================================== */

const APP = {
  dsKey: 'default',
  mode: 'vocab',
  masteryTarget: 3,
  wordsPerLevel: 25,
  verbsIncludePast: true,
  debug: false,
  kapitel: { title:'', counts:{vocab:0,verbs:0,adjadv:0,preps:0}, files:null },
  pick: (arr)=> arr && arr.length? arr[Math.floor(Math.random()*arr.length)] : null,
  norm: (s)=> (s||'').trim().toLowerCase(),
  normDe: (s)=> (s||'').trim().toLowerCase().replaceAll('ÃŸ','ss').replaceAll('Ã¤','ae').replaceAll('Ã¶','oe').replaceAll('Ã¼','ue'),
  currentVerbHasPrep: false   // ðŸ‘ˆ add this line
};

// ---------- DOM helpers ----------
function $(sel){
  const el = document.querySelector(sel);
  return el || null;
}
function $all(sel){ return Array.from(document.querySelectorAll(sel)); }
function setText(sel, text){
  const el = $(sel);
  if(el) el.textContent = text;
}
function setHTML(sel, html){
  const el = $(sel);
  if(el) el.innerHTML = html;
}
function setVal(sel, v){
  const el = $(sel);
  if(el) el.value = v;
}

function show(id){ const el=$(id.startsWith('#')?id:`#${id}`); if(el) el.classList.remove('hidden'); }
function hide(id){ const el=$(id.startsWith('#')?id:`#${id}`); if(el) el.classList.add('hidden'); }

// ---------- Firebase Sync ----------
let FBAPP=null, DBrt=null;

function fbInit(){
  try{
    if(window.firebase && window.firebaseConfig){
      FBAPP = firebase.apps?.length ? firebase.app() : firebase.initializeApp(window.firebaseConfig);
      DBrt = firebase.database();
      return true;
    }
  }catch(e){ console.warn('Firebase init failed:', e); }
  return false;
}
function syncPath(user){ return `/users/${encodeURIComponent(user)}`; }

function buildSyncPayload(){
  return {
    meta: {
      dsKey: APP.dsKey,
      masteryTarget: APP.masteryTarget,
      wordsPerLevel: APP.wordsPerLevel,
      ts: Date.now()
    },
    progress: {
      vocab: state.vocab,
      verbs: state.verbs,
      adjadv: state.adjadv,
      preps: state.preps,
      top5k: state.top5k
    },
    kapitel: APP.kapitel
  };
}
function applyPayload(p){
  try{
    if(p?.progress){
      Object.assign(state.vocab,  p.progress.vocab   || {});
      Object.assign(state.verbs,  p.progress.verbs   || {});
      Object.assign(state.adjadv, p.progress.adjadv  || {});
      Object.assign(state.preps,  p.progress.preps   || {});
      Object.assign(state.top5k,  p.progress.top5k   || {});
      saveAll(); // persist locally too
      renderMode();
    }
    if(p?.kapitel){ APP.kapitel = p.kapitel; dsUI.update(); }
  }catch(e){ console.warn('applyPayload failed', e); }
}

async function syncPull(user){
  if(!DBrt) return;
  const snap = await DBrt.ref(syncPath(user)).get();
  if(snap.exists()){ applyPayload(snap.val()); }
}
async function syncPush(user){
  if(!DBrt) return;
  await DBrt.ref(syncPath(user)).set(buildSyncPayload());
}

// helpers
function syncOnUI(user){
  setText('#syncStatus', `Sync: On âœ… (${user})`);
  setText('#syncStatusSide', `Sync: On âœ… (${user})`);
}
function syncOffUI(){
  setText('#syncStatus', 'Sync: Off');
  setText('#syncStatusSide', 'Sync: Off');
}

// ---------- Storage ----------
const LS = {
  key:(k)=> `${k}::${APP.dsKey}`,
  get:(k,fb)=>{ try{const v=localStorage.getItem(LS.key(k)); return v? JSON.parse(v):fb;}catch{return fb;} },
  set:(k,v)=>{ try{localStorage.setItem(LS.key(k),JSON.stringify(v));}catch{} },
  del:(k)=>{ try{localStorage.removeItem(LS.key(k));}catch{} }
};

// ---------- CSV ----------
function parseCSV(txt){
  const rows=[]; let row=[]; let cur=''; let q=false;
  for(let i=0;i<txt.length;i++){
    const c=txt[i];
    if(c==='"'){ if(q && txt[i+1]==='"'){ cur+='"'; i++; } else q=!q; }
    else if(c===',' && !q){ row.push(cur); cur=''; }
    else if((c==='\n'||c==='\r') && !q){ if(cur!==''||row.length){ row.push(cur); rows.push(row); row=[]; cur=''; } }
    else cur+=c;
  }
  if(cur!==''||row.length){ row.push(cur); rows.push(row); }
  return rows;
}

// ---------- Dataset IO ----------
async function datasetRead(name){
  // When Kapitel dataset is active, read from its in-memory files
  if(APP.dsKey==='kapitel' && APP.kapitel.files && APP.kapitel.files[name]!=null){
    return APP.kapitel.files[name];
  }
  // When Default and we have inline samples, use them
  if(APP.dsKey==='default' && APP._inline && APP._inline[name]!=null){
    return APP._inline[name];
  }
  // Fallback: fetch file (must be present in same dir)
  const res = await fetch(name, {cache:'no-store'});
  if(!res.ok) throw new Error('Failed to load ' + name);
  return await res.text();
}

async function handleKapitelZip(file){
  const zip = await JSZip.loadAsync(file);
  async function readByName(b){
    const choices = Object.values(zip.files);
    const exact = choices.find(f=>!f.dir && f.name.toLowerCase()===b.toLowerCase());
    const loose = choices.find(f=>!f.dir && f.name.toLowerCase().endsWith('/'+b.toLowerCase()));
    const entry = exact || loose;
    return entry? await entry.async('string'): null;
  }
  const manifestTxt = await readByName('manifest.json');
  const vocabTxt    = await readByName('vocab.csv');
  const verbsTxt    = await readByName('verbs.csv');
  const adjadvTxt   = await readByName('adjadv.csv');
  const prepsTxt    = await readByName('prepositions.csv');

  let manifest=null; try{ manifest = manifestTxt? JSON.parse(manifestTxt): null; }catch{ manifest=null; }
  const title = (manifest?.title) || (manifest?.kapitel? ('Kapitel '+manifest.kapitel): (file.name||'Kapitel'));
  const counts = {
    vocab: vocabTxt? Math.max(0, vocabTxt.trim().split(/\r?\n/).length-1) : 0,
    verbs: verbsTxt? Math.max(0, verbsTxt.trim().split(/\r?\n/).length-1) : 0,
    adjadv: adjadvTxt? Math.max(0, adjadvTxt.trim().split(/\r?\n/).length-1) : 0,
    preps: prepsTxt? Math.max(0, prepsTxt.trim().split(/\r?\n/).length-1) : 0
  };
  APP.kapitel = { title, counts, files:{
    'manifest.json': manifestTxt||'',
    'vocab.csv': vocabTxt||'',
    'verbs.csv': verbsTxt||'',
    'adjadv.csv': adjadvTxt||'',
    'prepositions.csv': prepsTxt||''
  }};
  localStorage.setItem('kapitel_current_v1', JSON.stringify(APP.kapitel));
  APP.dsKey='kapitel';
  dsUI.update();
  await loadAll();
  setMode('kapitelMix');
}

// ---------- UI small utils ----------
function setMode(m){
  APP.mode=m; localStorage.setItem('mode', m);
  renderMode();
  updateHUD();
}
const dsUI = {
  update(){
    const sel = $('#datasetSel');
    sel.innerHTML = `<option value="default">Default</option>` + (localStorage.getItem('kapitel_current_v1')? `<option value="kapitel">Kapitel</option>`:'');
    sel.value = APP.dsKey;
    $('#datasetCtx').textContent = (APP.dsKey==='kapitel') ? `Studying: ${APP.kapitel.title}` : '';
    $('#btnKapitelMix').disabled = (APP.dsKey!=='kapitel');

    // Hide level badges on Kapitel
    $('#vocabLevel').classList.toggle('hidden', APP.dsKey==='kapitel');
    $('#verbsLevel').classList.toggle('hidden', APP.dsKey==='kapitel');
    $('#aaLevel').classList.toggle('hidden', APP.dsKey==='kapitel');
    $('#ppLevel').classList.toggle('hidden', APP.dsKey==='kapitel');
  }
};

// ---------- Progress structure ----------
const state = {
  vocab: { data:[], level:1, streaks:{}, article:'', idx:0, showEn:true },
  verbs: { data:[], level:1, streaks:{}, idx:0 },
  adjadv:{ data:[], level:1, streaks:{}, idx:0 },
  preps: { data:[], level:1, streaks:{}, idx:0, currentAnswer:'' },
  top5k: {
    data: [],
    level: 1,
    streaks: {},       // correct-in-a-row (word mode only)
    difficulty: {},    // legacy (unused)
    penalty: {},       // legacy (unused)
    sentenceMode: false,
    idx: 0
  }

};
function saveAll(){
  LS.set('vocabProgress', state.vocab);
  LS.set('verbsProgress', state.verbs);
  LS.set('adjadvProgress', state.adjadv);
  LS.set('prepsProgress', state.preps);
  LS.set('top5kProgress', state.top5k);
  // auto-push if sync is active
  const on = localStorage.getItem('syncActive')==='true';
  const user = localStorage.getItem('syncUser') || '';
  if(on && user && DBrt){ syncPush(user).catch(()=>{}); }
}
function loadAllProgress(){
  const v=LS.get('vocabProgress',null); if(v) Object.assign(state.vocab,v);
  const b=LS.get('verbsProgress',null); if(b) Object.assign(state.verbs,b);
  const a=LS.get('adjadvProgress',null); if(a) Object.assign(state.adjadv,a);
  const p=LS.get('prepsProgress',null); if(p) Object.assign(state.preps,p);
  const c=LS.get('top5kProgress',null); if(c) Object.assign(state.top5k,c);
}


// ---------- Trainers ----------
const Vocab = {
  async load(){
    const txt = await datasetRead('vocab.csv');
    const rows = parseCSV(txt.trim()); rows.shift();
    state.vocab.data = rows.map(r=>({
      english:r[0]||'', article:r[1]||'', german:r[2]||'', plural:r[3]||'',
      ex:[r[4]||'',r[5]||'',r[6]||''].filter(Boolean)
    }));
  },
  levelPool(){
    return APP.dsKey==='kapitel'
      ? state.vocab.data
      : state.vocab.data.slice(0, state.vocab.level*APP.wordsPerLevel);
  },
  hasData(){ return state.vocab.data.length>0; },
  hasUnmastered(){
    return this.levelPool().some(
      x => (state.vocab.streaks[x.german]||0) < APP.masteryTarget
    );
  },
  pick(){
    const pool = this.levelPool();
    const pref = pool.filter(
      x => (state.vocab.streaks[x.german]||0) < APP.masteryTarget
    );
    return (pref.length ? APP.pick(pref) : APP.pick(pool)) || null;
  },
  render(x){
    setText('#vocabEn', state.vocab.showEn ? x.english : '');
    setText('#vocabStreak', `${state.vocab.streaks[x.german]||0}/${APP.masteryTarget}`);
    setText('#vocabExamples',''); // hide example until after Check
    setText('#vocabLevel', (APP.dsKey==='kapitel') ? '' : `Level ${state.vocab.level}`);
    setText('#vocabFeedback','');
    setVal('#vocabDe','');
    setVal('#vocabPl','');
    state.vocab.article='';
    $all('.article-bar .article-btn').forEach(b=>b.classList.remove('active'));
    const vd = $('#vocabDe');
    if(vd) setTimeout(()=>vd.focus(),0);
  },
  check(x){
    const ok =
      (state.vocab.article === x.article) &&
      (APP.norm($('#vocabDe').value) === APP.norm(x.german)) &&
      (APP.norm($('#vocabPl').value) === APP.norm(x.plural || ''));

    if(ok){
      state.vocab.streaks[x.german] = (state.vocab.streaks[x.german] || 0) + 1;
      setHTML('#vocabFeedback','<span class="good">Correct!</span>');
    } else {
      state.vocab.streaks[x.german] = 0;
      setHTML(
        '#vocabFeedback',
        `<span class="bad">Wrong.</span> Correct: <b>${x.article} ${x.german}</b> â€” ${x.plural||'â€”'}`
      );
    }

    // show one example only after checking
    if(x.ex && x.ex.length){
      setText('#vocabExamples','ðŸ“ '+APP.pick(x.ex));
    }

    saveAll();

    // Kapitel progress
    if(APP.dsKey==='kapitel'){
      updateKapitelProgress();
    }

    // Default: auto-level up
    if(APP.dsKey==='default'){
      const pool = this.levelPool();
      if(
        pool.length &&
        pool.every(z => (state.vocab.streaks[z.german]||0) >= APP.masteryTarget) &&
        state.vocab.level*APP.wordsPerLevel < state.vocab.data.length
      ){
        state.vocab.level++;
        saveAll();
      }
    }
  }
};
const Verbs = {
  async load(){
    const txt = await datasetRead('verbs.csv');
    const rows = parseCSV(txt.trim()); rows.shift();
    state.verbs.data = rows.map(r=>{
      return {
        id: r[0] || `${(r[1]||'').trim()}__${(r[2]||'').trim()}`,
        lemma:r[1]||'', english:r[2]||'', aux:(r[3]||'').trim().toLowerCase(),
        ich:r[4]||'', du:r[5]||'', er:r[6]||'', wir:r[7]||'', ihr:r[8]||'', sie:r[9]||'',
        partizip:r[10]||'', past:r[11]||'',
        preps:(r[12]||'').split(';').map(s=>s.trim()).filter(Boolean),
        case:(r[13]||'').trim().toLowerCase(),
        reflexive:String(r[14]||'').trim().toLowerCase()
      };
    });
  },
  levelPool(){ return APP.dsKey==='kapitel'? state.verbs.data : state.verbs.data.slice(0, state.verbs.level*APP.wordsPerLevel); },
  hasData(){ return state.verbs.data.length>0; },
  hasUnmastered(){ return this.levelPool().some(v=> (state.verbs.streaks[v.id]||0) < APP.masteryTarget); },
  pick(){ const p=this.levelPool(); const pref=p.filter(v=>(state.verbs.streaks[v.id]||0)<APP.masteryTarget); return (pref.length?APP.pick(pref):APP.pick(p))||null; },
    render(v){
    setText('#verbEn', v.english);
    setText('#verbsFeedback','');
    ['#vInf','#pIch','#pDu','#pEr','#pIhr','#vPast','#vPart','#vPrep'].forEach(s=>{
	  const el=$(s);
	  if(el){
		el.value='';
		el.classList.remove('good-field','bad-field'); // â† reset color
	  }
	});
	$all('[data-aux],[data-case],[data-refl]').forEach(b=>{
	  b.classList.remove('good-btn','bad-btn'); // â† reset button colors
	});

    $all('[data-aux]').forEach(b=>b.classList.remove('active'));
    $all('[data-case]').forEach(b=>b.classList.remove('active'));
    $all('[data-refl]').forEach(b=>b.classList.remove('active'));
    setText('#verbsLevel', (APP.dsKey==='kapitel')? '' : `Level ${state.verbs.level}`);

    const rowPast = $('#rowPast');
    if(rowPast) rowPast.classList.toggle('hidden', !APP.verbsIncludePast);

    // NEW: show/hide preposition row depending on whether the verb has preps
    const hasPrep = v.preps && v.preps.length > 0;
    const rowPrep = $('#rowPrep');
    if(rowPrep) rowPrep.classList.toggle('hidden', !hasPrep);
    APP.currentVerbHasPrep = hasPrep;

    const vi=$('#vInf'); if(vi) setTimeout(()=>vi.focus(),0);

  },
  check(v){
	  let ok = true;
	  let msg = [];

	  // RESET previous button states
	  $all('[data-aux],[data-case],[data-refl]').forEach(b=>{
		b.classList.remove('good-btn','bad-btn');
	  });

	  // helper: check & highlight input fields
	  const checkField = (sel, correctRaw, label)=>{
		const el = $(sel);
		if(!el || !correctRaw){
		  if(el) el.classList.remove('good-field','bad-field');
		  return;
		}
		const isCorrect = APP.normDe(el.value) === APP.normDe(correctRaw);
		el.classList.toggle('good-field', isCorrect);
		el.classList.toggle('bad-field', !isCorrect);
		if(!isCorrect){
		  ok = false;
		  msg.push(`${label} âžœ <b>${correctRaw}</b>`);
		  el.value = correctRaw; // fill with correct answer
		}
	  };

	  // TEXT FIELDS
	  checkField('#vInf',  v.lemma,    'infinitive');
	  checkField('#pIch',  v.ich,      'ich');
	  checkField('#pDu',   v.du,       'du');
	  checkField('#pEr',   v.er,       'er/sie/es');
	  checkField('#pIhr',  v.ihr,      'ihr');
	  if(APP.verbsIncludePast) checkField('#vPast', v.past, 'PrÃ¤teritum');
	  checkField('#vPart', v.partizip, 'Partizip');

	  // PREPOSITION field (ONLY if verb has preps)
	  if(v.preps && v.preps.length > 0){
		const inp = $('#vPrep');
		if(inp){
		  const normPreps = v.preps.map(APP.norm);
		  const user = APP.norm(inp.value);
		  const isCorrect = normPreps.includes(user);

		  inp.classList.toggle('good-field', isCorrect);
		  inp.classList.toggle('bad-field', !isCorrect);

		  if(!isCorrect){
			ok = false;
			msg.push('prep âžœ <b>'+v.preps.join('; ')+'</b>');
			inp.value = v.preps[0];
		  }
		}
	  } else {
		const inp = $('#vPrep');
		if(inp) inp.classList.remove('good-field','bad-field');
	  }

	  // AUX BUTTONS
	  const chosenAuxBtn = $all('[data-aux].active')[0] || null;
	  const chosenAux = chosenAuxBtn?.dataset.aux || '';

	  if(v.aux){
		const allowed = v.aux.split('/').map(s=>s.trim());
		// mark correct ones green
		$all('[data-aux]').forEach(b=>{
		  if(allowed.includes(b.dataset.aux)){
			b.classList.add('good-btn');
		  }
		});
		// chosen wrong? â†’ red
		if(chosenAux && !allowed.includes(chosenAux)){
		  ok = false;
		  msg.push('aux âžœ <b>'+v.aux+'</b>');
		  if(chosenAuxBtn) chosenAuxBtn.classList.add('bad-btn');
		}
	  }

	  // CASE BUTTONS
	  const chosenCaseBtn = $all('[data-case].active')[0] || null;
	  const chosenCase = chosenCaseBtn?.dataset.case || '';

	  if(v.case){
		const target = APP.norm(v.case);
		// mark correct button green
		$all('[data-case]').forEach(b=>{
		  if(APP.norm(b.dataset.case) === target){
			b.classList.add('good-btn');
		  }
		});
		if(!chosenCase || APP.norm(chosenCase) !== target){
		  ok = false;
		  msg.push('case âžœ <b>'+v.case+'</b>');
		  if(chosenCaseBtn) chosenCaseBtn.classList.add('bad-btn');
		}
	  }

	  // REFLEXIVE BUTTONS
	  const chosenReflBtn = $all('[data-refl].active')[0] || null;
	  const chosenRefl = chosenReflBtn?.dataset.refl || '';

	  if(v.reflexive){
		const target = APP.norm(v.reflexive);
		$all('[data-refl]').forEach(b=>{
		  if(APP.norm(b.dataset.refl) === target){
			b.classList.add('good-btn');
		  }
		});
		if(!chosenRefl || APP.norm(chosenRefl) !== target){
		  ok = false;
		  msg.push('reflexive âžœ <b>'+v.reflexive+'</b>');
		  if(chosenReflBtn) chosenReflBtn.classList.add('bad-btn');
		}
	  }

	  // feedback + streak
	  if(ok){
		state.verbs.streaks[v.id]=(state.verbs.streaks[v.id]||0)+1;
		setHTML('#verbsFeedback','<span class="good">Correct!</span>');
	  } else {
		state.verbs.streaks[v.id]=0;
		setHTML('#verbsFeedback',`<span class="bad">Wrong.</span> Correct: ${msg.join(', ')}`);
	  }
	  saveAll();
	  if(APP.dsKey==='kapitel') updateKapitelProgress();
	}

};

const AdjAdv = {
  async load(){
    const txt = await datasetRead('adjadv.csv');
    const rows = parseCSV(txt.trim()); rows.shift();
    state.adjadv.data = rows.map(r=>({ english:r[0]||'', german:r[1]||'', example:r[2]||'' }));
  },
  levelPool(){ return APP.dsKey==='kapitel'? state.adjadv.data : state.adjadv.data.slice(0, state.adjadv.level*APP.wordsPerLevel); },
  hasData(){ return state.adjadv.data.length>0; },
  hasUnmastered(){ return this.levelPool().some(x=> (state.adjadv.streaks[x.german]||0)<APP.masteryTarget); },
  pick(){ const p=this.levelPool(); const pref=p.filter(x=>(state.adjadv.streaks[x.german]||0)<APP.masteryTarget); return (pref.length?APP.pick(pref):APP.pick(p))||null; },
  render(x){
	setText('#aaEn', x.english);
  setText('#aaExample', x.example?('ðŸ“ '+x.example):'');
    setText('#aaFeedback','');
    setVal('#aaDe','');
    const a=$('#aaDe'); if(a) setTimeout(()=>a.focus(),0);
    setText('#aaLevel', (APP.dsKey==='kapitel')? '' : `Level ${state.adjadv.level}`);

  },
  check(x){
    const ok = APP.normDe($('#aaDe').value)===APP.normDe(x.german);
    if(ok){ state.adjadv.streaks[x.german]=(state.adjadv.streaks[x.german]||0)+1; setHTML('#aaFeedback','<span class="good">Correct!</span>'); }
    else { state.adjadv.streaks[x.german]=0; setHTML('#aaFeedback',`<span class="bad">Wrong.</span> Correct: <b>${x.german}</b>`); }
    saveAll();
    if(APP.dsKey==='kapitel'){ updateKapitelProgress(); }
    if(APP.dsKey==='default'){
      const p=this.levelPool();
      if(p.length && p.every(z=>(state.adjadv.streaks[z.german]||0)>=APP.masteryTarget) && state.adjadv.level*APP.wordsPerLevel<state.adjadv.data.length){
        state.adjadv.level++; saveAll();
      }
    }
  }
};

const Preps = {
  async load(){
    const txt = await datasetRead('prepositions.csv');
    const rows = parseCSV(txt.trim()); rows.shift();
    state.preps.data = rows.map(r=>({
      prep:r[0]||'', forms:(r[1]||'').split(';').map(s=>s.trim()).filter(Boolean),
      de:r.slice(2,12).map(x=>x||''), en:r.slice(12,22).map(x=>x||'')
    }));
  },
  levelPool(){ return APP.dsKey==='kapitel'? state.preps.data : state.preps.data.slice(0, state.preps.level*APP.wordsPerLevel); },
  hasData(){ return state.preps.data.length>0; },
  hasUnmastered(){ return this.levelPool().some(x=> (state.preps.streaks[x.prep]||0)<APP.masteryTarget); },
  pick(){ const p=this.levelPool(); const pref=p.filter(x=>(state.preps.streaks[x.prep]||0)<APP.masteryTarget); return (pref.length?APP.pick(pref):APP.pick(p))||null; },
  _blank(item){
    const idxs = item.de.map((s,i)=>({i,s})).filter(x=> (x.s||'').trim().length>0);
    if(!idxs.length) return null;
    const pick = APP.pick(idxs);
    const tokens = item.forms.filter(Boolean).sort((a,b)=>b.length-a.length);
    for(const t of tokens){
      const re = new RegExp(`\\b${t.replace(/[.*+?^${}()|[\]\\]/g,'\\$&')}\\b`,'u');
      if(re.test(pick.s)){
        const hole = `<span class="hole" contenteditable="true" id="ppHole"></span>`;
        const html = pick.s.replace(re, hole);
        state.preps.currentAnswer = t;
        const en = item.en[pick.i]||'';
        return {html,en};
      }
    }
    return null;
  },
  render(it){
	  setText('#ppFeedback','');
	  setText('#ppLevel', (APP.dsKey==='kapitel')? '' : `Level ${state.preps.level}`);
	  const b = this._blank(it);
	  if(!b){
		setHTML('#ppSentence','<em class="muted">No cloze found for this item.</em>');
		setText('#ppEnglish','');
		return 'repick';
	  }
	  setHTML('#ppSentence', b.html);
	  setText('#ppEnglish', b.en?('EN: '+b.en):'');
	  setTimeout(()=>{ const h=$('#ppHole'); if(h) h.focus(); },0);
},

  check(){
    const guess = ($('#ppHole')?.textContent||'').trim();
    const ok = guess === state.preps.currentAnswer;
    if(ok){ const key=this._curKey; state.preps.streaks[key]=(state.preps.streaks[key]||0)+1; setHTML('#ppFeedback','<span class="good">Correct!</span>'); }
    else { const key=this._curKey; state.preps.streaks[key]=0; setHTML('#ppFeedback',`<span class="bad">Wrong.</span> Correct: <b>${state.preps.currentAnswer||''}</b>`); }
    saveAll();
    if(APP.dsKey==='kapitel'){ updateKapitelProgress(); }
    if(APP.dsKey==='default'){
      const p=this.levelPool();
      if(p.length && p.every(z=>(state.preps.streaks[z.prep]||0)>=APP.masteryTarget) && state.preps.level*APP.wordsPerLevel<state.preps.data.length){
        state.preps.level++; saveAll();
      }
    }
  }
};

const Core5k = {
  async load(){
    let txt;
    try{
      txt = await datasetRead('5k.csv');
    } catch(e){
      state.top5k.data = [];
      return;
    }
    const rows = parseCSV(txt.trim());
    rows.shift(); // drop header

    // NOTE: adjust indices if your CSV order differs
    state.top5k.data = rows.map((r, idx) => ({
      id:      (r[0] || String(idx+1)).toString().trim(), // #
      german:  r[1] || '',
      english: r[2] || '',
      deSent:  r[3] || '',
      enSent:  r[4] || '',
      category:r[5] || '',
      masri:   r[6] || '',
      lvl: Math.floor(idx / APP.wordsPerLevel) + 1
    }));
  },

  levelPool(){
    return state.top5k.data.slice(0, state.top5k.level * APP.wordsPerLevel);
  },

  isSentenceMode(){
    return !!state.top5k.sentenceMode;
  },

  sentencePool(){
    // Only unlocked words with both sentences present
    return this.levelPool().filter(w => (w.deSent || '').trim() && (w.enSent || '').trim());
  },

  hasData(){
    return state.top5k.data.length > 0;
  },

  requiredFor(item){
    // Base requirement by distance from current level
    const CL = state.top5k.level;
    const WL = item.lvl || 1;
    const d = CL - WL;

    if(d <= 1) return 3;       // current + previous level
    if(d === 2) return 2;      // two levels behind
    return 1;                  // 3+ levels behind
  },

  hasUnmastered(){
    // Only meaningful in word-mode
    const pool = this.levelPool();
    return pool.some(it => {
      const need = this.requiredFor(it);
      return (state.top5k.streaks[it.id] || 0) < need;
    });
  },

  pick(){
    // Sentence mode: pure random from unlocked sentence pool
    if(this.isSentenceMode()){
      const sp = this.sentencePool();
      return APP.pick(sp) || null;
    }

    // Word mode: mastery-driven selection
    const pool = this.levelPool();
    if(!pool.length) return null;

    const unmastered = pool.filter(it => {
      const need = this.requiredFor(it);
      return (state.top5k.streaks[it.id] || 0) < need;
    });

    return (unmastered.length ? APP.pick(unmastered) : APP.pick(pool)) || null;
  },

  render(x){
    const sentenceMode = this.isSentenceMode();

    setText('#coreEnLabel', sentenceMode ? 'English sentence' : 'English word');

    if(sentenceMode){
      setText('#coreEn', x.enSent || '');
      setText('#coreEnSentence', x.english ? ('Word: ' + x.english) : '');
    } else {
      setText('#coreEn', x.english || '');
      setText('#coreEnSentence', x.enSent || '');
    }

    setText('#coreLevel', `Level ${state.top5k.level}`);
    setText('#coreMasri', x.masri ? ('Masri: ' + x.masri) : '');

    setText('#coreDeSentence', '');
    setHTML('#coreFeedback', '');
    setHTML('#coreDiff', '');

    const wordInp = $('#coreDe');
    const sentInp = $('#coreDeSent');

    if(wordInp){
      wordInp.value = '';
      wordInp.classList.remove('good-field','bad-field');
      wordInp.classList.toggle('hidden', sentenceMode);
    }
    if(sentInp){
      sentInp.value = '';
      sentInp.classList.remove('good-field','bad-field');
      sentInp.classList.toggle('hidden', !sentenceMode);
    }

    setTimeout(() => {
      if(sentenceMode) sentInp?.focus();
      else wordInp?.focus();
    }, 0);

    this.updateProgress();
  },

  check(x){
    const sentenceMode = this.isSentenceMode();
    const showCorrectSentence = () => setText('#coreDeSentence', x.deSent || '');

    // ---------- Sentence mode ----------
    if(sentenceMode){
      const inp = $('#coreDeSent');
      if(!inp) return;

      const userRaw = inp.value || '';
      const expRaw  = x.deSent || '';

      const userN = this._tok(userRaw).map(t=>this._normTok(t)).join(' ');
      const expN  = this._tok(expRaw).map(t=>this._normTok(t)).join(' ');

      inp.classList.remove('good-field','bad-field');
      setHTML('#coreDiff','');
      setHTML('#coreFeedback','');

      if(userN && userN === expN){
        inp.classList.add('good-field');
        setHTML('#coreFeedback', `<span class="good">Correct!</span>`);
        setHTML('#coreDiff', '');
      } else {
        inp.classList.add('bad-field');
        setHTML('#coreFeedback', `<span class="bad">Wrong.</span>`);
        setHTML('#coreDiff', this._renderDiff(expRaw, userRaw));
      }

      showCorrectSentence();
      this.updateProgress();
      return;
    }

    // ---------- Word mode ----------
    const inp = $('#coreDe');
    if(!inp) return;

    const guess  = APP.normDe(inp.value);
    const target = APP.normDe(x.german);
    const need   = this.requiredFor(x);
    let streak   = state.top5k.streaks[x.id] || 0;

    inp.classList.remove('good-field','bad-field');

    if(guess && guess === target){
      streak += 1;
      state.top5k.streaks[x.id] = streak;
      inp.classList.add('good-field');
      setHTML('#coreFeedback', `<span class="good">Correct!</span> (${streak}/${need})`);
    } else {
      state.top5k.streaks[x.id] = 0;
      inp.value = x.german || '';
      inp.classList.add('bad-field');
      setHTML('#coreFeedback', `<span class="bad">Wrong.</span> Correct: <b>${x.german || ''}</b>`);
    }

    showCorrectSentence();
    saveAll();

    const pool = this.levelPool();
    const allMastered = pool.length && pool.every(it => {
      const req = this.requiredFor(it);
      return (state.top5k.streaks[it.id] || 0) >= req;
    });

    if(allMastered && state.top5k.level * APP.wordsPerLevel < state.top5k.data.length){
      state.top5k.level++;
      state.top5k.streaks = {};
      saveAll();
    }

    this.updateProgress();
  },

  updateProgress(){
    // Progress across ALL unlocked words (level 1 â†’ current level)
    const pool = this.levelPool();
    if(!pool.length) return;

    const done = pool.filter(w => {
      const need = this.requiredFor(w);
      return (state.top5k.streaks[w.id] || 0) >= need;
    }).length;

    const pct = Math.round(100 * done / pool.length);

    const bar = $('#coreProgBar');
    const txt = $('#coreProgText');

    if(bar) bar.style.width = pct + '%';
    if(txt) txt.textContent = `${done} / ${pool.length}`;
  },

  _tok(s){
    const raw = (s || '').trim();
    if(!raw) return [];
    return raw.match(/[A-Za-zÃ„Ã–ÃœÃ¤Ã¶Ã¼ÃŸ]+|\d+|[^\sA-Za-zÃ„Ã–ÃœÃ¤Ã¶Ã¼ÃŸ\d]+/g) || [];
  },
  _normTok(t){
    if(/[A-Za-zÃ„Ã–ÃœÃ¤Ã¶Ã¼ÃŸ]/.test(t)) return APP.normDe(t);
    return t.trim();
  },
  _joinTokens(tokens){
    let out = '';
    for(const t of tokens){
      if(!out){ out = t; continue; }
      if(/^[\.,!\?:;\)\]\}]/.test(t)) out += t;
      else if(/^[\(\[\{]/.test(t)) out += ' ' + t;
      else out += ' ' + t;
    }
    return out;
  },
  _lcs(a, b){
    const n = a.length, m = b.length;
    const dp = Array.from({length:n+1}, () => Array(m+1).fill(0));
    for(let i=1;i<=n;i++){
      for(let j=1;j<=m;j++){
        dp[i][j] = (a[i-1] === b[j-1]) ? dp[i-1][j-1] + 1 : Math.max(dp[i-1][j], dp[i][j-1]);
      }
    }
    const matchA = new Set();
    const matchB = new Set();
    let i=n, j=m;
    while(i>0 && j>0){
      if(a[i-1] === b[j-1]){
        matchA.add(i-1);
        matchB.add(j-1);
        i--; j--;
      } else if(dp[i-1][j] >= dp[i][j-1]) i--;
      else j--;
    }
    return { matchA, matchB };
  },
  _renderDiff(expected, actual){
    const expT = this._tok(expected);
    const actT = this._tok(actual);

    const expN = expT.map(t => this._normTok(t));
    const actN = actT.map(t => this._normTok(t));

    const { matchA, matchB } = this._lcs(expN, actN);

    const expHtml = expT.map((t, idx) => {
      const safe = t.replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;');
      if(matchA.has(idx)) return `<span class="good">${safe}</span>`;
      return `<span class="bad" style="text-decoration:underline">${safe}</span>`;
    });

    const extras = actT
      .map((t, idx) => ({t, idx}))
      .filter(x => !matchB.has(x.idx))
      .map(x => x.t);

    const expLine = this._joinTokens(expHtml);
    let extraLine = '';
    if(extras.length){
      const safeExtras = extras.map(t => t.replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;'));
      extraLine = `<div class="bad" style="margin-top:4px">Extra: ${this._joinTokens(safeExtras)}</div>`;
    }

    return `<div>${expLine}</div>${extraLine}`;
  }
};


// ---------- Trainer bridge ----------
const Trainers = {
  vocab:{
    async load(){ await Vocab.load(); },
    hasData:()=>Vocab.hasData?.() ?? (state.vocab.data.length>0),
    hasUnmastered:()=>Vocab.hasUnmastered(),
    levelPool:()=>Vocab.levelPool(),
    next(internal=false){
      const x = Vocab.pick(); if(!x) return;
      Vocab.render(x); this._cur=x;
      if(!internal) setMode('vocab');
    },
    check(){ Vocab.check(this._cur); }
  },
  verbs:{
    async load(){ await Verbs.load(); },
    hasData:()=>Verbs.hasData?.() ?? (state.verbs.data.length>0),
    hasUnmastered:()=>Verbs.hasUnmastered(),
    levelPool:()=>Verbs.levelPool(),
    next(internal=false){
      const x = Verbs.pick(); if(!x) return;
      Verbs.render(x); this._cur=x;
      if(!internal) setMode('verbs');
    },
    check(){ Verbs.check(this._cur); }
  },
  adjadv:{
    async load(){ await AdjAdv.load(); },
    hasData:()=>AdjAdv.hasData?.() ?? (state.adjadv.data.length>0),
    hasUnmastered:()=>AdjAdv.hasUnmastered(),
    levelPool:()=>AdjAdv.levelPool(),
    next(internal=false){
      const x = AdjAdv.pick(); if(!x) return;
      AdjAdv.render(x); this._cur=x;
      if(!internal) setMode('adjadv');
    },
    check(){ AdjAdv.check(this._cur); }
  },
  preps:{
    async load(){ await Preps.load(); },
    hasData:()=>Preps.hasData?.() ?? (state.preps.data.length>0),
    hasUnmastered:()=>Preps.hasUnmastered(),
    levelPool:()=>Preps.levelPool(),
    next(internal=false){
      let x = Preps.pick(); if(!x) return;
      let rep = Preps.render(x);
      // if render() returns 'repick', pick another
      if(rep === 'repick'){
        x = Preps.pick();
        if(!x) return;
        rep = Preps.render(x);
        if(rep === 'repick') return;
      }
      this._cur = x;
      if(!internal) setMode('preps');
    },
    check(){ Preps.check(this._cur); }
  },
  top5k:{
    async load(){ await Core5k.load(); },
    hasData:()=>Core5k.hasData?.() ?? (state.top5k.data.length>0),
    hasUnmastered:()=>Core5k.hasUnmastered(),
    levelPool:()=>Core5k.levelPool(),
    next(internal=false){
      const x = Core5k.pick(); if(!x) return;
      Core5k.render(x); this._cur=x;
      if(!internal) setMode('top5k');
    },
    check(){ if(this._cur) Core5k.check(this._cur); }
  }
};


// ---------- Mix mounting (no cloning) ----------
const mixMounts = { mix:'#mixMount', kapitel:'#kmxMount' };
let mounted = null;
function mountSection(sec, where){
  const map={vocab:'#vocab',verbs:'#verbs',adjadv:'#adjadv',preps:'#preps'};
  const sel=map[sec]; if(!sel) return;
  const el=document.querySelector(sel); if(!el) return;

  // unmount current
  if(mounted && mounted.sec){
    const backSel = map[mounted.sec];
    const backEl = document.querySelector(backSel);
    if(backEl){ document.querySelector('.wrap').appendChild(backEl); backEl.classList.add('hidden'); }
    mounted=null;
  }
  const host=document.querySelector(mixMounts[where]); host.innerHTML='';
  el.classList.remove('hidden'); host.appendChild(el); mounted={sec,parentId: mixMounts[where]};
}

const Mix = {
  order:['vocab','verbs','adjadv','preps'], i:0,
  nextSection(){
    for(let k=0;k<4;k++){
      this.i=(this.i+1)%this.order.length;
      const s=this.order[this.i];
      if(!Trainers[s].hasData()) continue;
      if(Trainers[s].levelPool().length===0) continue;
      return s;
    }
    return 'vocab';
  },
  render(){ const sec=this.nextSection(); Trainers[sec].next(true); mountSection(sec,'mix'); setText('#mixInfo', 'â†’ '+sec); }
};

const KapitelMix = {
  order:['vocab','verbs','adjadv','preps'], i:-1,
  pickSection(){
    const avail=this.order.filter(s=>Trainers[s].hasData());
    const un=avail.filter(s=>Trainers[s].hasUnmastered());
    if(un.length){ this.i=(this.i+1)%un.length; return un[this.i]; }
    if(avail.length){ this.i=(this.i+1)%avail.length; return avail[this.i]; }
    return null;
  },
  allMastered(){ return ['vocab','verbs','adjadv','preps'].every(s=>!Trainers[s].hasData() || !Trainers[s].hasUnmastered()); },
  render(){
    const mount = $('#kmxMount');
    if(this.allMastered()){ $('#kmxAllDone').classList.remove('hidden'); mount.innerHTML='<div class="center" style="min-height:120px"><strong>Kapitel mastered ðŸŽ‰</strong></div>'; return; }
    $('#kmxAllDone').classList.add('hidden');
    const sec=this.pickSection(); if(!sec){ mount.innerHTML='<p class="muted">No Kapitel data loaded.</p>'; return; }
    Trainers[sec].next(true); mountSection(sec,'kapitel');
    updateKapitelProgress();
  }
};

// ---------- HUD ----------
function updateHUD(){
  setText('#dbgDataset', APP.dsKey);
  setText('#dbgMode', APP.mode);
  const sizes = 'vocab:' + state.vocab.data.length +
                ', verbs:' + state.verbs.data.length +
                ', adjadv:' + state.adjadv.data.length +
                ', preps:' + state.preps.data.length +
                ', 5k:' + (state.top5k.data.length || 0);
  setText('#dbgSizes', sizes);
}


// Kapitel Mix progress (% mastered across all four pools)
function updateKapitelProgress(){
  // total items (prefer live data; fallback to manifest counts)
  const totals = {
    vocab: state.vocab.data.length || (APP.kapitel.counts?.vocab||0),
    verbs: state.verbs.data.length || (APP.kapitel.counts?.verbs||0),
    adjadv: state.adjadv.data.length || (APP.kapitel.counts?.adjadv||0),
    preps: state.preps.data.length || (APP.kapitel.counts?.preps||0)
  };
  const mastered = {
    vocab: state.vocab.data.filter(x => (state.vocab.streaks[x.german]||0) >= APP.masteryTarget).length,
    verbs: state.verbs.data.filter(x => (state.verbs.streaks[x.id]||0)     >= APP.masteryTarget).length,
    adjadv:state.adjadv.data.filter(x => (state.adjadv.streaks[x.german]||0)>= APP.masteryTarget).length,
    preps: state.preps.data.filter(x => (state.preps.streaks[x.prep]||0)   >= APP.masteryTarget).length
  };
  const totalAll = totals.vocab + totals.verbs + totals.adjadv + totals.preps;
  const doneAll  = mastered.vocab + mastered.verbs + mastered.adjadv + mastered.preps;
  const pct = !totalAll ? 0 : Math.round(100 * doneAll / totalAll);

  const inner = $('#kmxProgressInner');
  const txt   = $('#kmxProgressText');
  if(inner){ inner.style.width = pct + '%'; }
  if(txt){ txt.textContent = `${pct}% (${doneAll}/${totalAll})`; }
}

// ---------- Mode rendering ----------
function renderMode(){
  ['#vocab','#top5k','#verbs','#adjadv','#preps','#mix','#kapitelMix'].forEach(hide);
  if(APP.mode==='mix'){ show('#mix'); Mix.render(); }
  else if(APP.mode==='kapitelMix'){ show('#kapitelMix'); KapitelMix.render(); }
  else { show('#'+APP.mode); }
  $all('.mode-btn').forEach(b=> b.classList.toggle('active', b.dataset.mode===APP.mode));
  updateHUD();
}


function activeSectionKey(){
  // If we're in mix/kapitelMix, use the mounted section. Else use mode as-is.
  if((APP.mode==='mix' || APP.mode==='kapitelMix') && mounted && mounted.sec) return mounted.sec;
  return APP.mode;
}
function safeNext(forcedSection){
  const key = forcedSection || activeSectionKey();
  const T = Trainers[key];
  if(!T || !T.next) return;
  // internal=true prevents setMode bounce
  T.next(true);
  if(APP.mode==='mix') Mix.render();
  if(APP.mode==='kapitelMix') KapitelMix.render();
}
function safeCheck(forcedSection){
  const key = forcedSection || activeSectionKey();
  const T = Trainers[key];
  if(!T || !T.check) return;
  T.check();
}


// ---------- Events ----------
function attachEvents(){
  // Sidebar
  const side=$('#side'), mask=$('#sideMask');
  const openSide=()=>{ document.body.classList.add('side-open'); };
  const closeSide=()=>{ document.body.classList.remove('side-open'); };
  $('#btnSide').addEventListener('click', openSide);
  $('#btnSideClose').addEventListener('click', closeSide);
  mask.addEventListener('click', closeSide);

    // Tabs (only buttons that actually declare a data-mode)
  $all('.mode-btn[data-mode]').forEach(b=>{
    b.addEventListener('click', ()=>{
      const m = b.dataset.mode;
      if(!m) return;
      if(m==='kapitelMix' && APP.dsKey!=='kapitel') return;
      setMode(m);
      if(m!=='mix' && m!=='kapitelMix') Trainers[m].next(true);
    });
  });


  // Dataset
  $('#datasetSel').addEventListener('change', async (e)=>{
    const v=e.target.value;
    if(v==='default'){ APP.dsKey='default'; }
    else if(v==='kapitel'){ if(!localStorage.getItem('kapitel_current_v1')){ e.target.value='default'; return; } APP.dsKey='kapitel'; }
    dsUI.update(); await loadAll(); if(APP.dsKey==='kapitel' && APP.mode==='mix') setMode('kapitelMix'); renderMode();
  });
  $('#btnLoadKapitel').addEventListener('click', ()=>{
    const inp=document.createElement('input'); inp.type='file'; inp.accept='.zip';
    inp.onchange=async (ev)=>{ const f=ev.target.files?.[0]; if(!f) return; try{ await handleKapitelZip(f); Trainers.vocab.next(true); setMode('kapitelMix'); }catch(e){ alert(e?.message||String(e)); } };
    inp.click();
  });

  // Vocab UI
  $all('.article-bar .article-btn').forEach(b=>{
    b.addEventListener('click', ()=>{
      state.vocab.article=b.dataset.a;
      $all('.article-bar .article-btn').forEach(x=>{
        x.classList.remove('active','art-der','art-die','art-das');
      });
      b.classList.add('active', 'art-' + b.dataset.a); // der/die/das
      $('#vocabDe')?.focus();
    });
  });
  $('#vocabCheck').addEventListener('click', ()=>safeCheck('vocab'));
  $('#vocabNext').addEventListener('click', ()=>safeNext('vocab'));
  $('#vocabReset').addEventListener('click', ()=>{ if(confirm('Reset vocab progress?')){ state.vocab.level=1; state.vocab.streaks={}; saveAll(); Trainers.vocab.next(true); renderMode(); } });
  $('#vocabShowEn').addEventListener('change', (e)=>{ state.vocab.showEn=e.target.checked; saveAll(); renderMode(); });

    // Verb toggles
  $all('[data-aux]').forEach(b=>b.addEventListener('click', ()=>{
    $all('[data-aux]').forEach(x=>x.classList.remove('active'));
    b.classList.add('active');
    const vi = $('#vInf'); if(vi) vi.focus();
  }));
  $all('[data-case]').forEach(b=>b.addEventListener('click', ()=>{ $all('[data-case]').forEach(x=>x.classList.remove('active')); b.classList.add('active'); }));
  $all('[data-refl]').forEach(b=>b.addEventListener('click', ()=>{ $all('[data-refl]').forEach(x=>x.classList.remove('active')); b.classList.add('active'); $('#vInf').focus(); }));
  $('#verbsCheck').addEventListener('click', ()=>safeCheck('verbs'));
  $('#verbsNext').addEventListener('click', ()=>safeNext('verbs'));
  $('#verbsReset').addEventListener('click', ()=>{ if(confirm('Reset verbs progress?')){ state.verbs.level=1; state.verbs.streaks={}; saveAll(); Trainers.verbs.next(true); renderMode(); } });

  // Adj/Adv
  $('#aaCheck').addEventListener('click', ()=>safeCheck('adjadv'));
  $('#aaNext').addEventListener('click', ()=>safeNext('adjadv'));
  $('#aaReset').addEventListener('click', ()=>{ if(confirm('Reset adj/adv progress?')){ state.adjadv.level=1; state.adjadv.streaks={}; saveAll(); Trainers.adjadv.next(true); renderMode(); } });

  // Preps
  $('#ppCheck').addEventListener('click', ()=>safeCheck('preps'));
  $('#ppNext').addEventListener('click', ()=>safeNext('preps'));
  $('#ppReset').addEventListener('click', ()=>{ if(confirm('Reset preps progress?')){ state.preps.level=1; state.preps.streaks={}; saveAll(); Trainers.preps.next(true); renderMode(); } });
  
    // 5k Core words
  // 5k sentence mode toggle
  const coreTgl = $('#coreSentenceMode');
  if(coreTgl){
    coreTgl.checked = !!state.top5k.sentenceMode;
    coreTgl.addEventListener('change', (e)=>{
      state.top5k.sentenceMode = !!e.target.checked;
      saveAll();
      Trainers.top5k.next(true);
      renderMode();
    });
  }
  const coreCheckBtn = $('#coreCheck');
  if(coreCheckBtn){
    coreCheckBtn.addEventListener('click', ()=>safeCheck('top5k'));
  }
  const coreNextBtn = $('#coreNext');
  if(coreNextBtn){
    coreNextBtn.addEventListener('click', ()=>safeNext('top5k'));
  }
  const coreResetBtn = $('#coreReset');
  if(coreResetBtn){
    coreResetBtn.addEventListener('click', ()=>{
      if(!confirm('Reset 5k words progress?')) return;
      state.top5k.level = 1;
      state.top5k.streaks = {};
      saveAll();
      Trainers.top5k.next(true);
      renderMode();
    });
  }

    // Kapitel Mix controls
  const kmxNextBtn = $('#kmxNext');
  if(kmxNextBtn){
    kmxNextBtn.addEventListener('click', ()=>{
      // just request a new section/card
      KapitelMix.render();
    });
  }
  const kmxResetBtn = $('#kmxReset');
  if(kmxResetBtn){
    kmxResetBtn.addEventListener('click', ()=>{
      if(!confirm('Reset this Kapitel progress?')) return;
      // clear streaks ONLY in current dataset (kapitel)
      state.vocab.streaks = {};
      state.verbs.streaks = {};
      state.adjadv.streaks = {};
      state.preps.streaks = {};
      saveAll();
      updateKapitelProgress();
      KapitelMix.render();
    });
  }

  // Debug HUD buttons (footer + sidebar)
	['#btnDebug','#btnDebugSide'].forEach(sel=>{
	  const el=$(sel); if(!el) return;
	  el.addEventListener('click', ()=>{
		const h=$('#debugHUD');
		h.style.display = (h.style.display==='none'||!h.style.display)?'block':'none';
	  });
      // Verbs: include/exclude PrÃ¤teritum field
  const verbsTgl = $('#verbsPastToggle');
  if(verbsTgl){
    verbsTgl.checked = APP.verbsIncludePast;
    verbsTgl.addEventListener('change', (e)=>{
      APP.verbsIncludePast = !!e.target.checked;
      localStorage.setItem('verbsIncludePast', APP.verbsIncludePast ? 'true' : 'false');
      const row = $('#rowPast');
      if(row) row.classList.toggle('hidden', !APP.verbsIncludePast);
    });
  }
	});
	$('#dbgDump').addEventListener('click', ()=>{ console.log({APP,state}); alert('Dumped to console.'); });
  function openSync(){ const m=$('#syncModal'); if(m) m.style.display='flex'; }
  function closeSync(){ const m=$('#syncModal'); if(m) m.style.display='none'; }
  ['#btnSync','#btnSyncSide'].forEach(sel=>{
    const el=$(sel); if(!el) return;
    el.addEventListener('click', openSync);
  });
  $('#syncCancel').addEventListener('click', closeSync);
    $('#syncEnable').addEventListener('click', async ()=>{
      const input = $('#syncUser');
      const user = input ? input.value.trim() : '';
      if(!user){
        alert('Enter a username.');
        return;
      }
      localStorage.setItem('syncActive','true');
      localStorage.setItem('syncUser', user);
      const ok = fbInit();
      if(ok){
        try{
          await syncPull(user);
          await syncPush(user);
        }catch(e){
          console.warn(e);
        }
      }
      syncOnUI(user);
      closeSync();
    });
  
  // restore sync on load
    const wasOn = localStorage.getItem('syncActive')==='true';
  const lastUser = localStorage.getItem('syncUser') || '';
  if(wasOn && lastUser){
    fbInit();
    syncOnUI(lastUser);
    syncPull(lastUser).then(()=>syncPush(lastUser)).catch(()=>{});
  } else {
    syncOffUI();
  }


  // GLOBAL ENTER ENGINE
  let enterArmed=false;
    function modeFields(mode){
    if(mode==='vocab') return ['#vocabDe','#vocabPl'];
    if(mode==='top5k') return [ state.top5k.sentenceMode ? '#coreDeSent' : '#coreDe' ];
    if(mode==='verbs'){
      const base = ['#vInf','#pIch','#pDu','#pEr','#pIhr','#vPart'];
      if(APP.verbsIncludePast) base.push('#vPast');
      if(APP.currentVerbHasPrep) base.push('#vPrep'); // only include if this verb actually has a prep
      return base;
    }
    if(mode==='adjadv') return ['#aaDe'];
    if(mode==='preps') return ['#ppHole'];
    if(mode==='mix'||mode==='kapitelMix'){
      if(!mounted) return [];
      return modeFields(mounted.sec);
    }
    return [];
  }

  function sectionCheck(mode){ const m=(mode==='mix'||mode==='kapitelMix')&&mounted? mounted.sec:mode; Trainers[m]?.check && Trainers[m].check(); }
  function sectionNext(mode){
  // Kapitel Mix: let the KapitelMix engine handle section selection + mounting.
  if(mode === 'kapitelMix'){
    KapitelMix.render();
    return;
  }

  // Normal / default Mix behaviour:
  const m = (mode === 'mix' && mounted) ? mounted.sec : mode;
  const T = Trainers[m];
  if(T && T.next) T.next(true);

  if(mode === 'mix'){
    Mix.render();
  }
}

  document.addEventListener('keydown',(e)=>{
    if(e.key!=='Enter') return;
    const fields=modeFields(APP.mode).map(s=>document.querySelector(s)).filter(Boolean);
    if(!fields.length) return;
    const active=document.activeElement; const idx=fields.indexOf(active);
    if(APP.mode==='preps'||APP.mode==='kapitelMix'){
      const hole=document.querySelector('#ppHole'); if(hole && fields[0]===hole && active!==hole){ e.preventDefault(); hole.focus(); return; }
    }
    if(idx>-1 && idx<fields.length-1){ e.preventDefault(); fields[idx+1].focus(); enterArmed=false; return; }
    e.preventDefault();
    if(!enterArmed){ enterArmed=true; sectionCheck(APP.mode); const last=fields[fields.length-1]; if(last) last.focus(); }
    else { enterArmed=false; sectionNext(APP.mode); setTimeout(()=>{ const nf=modeFields(APP.mode).map(s=>document.querySelector(s)).filter(Boolean)[0]; nf&&nf.focus(); },0); }
  });
}

// ---------- Samples (no backticks) ----------
const SAMPLE_VOCAB = [
  "english,article,german,plural,example1,example2,example3",
  "book,das,Das Buch,BÃ¼cher,Ich lese ein Buch.,Das Buch ist interessant.,Sie kaufen viele BÃ¼cher.",
  "cat,die,Die Katze,Katzen,Die Katze schlÃ¤ft.,Ich mag Katzen.,Die Katzen sind sÃ¼ÃŸ.",
  "man,der,Der Mann,MÃ¤nner,Der Mann arbeitet.,Ich sehe den Mann.,Viele MÃ¤nner sind hier."
].join("\n");
const SAMPLE_VERBS = [
  "id,lemma,english,aux,ich,du,er,wir,ihr,sie,partizip,past,preps,case,reflexive",
  "gehen,gehen,to go,sein,gehe,gehst,geht,gehen,geht,gehen,gegangen,ging,,-,false",
  "sprechen,sprechen,to speak,haben,spreche,sprichst,spricht,sprechen,sprecht,sprechen,gesprochen,sprach,Ã¼ber,akk,false",
  "sich-waschen,waschen,to wash,haben,wasche,waeschst,waescht,waschen,wascht,waschen,gewaschen,wusch,,inf,true"
].join("\n");
const SAMPLE_AA = [
  "english,german,example",
  "beautiful,schÃ¶n,Das ist ein schÃ¶nes Bild.",
  "dangerous,gefÃ¤hrlich,Das ist eine gefÃ¤hrliche Kreuzung.",
  "often,hÃ¤ufig,Ich fahre hÃ¤ufig mit dem Rad."
].join("\n");
const SAMPLE_PREPS = [
  "prep,forms,de1,de2,de3,de4,de5,de6,de7,de8,de9,de10,en1,en2,en3,en4,en5,en6,en7,en8,en9,en10",
  "in,in;im;ins,Ich bin im BÃ¼ro.,Wir gehen ins Kino.,Er wohnt in Berlin.,,,,,,I'm at the office.,We're going to the cinema.,He lives in Berlin.,,,,,,,",
  "auf,auf,Das Buch liegt auf dem Tisch.,Wir gehen auf den Markt.,Er ist auf der BÃ¼hne.,,,,,,The book is on the table.,We are going to the market.,He is on the stage.,,,,,,,"
].join("\n");

// ---------- Boot ----------
async function loadDefaultIfMissing(name, sample){
  try{ await datasetRead(name); }catch{ if(APP.dsKey==='default'){ if(!APP._inline){ APP._inline={}; } APP._inline[name]=sample; } }
}
async function loadAll(){
  loadAllProgress();
  await Trainers.vocab.load().catch(()=>{});
  await Trainers.verbs.load().catch(()=>{});
  await Trainers.adjadv.load().catch(()=>{});
  await Trainers.preps.load().catch(()=>{});
  await Trainers.top5k.load().catch(()=>{});
  dsUI.update();
  updateHUD();
}

async function boot(){
  APP.mode = localStorage.getItem('mode') || 'vocab';
  // Restore Kapitel if present
  const saved = localStorage.getItem('kapitel_current_v1');
  const incPast = localStorage.getItem('verbsIncludePast');
  if(incPast === 'false') APP.verbsIncludePast = false;
  if(saved){
    try{
      const k = JSON.parse(saved);
      APP.kapitel = { title:k.title, counts:k.counts, files:k.files };
      APP.dsKey = 'kapitel';
    }catch{}
  }

  await loadDefaultIfMissing('vocab.csv', SAMPLE_VOCAB);
  await loadDefaultIfMissing('verbs.csv', SAMPLE_VERBS);
  await loadDefaultIfMissing('adjadv.csv', SAMPLE_AA);
  await loadDefaultIfMissing('prepositions.csv', SAMPLE_PREPS);

  await loadAll();
  attachEvents();

  // Start in whatever mode was last used (fallback to vocab)
  if (!Trainers[APP.mode]) {
    APP.mode = 'vocab';
  }
  const startTrainer = Trainers[APP.mode];
  if (startTrainer && startTrainer.next) {
    startTrainer.next(true);   // pick first item for that mode
  }

  renderMode();
}
document.addEventListener('DOMContentLoaded', boot);
</script>

</body>
</html>
