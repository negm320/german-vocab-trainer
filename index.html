<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>German Vocab Trainer</title>
  <style>
    :root{
      --bg:#0f1115; --text:#eaeaea; --muted:#9aa6b2; --card:#171b23; --border:#2a3240; --input:#0f1620;
      --btn:#243042; --btn-hover:#2a3a50; --ok:#22c55e; --bad:#f97373;
      --der:#7fb3ff; --der-text:#0b2139; --die:#ff9aa2; --die-text:#3a0b12; --das:#9be7a1; --das-text:#0d2a14;
    }
    *{box-sizing:border-box}
    body{font-family:Arial,sans-serif;margin:0;padding:10px;background:var(--bg);color:var(--text)}
    .container{max-width:500px;margin:auto;padding:10px}
    h1{font-size:1.8em;text-align:center;margin-bottom:10px}
    #level{text-align:center;margin-bottom:15px;font-size:1.1em;color:var(--muted)}
    .card{background:var(--card);border-radius:12px;padding:15px;box-shadow:0 2px 6px rgba(0,0,0,.35);border:1px solid var(--border)}

    .button-row{display:flex;gap:8px}
    .article-btn{flex:1 1 0;padding:12px 0;font-size:16px;border-radius:10px;cursor:pointer;border:1px solid var(--border);background:#202734;color:var(--text)}
    #btnDer.selected{background:var(--der);color:var(--der-text);border-color:#6aa6ff}
    #btnDie.selected{background:var(--die);color:var(--die-text);border-color:#ff8a93}
    #btnDas.selected{background:var(--das);color:var(--das-text);border-color:#86d892}

    input{width:48%;padding:12px;margin:5px 1%;font-size:16px;border-radius:8px;border:1px solid var(--border);background:var(--input);color:var(--text)}
    input::placeholder{color:#7b879a}
    input:focus{outline:2px solid #3b82f680;border-color:#3b82f6}

    button{padding:12px;margin:5px 1%;font-size:16px;border-radius:8px;border:1px solid var(--border);background:var(--btn);color:var(--text);cursor:pointer}
    button:hover{background:var(--btn-hover)}

    #feedback{margin-top:5px;font-size:1em}
    #example{margin-top:6px;font-size:.95em;color:var(--muted)}
    #nextBtn{display:none;width:100%}
    #status{margin-top:10px;font-size:.9em;color:var(--muted);white-space:pre-wrap}
  </style>
  
  <style>
    /* === Additive styles for Verbs UI === */
    #mode-switch { margin: 12px 0; display: flex; gap: 8px; flex-wrap: wrap; }
    #mode-switch .mode-btn { padding: 6px 10px; border: 1px solid #ccc; background: #f8f8f8; cursor: pointer; border-radius: 6px; }
    #mode-switch .mode-btn.active { background: #e8f2ff; border-color: #5b9cff; }
  
    #verbs-card { border: 1px solid #e5e5e5; border-radius: 10px; padding: 16px; margin: 8px 0 16px; background: #fff; }
    #verbs-card[hidden] { display: none; }
    #verbs-card .prompt { font-size: 20px; font-weight: 600; margin-bottom: 8px; }
  
    .aux-toggle { display: flex; align-items: center; gap: 8px; margin: 8px 0; }
    .aux-btn { padding: 6px 10px; border: 1px solid #ccc; background: #fafafa; border-radius: 6px; cursor: pointer; }
    .aux-btn.selected { background: #e8f2ff; border-color: #5b9cff; }
    .badge { display: inline-block; padding: 2px 8px; border-radius: 999px; border: 1px solid #5b9cff; color: #1b62cf; font-size: 12px; }
  
    .praesens-grid { display: grid; grid-template-columns: repeat(2, minmax(200px, 1fr)); gap: 8px 16px; margin: 10px 0; }
    .praesens-grid div { display: flex; align-items: center; gap: 6px; }
    .praesens-grid input, #verbs-inf, #verbs-partizip { width: 100%; padding: 6px 8px; }
  
    .result-ok { border-color: #29a36a !important; background: #f0fff7 !important; }
    .result-bad { border-color: #d9534f !important; background: #fff5f5 !important; }
  
    #verbs-actions { display: flex; gap: 8px; margin-top: 12px; }
    #verbs-actions button { padding: 8px 12px; border-radius: 6px; border: 1px solid #ccc; background: #f8f8f8; cursor: pointer; }
    #verbs-feedback { margin-top: 10px; font-size: 14px; }
  </style>
  
  <style>
    /* ===== Global dark theme (opt-in via .dark on <body>) ===== */
    body.dark { background: #0b0d10; color: #e8eaed; }
  
    /* try to harmonize common elements if they exist */
    body.dark input, body.dark select, body.dark button, body.dark textarea {
      background: #111418; color: #e8eaed; border: 1px solid #2a2f36;
    }
    body.dark .card, body.dark .panel, body.dark .box {
      background: #0f1216; border: 1px solid #2a2f36; color: #e8eaed;
    }
    body.dark a { color: #96b7ff; }
  
    /* ===== Verbs UI dark styles ===== */
    body.dark #mode-switch .mode-btn {
      background: #12151a; border-color: #2a2f36; color: #e8eaed;
    }
    body.dark #mode-switch .mode-btn.active {
      background: #162036; border-color: #3b6ad9;
    }
    body.dark #verbs-card {
      background: #0f1216; border-color: #2a2f36;
    }
    body.dark .aux-btn {
      background: #12151a; border-color: #2a2f36; color: #e8eaed;
    }
    body.dark .aux-btn.selected {
      background: #162036; border-color: #3b6ad9;
    }
    body.dark .badge {
      border-color: #3b6ad9; color: #9bb8ff;
    }
    /* check result colors tuned for dark bg */
    body.dark .result-ok { border-color: #2fa97b !important; background: #0f1b16 !important; }
    body.dark .result-bad { border-color: #e66b6b !important; background: #1a1111 !important; }
  </style>
</head>
<body>
    <div id="mode-switch">
    <button class="mode-btn" data-mode="vocab">Vocab</button>
    <button class="mode-btn" data-mode="verbs">Verbs</button>
    <button class="mode-btn" data-mode="mix">Mix</button>
  </div>

  <div id="verbs-card" hidden>
    <div class="prompt" id="verbs-english">to go</div>

    <label for="verbs-inf">German infinitive</label>
    <input id="verbs-inf" autocomplete="off" />

    <div class="aux-toggle">
      <span>Auxiliary:</span>
      <button type="button" class="aux-btn" data-aux="haben">haben</button>
      <button type="button" class="aux-btn" data-aux="sein">sein</button>
      <span id="verbs-aux-badge" class="badge" style="display:none;"></span>
    </div>

    <div class="praesens-grid">
      <div>ich <input id="verbs-p-ich" autocomplete="off"></div>
      <div>du <input id="verbs-p-du" autocomplete="off"></div>
      <div>er/sie/es <input id="verbs-p-er" autocomplete="off"></div>
      <div>wir <input id="verbs-p-wir" autocomplete="off"></div>
      <div>ihr <input id="verbs-p-ihr" autocomplete="off"></div>
      <div>sie/Sie <input id="verbs-p-sie" autocomplete="off"></div>
    </div>

    <div class="perfekt">
      ich <span id="verbs-aux-fixed" class="badge">—</span>
      <input id="verbs-partizip" placeholder="Partizip II (z. B. gegangen)" autocomplete="off">
    </div>

    <div id="verbs-actions">
      <button id="verbs-check">Check</button>
      <button id="verbs-next">Next</button>
    </div>

    <div id="verbs-feedback"></div>
  </div>
  <div class="container">
    <h1>German Vocab Trainer</h1>
    <p id="level">Level: 1 (Words 1–25)</p>
    <div id="vocab-wrapper">
      <div class="card">
        <p id="englishRow"><strong>English word:</strong> <span id="english"></span> <em id="streakDisplay"></em></p>
  
        <div id="media" style="margin-bottom:8px;">
          <!-- Faster image: async decode + high fetch priority -->
          <img id="wordImage" alt="vocab image" decoding="async" fetchpriority="high"
               style="display:none;width:100%;max-height:220px;object-fit:contain;background:#0d0f14;border:1px solid var(--border);border-radius:10px;padding:8px;" />
        </div>
  
        <div class="button-row">
          <button id="btnDer" class="article-btn">der</button>
          <button id="btnDie" class="article-btn">die</button>
          <button id="btnDas" class="article-btn">das</button>
        </div>
  
        <input type="text" id="german" placeholder="German word" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
        <input type="text" id="plural" placeholder="Plural" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
        <p id="feedback"></p>
        <p id="example"></p>
  
        <br />
        <button id="checkBtn">Check</button>
        <button id="resetBtn">Reset Progress</button>
        <button id="nextBtn">Next word</button>
        <div id="status"></div>
      </div>
    </div>
  </div>

  <label style="display:flex;align-items:center;gap:8px;margin:10px auto 0;max-width:500px;color:var(--muted);font-size:.95em;">
    <input type="checkbox" id="toggleEnglish" checked /> Show English word
  </label>

  <script>
  document.addEventListener('DOMContentLoaded', () => {
    // ===== State =====
    let words = [];
    let currentWord = null;
    let chosenArticle = '';
    let level = 1;
    const wordsPerLevel = 25;
    const masteryThreshold = 3;
    let pluralEnterCount = 0;
    let lastFocusId = 'german';

    const statusEl = document.getElementById('status');
    const englishRowEl = document.getElementById('englishRow');

    // Show any uncaught error in the UI (helps diagnose blank screens)
    window.addEventListener('error', (e) => {
      if (statusEl) statusEl.textContent = '⚠️ JS error: ' + (e.error?.message || e.message || String(e));
    });

    // === Image cache & preload ===
    let imageCache = new Map(); // german -> best src or null
    let preloadedNext = null;   // { word, src }

    function status(msg){ if(statusEl) statusEl.textContent = msg || ''; }

    // ===== CSV Parser =====
    function parseCSV(text){
      const rows=[]; let row=[]; let cur=''; let inQuotes=false;
      for(let i=0;i<text.length;i++){
        const c=text[i];
        if(c==='"'){
          if(inQuotes && text[i+1]==='"'){ cur+='"'; i++; } else { inQuotes=!inQuotes; }
        } else if(c===',' && !inQuotes){
          row.push(cur); cur='';
        } else if((c==='\n' || c==='\r') && !inQuotes){
          if(cur!=='' || row.length){ row.push(cur); rows.push(row); row=[]; cur=''; }
        } else {
          cur+=c;
        }
      }
      if(cur!=='' || row.length){ row.push(cur); rows.push(row); }
      return rows;
    }

    // ===== Data loading =====
    async function loadCSV(){
      try{
        status('Loading vocab.csv…');
        const res = await fetch('vocab.csv', {cache:'no-store'});
        if(!res.ok) throw new Error('Failed to load vocab.csv');
        const data = await res.text();
        const lines = parseCSV(data.trim());
        if(lines.length===0){ status('vocab.csv is empty'); return; }
        lines.shift();
        words = lines.map(cols=>{
          const english=cols[0]||''; const article=cols[1]||''; const german=cols[2]||''; const plural=cols[3]||'';
          const ex1=cols[4]||''; const ex2=cols[5]||''; const ex3=cols[6]||'';
          const examples=[ex1,ex2,ex3].filter(x=>x&&x.trim()!=='');
          return { english, article, german, plural, examples, correctStreak:0, answeredCorrect:false };
        });
        loadProgress();
        updateLevelDisplay();
        await nextWord();          // show first word
        schedulePreloadNext();     // start preloading immediately
        status('');
      }catch(e){ console.error(e); status('Error: '+e.message); }
    }

    function updateLevelDisplay(){
      const el = document.getElementById('level');
      if (el) el.textContent = `Level: ${level} (Words 1–${level*wordsPerLevel})`;
    }

    function getActiveWords(){ return words.slice(0, level*wordsPerLevel); }

    function getTierWords(){
      const active=getActiveWords(); if(active.length===0) return [];
      const minStreak=Math.min(...active.map(w=>w.correctStreak));
      return active.filter(w=>w.correctStreak===minStreak && !w.answeredCorrect);
    }

    // ===== Image helpers =====
    function replaceUmlauts(s){
      return (s||'')
        .replaceAll('ä','ae').replaceAll('Ä','Ae')
        .replaceAll('ö','oe').replaceAll('Ö','Oe')
        .replaceAll('ü','ue').replaceAll('Ü','Ue')
        .replaceAll('ß','ss');
    }
    function buildCandidates(german){
      const baseRaw=(german||'').trim(); const bases=[];
      if(baseRaw){
        bases.push(baseRaw, baseRaw.toLowerCase(), baseRaw.replaceAll(' ','-'), baseRaw.toLowerCase().replaceAll(' ','-'));
        const uml=replaceUmlauts(baseRaw);
        bases.push(uml, uml.toLowerCase(), uml.replaceAll(' ','-'), uml.toLowerCase().replaceAll(' ','-'));
      }
      const exts=['jpg','jpeg','png','webp']; const out=[];
      bases.forEach(b=>exts.forEach(ext=>out.push('img/'+encodeURIComponent(b)+'.'+ext)));
      return out;
    }

    function resolveImageSrcForGerman(german){
      return new Promise((resolve)=>{
        if(!german){ resolve(null); return; }
        if(imageCache.has(german)){ resolve(imageCache.get(german)); return; }

        const candidates = buildCandidates(german);
        let i = 0, done = false;

        const tryNext = ()=>{
          if(done) return;
          if(i >= candidates.length){ done = true; imageCache.set(german, null); resolve(null); return; }
          const src = candidates[i++];
          const probe = new Image();
          probe.onload = ()=>{ if(done) return; done = true; imageCache.set(german, src); resolve(src); };
          probe.onerror = tryNext;
          probe.src = src;
        };
        tryNext();
      });
    }

    async function preloadWordImage(word){
      if(!word || !word.german) return { word, src: null };
      const src = await resolveImageSrcForGerman(word.german);
      return { word, src };
    }

    // Faster image: no artificial wait
    async function loadImageForCurrent(waitMs = 0){
      const img=document.getElementById('wordImage');
      if(!img) return;

      img.style.display='none';
      img.removeAttribute('src');
      if(!currentWord || !currentWord.german) return;

      let src = (preloadedNext && preloadedNext.word === currentWord) ? preloadedNext.src : null;
      if(!src){ src = await resolveImageSrcForGerman(currentWord.german); }
      if(!src){ return; }

      if(waitMs > 0) await new Promise(r => setTimeout(r, waitMs));

      img.onload = ()=>{ img.style.display='block'; };
      img.onerror = ()=>{ img.style.display='none'; };
      img.src = src;
    }

    function pickNextCandidateWord(){
      const active = getActiveWords();
      if(active.length === 0) return null;

      const minStreak = Math.min(...active.map(w => w.correctStreak));
      let tier = active.filter(w => w.correctStreak === minStreak && !w.answeredCorrect);
      if(tier.length === 0) tier = active.filter(w => w.correctStreak === minStreak);
      if(tier.length === 0) tier = active;

      return tier[Math.floor(Math.random()*tier.length)];
    }
    async function schedulePreloadNext(){
      const candidate = pickNextCandidateWord();
      if(!candidate){ preloadedNext = null; return; }
      preloadedNext = await preloadWordImage(candidate);
    }

    async function nextWord(){
      const activeWords=getActiveWords(); if(activeWords.length===0) return;

      let tierWords=getTierWords();
      if(tierWords.length===0){
        const minStreak=Math.min(...activeWords.map(w=>w.correctStreak));
        activeWords.filter(w=>w.correctStreak===minStreak).forEach(w=>w.answeredCorrect=false);
        tierWords=getTierWords();
      }
      const list=(tierWords.length?tierWords:activeWords);
      currentWord=list[Math.floor(Math.random()*list.length)];

      const englishEl = document.getElementById('english');
      const streakEl  = document.getElementById('streakDisplay');
      const germanEl  = document.getElementById('german');
      const pluralEl  = document.getElementById('plural');
      const feedbackEl= document.getElementById('feedback');
      const exampleEl = document.getElementById('example');
      const nextBtn   = document.getElementById('nextBtn');

      if(englishEl) englishEl.textContent=currentWord.english;
      if(streakEl)  streakEl.textContent=`(${currentWord.correctStreak}/${masteryThreshold})`;
      if(germanEl)  germanEl.value='';
      if(pluralEl)  pluralEl.value='';
      if(feedbackEl)feedbackEl.textContent='';
      if(exampleEl) exampleEl.textContent='';
      if(nextBtn)   nextBtn.style.display='none';

      chosenArticle='';
      resetArticleButtons();
      pluralEnterCount=0;

      applyEnglishVisibility();

      // Begin resolving image ASAP, then show it
      await loadImageForCurrent(0);
      schedulePreloadNext();

      if(germanEl){
        setTimeout(()=>{
          germanEl.focus();
          try{ germanEl.scrollIntoView({ behavior:'smooth', block:'center' }); }catch{}
        },0);
      }
    }

    function resetArticleButtons(){
      const a=document.getElementById('btnDer');
      const b=document.getElementById('btnDie');
      const c=document.getElementById('btnDas');
      if(a) a.classList.remove('selected');
      if(b) b.classList.remove('selected');
      if(c) c.classList.remove('selected');
    }

    function chooseArticle(article){
      chosenArticle=article; resetArticleButtons();
      if(article==='der') document.getElementById('btnDer')?.classList.add('selected');
      if(article==='die') document.getElementById('btnDie')?.classList.add('selected');
      if(article==='das') document.getElementById('btnDas')?.classList.add('selected');

      const germanEl=document.getElementById('german');
      if(germanEl){
        lastFocusId='german';
        setTimeout(()=>{
          germanEl.focus();
          try{ germanEl.scrollIntoView({ behavior:'smooth', block:'center' }); }catch{}
        },0);
      }
    }

    function randomExample(examples){ if(!examples||examples.length===0) return ''; const i=Math.floor(Math.random()*examples.length); return examples[i]; }

    function checkAnswer(){
      if(!currentWord) return;
      const german=(document.getElementById('german')?.value || '').trim().toLowerCase();
      const plural=(document.getElementById('plural')?.value || '').trim().toLowerCase();
      let feedback='';
      const correctGerman=(currentWord.german||'').toLowerCase();
      const correctPlural=(currentWord.plural||'').toLowerCase();
      const pluralCorrect=(plural===correctPlural) || (correctPlural==='—' && plural==='');
      if(chosenArticle===currentWord.article && german===correctGerman && pluralCorrect){
        currentWord.correctStreak++; currentWord.answeredCorrect=true; feedback='<span style="color:var(--ok)">Correct!</span>';
      } else {
        currentWord.correctStreak=0; currentWord.answeredCorrect=false; feedback=`<span style="color:var(--bad)">Wrong!</span><br>Correct: ${currentWord.article} ${currentWord.german} — ${currentWord.plural}`;
      }
      const feedbackEl=document.getElementById('feedback');
      if(feedbackEl) feedbackEl.innerHTML=feedback;
      const streakEl=document.getElementById('streakDisplay');
      if(streakEl) streakEl.textContent=`(${currentWord.correctStreak}/${masteryThreshold})`;
      const ex=randomExample(currentWord.examples);
      const exampleEl=document.getElementById('example');
      if(exampleEl) exampleEl.textContent=ex?`📝 ${ex}`:'';
      const nextBtn=document.getElementById('nextBtn');
      if(nextBtn) nextBtn.style.display='inline-block';
      saveProgress();

      const activeWords=getActiveWords();
      const allMastered=activeWords.every(w=>w.correctStreak>=masteryThreshold);
      if(allMastered && level*wordsPerLevel<words.length){
        level++; activeWords.forEach(w=>{w.correctStreak=0; w.answeredCorrect=false;}); updateLevelDisplay(); saveProgress();
      }
    }

    function saveProgress(){
      try{ localStorage.setItem('vocabProgress', JSON.stringify({ words, level, showEnglish: document.getElementById('toggleEnglish')?.checked })); }catch{}
    }

    function loadProgress(){
      try{
        const saved=localStorage.getItem('vocabProgress');
        const cb=document.getElementById('toggleEnglish');
        if(saved){
          const data=JSON.parse(saved);
          level=data.level||1;
          if(cb) cb.checked = (data.showEnglish!==undefined)? !!data.showEnglish : true;
          words.forEach((w,i)=>{ if(data.words && data.words[i]){ w.correctStreak=data.words[i].correctStreak||0; w.answeredCorrect=data.words[i].answeredCorrect||false; } });
        } else { if(cb) cb.checked = true; }
      }catch{}
    }

    function resetProgress(){
      if(confirm('Are you sure you want to reset progress?')){
        try{ localStorage.removeItem('vocabProgress'); }catch{}
        words.forEach(w=>{ w.correctStreak=0; w.answeredCorrect=false; }); level=1; updateLevelDisplay(); nextWord();
      }
    }

    // Input focus + Enter behavior
    document.getElementById('german')?.addEventListener('focus', ()=>{ lastFocusId='german'; });
    document.getElementById('plural')?.addEventListener('focus', ()=>{ lastFocusId='plural'; });

    document.getElementById('german')?.addEventListener('keydown', e=>{ if(e.key==='Enter'){ e.preventDefault(); document.getElementById('plural')?.focus(); }});
    document.getElementById('plural')?.addEventListener('keydown', e=>{
      if(e.key==='Enter'){
        e.preventDefault();
        pluralEnterCount++;
        if(pluralEnterCount===1) checkAnswer();
        else if(pluralEnterCount===2){ pluralEnterCount=0; nextWord(); }
      }
    });

    // ===== Article buttons — keep keyboard up =====
    function bindArticleButton(id, article){
      const el = document.getElementById(id);
      if(!el) return;

      // Prevent the button from stealing focus (so keyboard stays open)
      const early = (e)=>{ 
        try { e.preventDefault(); } catch {}
        chooseArticle(article);
      };
      el.addEventListener('pointerdown', early);
      el.addEventListener('mousedown', early);
      el.addEventListener('click', (e)=>{ e.preventDefault(); chooseArticle(article); });
    }
    bindArticleButton('btnDer','der');
    bindArticleButton('btnDie','die');
    bindArticleButton('btnDas','das');

    // Other buttons
    document.getElementById('checkBtn')?.addEventListener('click', checkAnswer);
    document.getElementById('resetBtn')?.addEventListener('click', resetProgress);
    document.getElementById('nextBtn')?.addEventListener('click', nextWord);

    // English toggle
    function applyEnglishVisibility(){
      const cb=document.getElementById('toggleEnglish');
      if(!englishRowEl) return;
      englishRowEl.style.display = cb && cb.checked ? '' : 'none';
    }
    document.getElementById('toggleEnglish')?.addEventListener('change', ()=>{ applyEnglishVisibility(); saveProgress(); });

    // Start
    applyEnglishVisibility();
    loadCSV();
  });
  </script>
  <script>
  /* =======================
     Verbs Trainer (ADD-ON)
     ======================= */
  
  /* LocalStorage keys (namespaced) */
  const MODE_KEY = 'mode'; // shared selector; defaults to 'vocab'
  const VERBS_LEVEL_KEY = 'verbs_level';
  const VERBS_UNLOCKED_KEY = 'verbs_unlocked_count';
  const VERBS_STREAKS_KEY = 'verbs_streaks';
  const VERBS_INDEX_KEY = 'verbs_index';
  
  /* State */
  const verbsState = {
    data: [],      // array of verbs
    index: 0,      // pointer within unlocked pool
    level: 1,      // 25 items per level
    unlocked: 25,  // how many available = level * 25
    streaks: {}    // id -> 0..3
  };
  
  /* DOM refs */
  const elModeSwitch = document.getElementById('mode-switch');
  const elVerbsCard  = document.getElementById('verbs-card');
  const elEnglish    = document.getElementById('verbs-english');
  const elInf        = document.getElementById('verbs-inf');
  const elAuxBtns    = Array.from(document.querySelectorAll('.aux-btn'));
  const elAuxBadge   = document.getElementById('verbs-aux-badge');
  const elAuxFixed   = document.getElementById('verbs-aux-fixed');
  const pIch = document.getElementById('verbs-p-ich');
  const pDu  = document.getElementById('verbs-p-du');
  const pEr  = document.getElementById('verbs-p-er');
  const pWir = document.getElementById('verbs-p-wir');
  const pIhr = document.getElementById('verbs-p-ihr');
  const pSie = document.getElementById('verbs-p-sie');
  const elPart = document.getElementById('verbs-partizip');
  const elCheck = document.getElementById('verbs-check');
  const elNext  = document.getElementById('verbs-next');
  const elFeedback = document.getElementById('verbs-feedback');
  
  /* Helpers */
  function lsGet(key, fallback) {
    try { const v = localStorage.getItem(key); return v ? JSON.parse(v) : fallback; } catch { return fallback; }
  }
  function lsSet(key, val) { try { localStorage.setItem(key, JSON.stringify(val)); } catch {} }
  function lsGetInt(key, fallback) {
    const v = localStorage.getItem(key); const n = v===null?NaN:parseInt(v,10); return Number.isFinite(n)?n:fallback;
  }
  function lsSetInt(key, n) { try { localStorage.setItem(key, String(n)); } catch {} }
  function norm(s){ return (s||'').trim().toLowerCase().replaceAll('ß','ss').replaceAll('ä','ae').replaceAll('ö','oe').replaceAll('ü','ue'); }
  function mark(el, ok){ el?.classList.remove('result-ok','result-bad'); el?.classList.add(ok?'result-ok':'result-bad'); }
  
  /* Mode switch (non-destructive) */
  function getMode(){ return localStorage.getItem(MODE_KEY) || 'vocab'; }
  function setMode(m){ localStorage.setItem(MODE_KEY, m); renderMode(); }
  function renderMode(){
    const mode = localStorage.getItem(MODE_KEY) || 'vocab';
  
    // Highlight the active mode button
    document.querySelectorAll('#mode-switch .mode-btn').forEach(btn=>{
      btn.classList.toggle('active', btn.dataset.mode === mode);
    });
  
    // Sections we want to show/hide
    const vocab = document.getElementById('vocab-wrapper'); // <- the wrapper you just added
    const verbs = document.getElementById('verbs-card');
  
    // Show Verbs card only in "verbs" mode
    if (verbs) verbs.hidden = (mode !== 'verbs');
  
    // Show Vocab only in "vocab" or "mix" (hide when "verbs")
    if (vocab) vocab.style.display = (mode === 'vocab' || mode === 'mix') ? '' : 'none';
  
    // If entering verbs, (re)render a fresh card
    if (mode === 'verbs') {
      chosenAux = null;          // from the verbs add-on state
      renderVerbsCard?.();       // safe call in case it’s not defined yet
    }
  }
  elModeSwitch?.addEventListener('click', (e)=>{
    if(e.target.matches('.mode-btn')){
      setMode(e.target.dataset.mode);
    }
  });
  
  /* Load verbs data
     - Tries verbs.csv (same folder) with header:
       id,lemma,english,aux,ich,du,er,wir,ihr,sie,partizip
     - If not found, uses a small mock so you can test UI immediately.
  */
  async function loadVerbsData(){
    let rows = null;
    try {
      const res = await fetch('verbs.csv', { cache: 'no-store' });
      if (res.ok) {
        const csv = await res.text();
        rows = parseCSV(csv);
      }
    } catch(_) {}
    if (!rows || rows.length===0) {
      rows = [
        { id:'v001', lemma:'gehen',  english:'to go',    aux:'sein',  ich:'gehe', du:'gehst', er:'geht', wir:'gehen', ihr:'geht', sie:'gehen', partizip:'gegangen' },
        { id:'v002', lemma:'machen', english:'to make',  aux:'haben', ich:'mache', du:'machst', er:'macht', wir:'machen', ihr:'macht', sie:'machen', partizip:'gemacht' },
        { id:'v003', lemma:'kommen', english:'to come',  aux:'sein',  ich:'komme', du:'kommst', er:'kommt', wir:'kommen', ihr:'kommt', sie:'kommen', partizip:'gekommen' },
      ];
    }
    verbsState.data = rows;
  }
  
  /* Tiny CSV parser (no deps) */
  function parseCSV(text){
    const lines = text.trim().split(/\r?\n/);
    const headers = lines.shift().split(',').map(h=>h.trim());
    return lines.map(line=>{
      const cells = [];
      let cur = '', inQ=false;
      for (let i=0;i<line.length;i++){
        const ch=line[i];
        if (ch==='\"'){ inQ = !inQ; continue; }
        if (ch===',' && !inQ){ cells.push(cur); cur=''; continue; }
        cur += ch;
      }
      cells.push(cur);
      const obj={};
      headers.forEach((h,i)=>obj[h]= (cells[i]||'').trim());
      // ensure id exists
      if (!obj.id) obj.id = 'v_' + obj.lemma + '_' + Math.random().toString(36).slice(2,7);
      return obj;
    });
  }
  
  /* Initialize state from LS */
  function initVerbsState(){
    verbsState.level   = lsGetInt(VERBS_LEVEL_KEY, 1);
    verbsState.unlocked= lsGetInt(VERBS_UNLOCKED_KEY, verbsState.level*25);
    verbsState.index   = lsGetInt(VERBS_INDEX_KEY, 0);
    verbsState.streaks = lsGet(VERBS_STREAKS_KEY, {});
  }
  
  /* Save state to LS */
  function saveVerbsState(){
    lsSetInt(VERBS_LEVEL_KEY, verbsState.level);
    lsSetInt(VERBS_UNLOCKED_KEY, verbsState.unlocked);
    lsSetInt(VERBS_INDEX_KEY, verbsState.index);
    lsSet(VERBS_STREAKS_KEY, verbsState.streaks);
  }
  
  /* Render current verb card */
  function currentVerb(){
    const pool = verbsState.data.slice(0, Math.min(verbsState.unlocked, verbsState.data.length));
    if (pool.length===0) return null;
    const i = Math.max(0, Math.min(verbsState.index % pool.length, pool.length-1));
    return pool[i];
  }
  
  function clearFieldStyles(){
    [elInf, pIch, pDu, pEr, pWir, pIhr, pSie, elPart].forEach(el=>el?.classList.remove('result-ok','result-bad'));
  }
  
  function renderVerbsCard(){
    const v = currentVerb();
    if (!v) { elVerbsCard.hidden = true; return; }
    clearFieldStyles();
    elEnglish.textContent = v.english || '';
    elInf.value = '';
    elPart.value = '';
    [pIch,pDu,pEr,pWir,pIhr,pSie].forEach(el=>{ if(el) el.value=''; });
    // aux UI reset
    elAuxBtns.forEach(btn=>btn.classList.remove('selected'));
    elAuxBadge.style.display='none';
    elAuxBadge.textContent='';
    elAuxFixed.textContent='—';
    elFeedback.textContent='';
  }
  
  /* Aux selection */
  let chosenAux = null;
  elAuxBtns.forEach(btn=>{
    btn.addEventListener('click', ()=>{
      chosenAux = btn.dataset.aux;
      elAuxBtns.forEach(b=>b.classList.toggle('selected', b===btn));
      elAuxBadge.style.display='inline-block';
      elAuxBadge.textContent = chosenAux;
      elAuxFixed.textContent = chosenAux;
    });
  });
  
  /* Check logic: full card must be correct to increment streak (3x target) */
  function checkVerbsCard(){
    const v = currentVerb();
    if (!v) return;
  
    // comparisons
    const okInf  = norm(elInf.value)   === norm(v.lemma);
    const okAux  = (chosenAux === (v.aux||'').toLowerCase());
    const okIch  = norm(pIch.value)    === norm(v.ich);
    const okDu   = norm(pDu.value)     === norm(v.du);
    const okEr   = norm(pEr.value)     === norm(v.er);
    const okWir  = norm(pWir.value)    === norm(v.wir);
    const okIhr  = norm(pIhr.value)    === norm(v.ihr);
    const okSie  = norm(pSie.value)    === norm(v.sie);
    const okPart = norm(elPart.value)  === norm(v.partizip);
  
    // mark fields
    mark(elInf, okInf);
    elAuxBtns.forEach(b=>b.classList.toggle('result-ok', okAux));
    elAuxBtns.forEach(b=>b.classList.toggle('result-bad', !okAux));
    mark(pIch, okIch); mark(pDu, okDu); mark(pEr, okEr);
    mark(pWir, okWir); mark(pIhr, okIhr); mark(pSie, okSie);
    mark(elPart, okPart);
  
    const allOK = okInf && okAux && okIch && okDu && okEr && okWir && okIhr && okSie && okPart;
  
    // streak update (per-item)
    const id = v.id;
    const cur = verbsState.streaks[id] || 0;
    verbsState.streaks[id] = allOK ? Math.min(3, cur + 1) : 0;
  
    // unlock next level if needed (every 25)
    maybeUnlockNextVerbsLevel();
  
    saveVerbsState();
  
    // feedback
    const streakNow = verbsState.streaks[id];
    elFeedback.textContent = allOK
      ? `✅ Perfect! Streak for "${v.lemma}" is now ${streakNow}/3.`
      : `❌ Not quite. Streak for "${v.lemma}" reset to 0.`;
  
    // (OPTIONAL) if you have a global XP/streak function, call it here safely:
    try {
      if (typeof updateStreak === 'function') {
        updateStreak({ mode: 'verbs', passed: allOK, correctFields: allOK?9:0, totalFields: 9 });
      }
    } catch(_) {}
  }
  
  /* Unlock logic identical shape to your vocab levels */
  function allVerbsInCurrentLevelComplete(){
    const need = verbsState.level * 25;
    const ids = verbsState.data.slice(0, Math.min(need, verbsState.data.length)).map(v=>v.id);
    return ids.length>0 && ids.every(id => (verbsState.streaks[id]||0) >= 3);
  }
  function maybeUnlockNextVerbsLevel(){
    if (allVerbsInCurrentLevelComplete()){
      verbsState.level += 1;
      verbsState.unlocked = Math.min(verbsState.level * 25, verbsState.data.length);
      // You can show a toast here if you have one
    }
  }
  
  /* Navigation */
  function nextVerb(){
    // Prefer items that are < 3 streak within unlocked set
    const pool = verbsState.data.slice(0, Math.min(verbsState.unlocked, verbsState.data.length));
    if (pool.length===0) return;
  
    let nextIdx = (verbsState.index + 1) % pool.length;
  
    // Try to find a verb with streak < 3
    const start = nextIdx;
    do {
      const id = pool[nextIdx].id;
      if ((verbsState.streaks[id]||0) < 3) break;
      nextIdx = (nextIdx + 1) % pool.length;
    } while(nextIdx !== start);
  
    verbsState.index = nextIdx;
    saveVerbsState();
    chosenAux = null;
    renderVerbsCard();
  }
  
  /* Wire buttons */
  elCheck?.addEventListener('click', checkVerbsCard);
  elNext ?.addEventListener('click', nextVerb);
  
  /* Boot */
  (async function initVerbs(){
    document.body.classList.add('dark'); // enables black mode
    
    await loadVerbsData();
    initVerbsState();
    renderMode();
  
    // If first time and no mode saved, keep your site behavior (vocab default).
    if (!localStorage.getItem(MODE_KEY)) localStorage.setItem(MODE_KEY, 'vocab');
  
    if (getMode() === 'verbs') renderVerbsCard();
  
    // Re-render verbs card whenever switching to verbs mode
    const obs = new MutationObserver(()=>{ if(getMode()==='verbs') renderVerbsCard(); });
    obs.observe(document.getElementById('mode-switch'), { attributes:true, childList:true, subtree:true });
  })();
  </script>
</body>
</html>