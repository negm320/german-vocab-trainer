<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>German Trainer</title>
  <style>
    :root{
      --bg:#0f1115; --text:#eaeaea; --muted:#9aa6b2; --card:#171b23; --border:#2a3240; --input:#0f1620;
      --btn:#243042; --btn-hover:#2a3a50; --ok:#22c55e; --bad:#f97373;
      --der:#7fb3ff; --der-text:#0b2139; --die:#ff9aa2; --die-text:#3a0b12; --das:#9be7a1; --das-text:#0d2a14;
    }
    *{box-sizing:border-box}
    body{font-family:Arial,sans-serif;margin:0;padding:10px;background:var(--bg);color:var(--text)}
    .container{max-width:500px;margin:auto;padding:10px}
    h1{font-size:1.8em;text-align:center;margin-bottom:10px}
    #level{text-align:center;margin-bottom:15px;font-size:1.1em;color:var(--muted)}
    .card{background:var(--card);border-radius:12px;padding:15px;box-shadow:0 2px 6px rgba(0,0,0,.35);border:1px solid var(--border)}

    .button-row{display:flex;gap:8px}
    .article-btn{flex:1 1 0;padding:12px 0;font-size:16px;border-radius:10px;cursor:pointer;border:1px solid var(--border);background:#202734;color:var(--text)}
    #btnDer.selected{background:var(--der);color:var(--der-text);border-color:#6aa6ff}
    #btnDie.selected{background:var(--die);color:var(--die-text);border-color:#ff8a93}
    #btnDas.selected{background:var(--das);color:var(--das-text);border-color:#86d892}

    input{width:48%;padding:12px;margin:5px 1%;font-size:16px;border-radius:8px;border:1px solid var(--border);background:var(--input);color:var(--text)}
    input::placeholder{color:#7b879a}
    input:focus{outline:2px solid #3b82f680;border-color:#3b82f6}

    button{padding:12px;margin:5px 1%;font-size:16px;border-radius:8px;border:1px solid var(--border);background:var(--btn);color:var(--text);cursor:pointer}
    button:hover{background:var(--btn-hover)}

    #feedback{margin-top:5px;font-size:1em}
    #example{margin-top:6px;font-size:.95em;color:var(--muted)}
    #nextBtn{display:none;width:100%}
    #status{margin-top:10px;font-size:.9em;color:var(--muted);white-space:pre-wrap}
  </style>
  
  <style>
    /* === Additive styles for Verbs UI === */
    #mode-switch { margin: 12px 0; display: flex; gap: 8px; flex-wrap: wrap; }
    #mode-switch .mode-btn { padding: 6px 10px; border: 1px solid #ccc; background: #f8f8f8; cursor: pointer; border-radius: 6px; }
    #mode-switch .mode-btn.active { background: #e8f2ff; border-color: #5b9cff; }
  
    #verbs-card { border: 1px solid #e5e5e5; border-radius: 10px; padding: 16px; margin: 8px 0 16px; background: #fff; }
    #verbs-card[hidden] { display: none; }
    #verbs-card .prompt { font-size: 20px; font-weight: 600; margin-bottom: 8px; }
  
    .aux-toggle { display: flex; align-items: center; gap: 8px; margin: 8px 0; }
    .aux-btn { padding: 6px 10px; border: 1px solid #ccc; background: #fafafa; border-radius: 6px; cursor: pointer; }
    .aux-btn.selected { background: #e8f2ff; border-color: #5b9cff; }
    .badge { display: inline-block; padding: 2px 8px; border-radius: 999px; border: 1px solid #5b9cff; color: #1b62cf; font-size: 12px; }
  
    .praesens-grid { display: grid; grid-template-columns: repeat(2, minmax(200px, 1fr)); gap: 8px 16px; margin: 10px 0; }
    .praesens-grid div { display: flex; align-items: center; gap: 6px; }
    .praesens-grid input, #verbs-inf, #verbs-partizip { width: 100%; padding: 6px 8px; }
  
    .result-ok { border-color: #29a36a !important; background: #f0fff7 !important; }
    .result-bad { border-color: #d9534f !important; background: #fff5f5 !important; }
  
    #verbs-actions { display: flex; gap: 8px; margin-top: 12px; }
    #verbs-actions button { padding: 8px 12px; border-radius: 6px; border: 1px solid #ccc; background: #f8f8f8; cursor: pointer; }
    #verbs-feedback { margin-top: 10px; font-size: 14px; }
  </style>
  
  <style>
    /* ===== Global dark theme (opt-in via .dark on <body>) ===== */
    body.dark { background: #0b0d10; color: #e8eaed; }
  
    /* try to harmonize common elements if they exist */
    body.dark input, body.dark select, body.dark button, body.dark textarea {
      background: #111418; color: #e8eaed; border: 1px solid #2a2f36;
    }
    body.dark .card, body.dark .panel, body.dark .box {
      background: #0f1216; border: 1px solid #2a2f36; color: #e8eaed;
    }
    body.dark a { color: #96b7ff; }
  
    /* ===== Verbs UI dark styles ===== */
    body.dark #mode-switch .mode-btn {
      background: #12151a; border-color: #2a2f36; color: #e8eaed;
    }
    body.dark #mode-switch .mode-btn.active {
      background: #162036; border-color: #3b6ad9;
    }
    body.dark #verbs-card {
      background: #0f1216; border-color: #2a2f36;
    }
    body.dark .aux-btn {
      background: #12151a; border-color: #2a2f36; color: #e8eaed;
    }
    body.dark .aux-btn.selected {
      background: #162036; border-color: #3b6ad9;
    }
    body.dark .badge {
      border-color: #3b6ad9; color: #9bb8ff;
    }
    /* check result colors tuned for dark bg */
    body.dark .result-ok { border-color: #2fa97b !important; background: #0f1b16 !important; }
    body.dark .result-bad { border-color: #e66b6b !important; background: #1a1111 !important; }
  </style>

  <style>
    #verbs-gov { margin: 10px 0 6px; display: grid; gap: 10px; }
    #verbs-gov .gov-row { display: grid; grid-template-columns: 110px 1fr; gap: 12px; align-items: center; }
    .refl-toggle { display: flex; gap: 8px; align-items: center; }
    .refl-btn { padding: 6px 10px; border: 1px solid #ccc; background: #fafafa; border-radius: 6px; cursor: pointer; }
    .refl-btn.selected { background: #e8f2ff; border-color: #5b9cff; }
  
    /* dark mode versions */
    body.dark #verbs-gov select,
    body.dark .refl-btn { background: #12151a; border-color: #2a2f36; color: #e8eaed; }
    body.dark .refl-btn.selected { background: #162036; border-color: #3b6ad9; }
  </style>

  <style>    
    /* Adj/Adv card styles (reuse look of verbs) */
    #adjadv-card { border: 1px solid var(--border); border-radius: 10px; padding: 16px; margin: 8px 0 16px; background: var(--card); }
    #adjadv-card[hidden] { display: none; }
    #adjadv-card .prompt { font-size: 20px; font-weight: 600; margin-bottom: 8px; }
    #adjadv-card input { width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 8px; background: var(--input); color: var(--text); }
    #adjadv-card .result-ok { border-color: #29a36a !important; background: #0f1b16 !important; }
    #adjadv-card .result-bad { border-color: #d9534f !important; background: #1a1111 !important; }
    .muted { color: var(--muted); }
  </style>

  <style>
    /* Make verbs inputs truly full width */
    #verbs-card .praesens-list { 
      grid-template-columns: 70px 1fr;  /* slimmer label column, more room for input */
    }
  
    /* Force width for all text inputs inside the verbs card */
    #verbs-card input[type="text"],
    #verbs-card input[list],
    #verbs-card input:not([type]),
    #verbs-gov input,
    #verbs-card .praesens-list input {
      width: 100% !important;
      box-sizing: border-box;
    }
  
    /* Optional: make the preposition row align perfectly */
    #verbs-gov .gov-row { 
      grid-template-columns: 110px 1fr; 
    }
  
    /* If some global CSS sets small widths, this beats it */
    #verbs-card input { 
      min-width: 0; 
      display: block; 
    }
  </style>

  
  <style>
    /* Vertical two-column label/input layout */
    .praesens-list {
      display: grid;
      grid-template-columns: 110px 1fr;
      row-gap: 10px;
      column-gap: 12px;
      margin: 12px 0;
      align-items: center;
    }
    .praesens-list label { opacity: 0.9; }
  
    /* Make verbs buttons dark (override whites) */
    body.dark #verbs-actions button {
      background: #12151a !important;
      border-color: #2a2f36 !important;
      color: #e8eaed !important;
    }
    body.dark #verbs-actions button:hover {
      background: #162036 !important;
      border-color: #3b6ad9 !important;
    }
  
    /* Ensure inputs match dark styling */
    body.dark #verbs-card input {
      background: #111418;
      color: #e8eaed;
      border: 1px solid #2a2f36;
    }
  </style>
  
  <style>
	  /* Correct answer tips under red fields */
	  .correct-tip {
		font-size: 0.85em;
		color: #aaa;
		margin-top: 2px;
		opacity: 0.8;
	  }
	  body.dark .correct-tip {
		color: #999;
	  }
	</style>

  
  <style>
	  .past-row { display: grid; grid-template-columns: 110px 1fr; gap: 12px; align-items: center; margin: 10px 0; }
	  .case-toggle { display: flex; gap: 8px; align-items: center; }
	  .case-btn { padding: 6px 10px; border: 1px solid #ccc; background: #fafafa; border-radius: 6px; cursor: pointer; }
	  .case-btn.selected { background: #e8f2ff; border-color: #5b9cff; }

	  body.dark .case-btn { background: #12151a; border-color: #2a2f36; color: #e8eaed; }
	  body.dark .case-btn.selected { background: #162036; border-color: #3b6ad9; }
	</style>


</head>
<body>
    <div id="mode-switch">
    <button class="mode-btn" data-mode="vocab">Vocab</button>
    <button class="mode-btn" data-mode="verbs">Verbs</button>
    <button class="mode-btn" data-mode="adjadv">Adj/Adv</button>
    <button class="mode-btn" data-mode="preps">Preps</button>
    <button class="mode-btn" data-mode="mix">Mix</button>
  </div>

  <div id="verbs-card" hidden>
    <div class="prompt" id="verbs-english">to go</div>

    <label for="verbs-inf">German infinitive</label>
    <input id="verbs-inf" autocomplete="off" />

    <div class="aux-toggle">
      <span>Auxiliary:</span>
      <button type="button" class="aux-btn" data-aux="haben">haben</button>
      <button type="button" class="aux-btn" data-aux="sein">sein</button>
      <span id="verbs-aux-badge" class="badge" style="display:none;"></span>
    </div>

    <!-- === Verb governance (preposition + reflexive) === -->
    <div id="verbs-gov">
      <div class="gov-row">
		  <label for="verbs-prep">Preposition</label>
		  <input id="verbs-prep" list="verbs-prep-options" placeholder="e.g., auf" autocomplete="off" />
		  <datalist id="verbs-prep-options">
			<option value="an"></option>
			<option value="auf"></option>
			<option value="aus"></option>
			<option value="bei"></option>
			<option value="fÃ¼r"></option>
			<option value="gegen"></option>
			<option value="in"></option>
			<option value="mit"></option>
			<option value="nach"></option>
			<option value="Ã¼ber"></option>
			<option value="um"></option>
			<option value="von"></option>
			<option value="zu"></option>
		  </datalist>
		</div>

		<div class="gov-row">
		  <label>Case after verb</label>
		  <div class="case-toggle">
			<button type="button" class="case-btn" data-case="inf">Inf</button>
			<button type="button" class="case-btn" data-case="akk">Akk</button>
			<button type="button" class="case-btn" data-case="dat">Dat</button>
		  </div>
		</div>

    
      <div class="gov-row">
		  <label>Reflexive?</label>
		  <div class="refl-toggle">
			<button type="button" class="refl-btn" data-refl="no">No</button>
			<button type="button" class="refl-btn" data-refl="yes">Yes</button>
		  </div>
		</div>

    </div>

    
    <div class="praesens-list">
      <label for="verbs-p-ich">ich</label>
      <input id="verbs-p-ich" autocomplete="off">
    
      <label for="verbs-p-du">du</label>
      <input id="verbs-p-du" autocomplete="off">
    
      <label for="verbs-p-er">er/sie/es</label>
      <input id="verbs-p-er" autocomplete="off">
    
      <label for="verbs-p-ihr">ihr</label>
      <input id="verbs-p-ihr" autocomplete="off">
    </div>

	<!-- Simple past -->
	<div class="past-row">
	  <label for="verbs-past">PrÃ¤teritum</label>
	  <input id="verbs-past" placeholder="z. B. ging" autocomplete="off">
	</div>

	<!-- Perfekt line -->
    <div class="perfekt">
      ich <span id="verbs-aux-fixed" class="badge">â€”</span>
      <input id="verbs-partizip" placeholder="Partizip II (z. B. gegangen)" autocomplete="off">
    </div>

    <div id="verbs-actions">
      <button id="verbs-check">Check</button>
      <button id="verbs-next">Next</button>
    </div>

    <div id="verbs-feedback"></div>
	
	<div id="verbs-level-indicator" style="margin-top:10px; font-size:12px; opacity:0.8;"></div>

  </div>
  
  <div id="adjadv-card" hidden>
    <div class="prompt" id="adjadv-english">beautiful</div>
  
    <label for="adjadv-german">German word</label>
    <input id="adjadv-german" autocomplete="off" placeholder="z. B. schÃ¶n" />
  
    <p id="adjadv-example" class="muted"></p>
  
    <div id="adjadv-actions" style="display:flex;gap:8px;margin-top:12px;">
      <button id="adjadv-check">Check</button>
      <button id="adjadv-next">Next</button>
    </div>
  
    <div id="adjadv-feedback" style="margin-top:10px;font-size:14px;"></div>
  </div>

   <!-- === Prepositions Trainer Card (simple: just the preposition) === -->
      <style>
        #preps-card { border: 1px solid var(--border); border-radius: 10px; padding: 16px; margin: 8px 0 16px; background: var(--card); }
        #preps-card[hidden] { display: none; }
        #preps-sentence { font-size: 20px; line-height: 1.6; margin-bottom: 10px; }
        #preps-input { padding: 8px 10px; border: 1px solid var(--border); border-radius: 8px; background: var(--input); color: var(--text); min-width: 80px; display: inline-block; text-align:center; }
        #preps-input.result-ok { border-color: #29a36a !important; background: #0f1b16 !important; }
        #preps-input.result-bad { border-color: #d9534f !important; background: #1a1111 !important; }
        #preps-english { color: var(--muted); margin: 6px 0 0; }
      </style>
      
      <div id="preps-card" hidden>
        <div id="preps-sentence"></div>
        <p id="preps-english" class="muted"></p>
      
        <div style="display:flex; gap:8px; margin-top:12px;">
          <button id="preps-check">Check</button>
          <button id="preps-next">Next</button>
        </div>
      
        <div id="preps-feedback" style="margin-top:10px;font-size:14px;"></div>
      
        <!-- Autocomplete list (plain prepositions, no + Akk/+ Dat) -->
        <datalist id="preps-options">
          <option value="an"></option>
          <option value="auf"></option>
          <option value="aus"></option>
          <option value="bei"></option>
          <option value="fÃ¼r"></option>
          <option value="gegen"></option>
          <option value="in"></option>
          <option value="mit"></option>
          <option value="nach"></option>
          <option value="Ã¼ber"></option>
          <option value="um"></option>
          <option value="unter"></option>
          <option value="von"></option>
          <option value="vor"></option>
          <option value="zu"></option>
          <option value="ohne"></option>
          <option value="trotz"></option>
        </datalist>
      </div>

  
  <div class="container">
    <div id="vocab-wrapper">
    <h1>German Vocab Trainer</h1>
    <p id="level">Level: 1 (Words 1â€“25)</p>
      <div class="card">
        <p id="englishRow"><strong>English word:</strong> <span id="english"></span> <em id="streakDisplay"></em></p>
  
        <div id="media" style="margin-bottom:8px;">
          <!-- Faster image: async decode + high fetch priority -->
          <img id="wordImage" alt="vocab image" decoding="async" fetchpriority="high"
               style="display:none;width:100%;max-height:220px;object-fit:contain;background:#0d0f14;border:1px solid var(--border);border-radius:10px;padding:8px;" />
        </div>
  
        <div class="button-row">
          <button id="btnDer" class="article-btn">der</button>
          <button id="btnDie" class="article-btn">die</button>
          <button id="btnDas" class="article-btn">das</button>
        </div>
  
        <input type="text" id="german" placeholder="German word" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
        <input type="text" id="plural" placeholder="Plural" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
        <p id="feedback"></p>
        <p id="example"></p>
  
        <br />
        <button id="checkBtn">Check</button>
        <button id="resetBtn">Reset Progress</button>
        <button id="nextBtn">Next word</button>
        <div id="status"></div>

        <label style="display:flex;align-items:center;gap:8px;margin:10px auto 0;max-width:500px;color:var(--muted);font-size:.95em;">
          <input type="checkbox" id="toggleEnglish" checked /> Show English word
        </label>
      </div>
    </div>
  </div>

  <script>
  document.addEventListener('DOMContentLoaded', () => {
    // ===== State =====
    let words = [];
    let currentWord = null;
    let chosenArticle = '';
    let level = 1;
    const wordsPerLevel = 25;
    const masteryThreshold = 3;
    let pluralEnterCount = 0;
    let lastFocusId = 'german';

    const statusEl = document.getElementById('status');
    const englishRowEl = document.getElementById('englishRow');

    // Show any uncaught error in the UI (helps diagnose blank screens)
    window.addEventListener('error', (e) => {
      if (statusEl) statusEl.textContent = 'âš ï¸ JS error: ' + (e.error?.message || e.message || String(e));
    });

    // === Image cache & preload ===
    let imageCache = new Map(); // german -> best src or null
    let preloadedNext = null;   // { word, src }

    function status(msg){ if(statusEl) statusEl.textContent = msg || ''; }

    // ===== CSV Parser =====
    function parseCSV(text){
      const rows=[]; let row=[]; let cur=''; let inQuotes=false;
      for(let i=0;i<text.length;i++){
        const c=text[i];
        if(c==='"'){
          if(inQuotes && text[i+1]==='"'){ cur+='"'; i++; } else { inQuotes=!inQuotes; }
        } else if(c===',' && !inQuotes){
          row.push(cur); cur='';
        } else if((c==='\n' || c==='\r') && !inQuotes){
          if(cur!=='' || row.length){ row.push(cur); rows.push(row); row=[]; cur=''; }
        } else {
          cur+=c;
        }
      }
      if(cur!=='' || row.length){ row.push(cur); rows.push(row); }
      return rows;
    }

    // ===== Data loading =====
    async function loadCSV(){
      try{
        status('Loading vocab.csvâ€¦');
        const res = await fetch('vocab.csv', {cache:'no-store'});
        if(!res.ok) throw new Error('Failed to load vocab.csv');
        const data = await res.text();
        const lines = parseCSV(data.trim());
        if(lines.length===0){ status('vocab.csv is empty'); return; }
        lines.shift();
        words = lines.map(cols=>{
          const english=cols[0]||''; const article=cols[1]||''; const german=cols[2]||''; const plural=cols[3]||'';
          const ex1=cols[4]||''; const ex2=cols[5]||''; const ex3=cols[6]||'';
          const examples=[ex1,ex2,ex3].filter(x=>x&&x.trim()!=='');
          return { english, article, german, plural, examples, correctStreak:0, answeredCorrect:false };
        });
        loadProgress();
        updateLevelDisplay();
        await nextWord();          // show first word
        schedulePreloadNext();     // start preloading immediately
        status('');
      }catch(e){ console.error(e); status('Error: '+e.message); }
    }

    function updateLevelDisplay(){
      const el = document.getElementById('level');
      if (el) el.textContent = `Level: ${level} (Words 1â€“${level*wordsPerLevel})`;
    }

    function getActiveWords(){ return words.slice(0, level*wordsPerLevel); }

    function getTierWords(){
      const active=getActiveWords(); if(active.length===0) return [];
      const minStreak=Math.min(...active.map(w=>w.correctStreak));
      return active.filter(w=>w.correctStreak===minStreak && !w.answeredCorrect);
    }

    // ===== Image helpers =====
    function replaceUmlauts(s){
      return (s||'')
        .replaceAll('Ã¤','ae').replaceAll('Ã„','Ae')
        .replaceAll('Ã¶','oe').replaceAll('Ã–','Oe')
        .replaceAll('Ã¼','ue').replaceAll('Ãœ','Ue')
        .replaceAll('ÃŸ','ss');
    }
    function buildCandidates(german){
      const baseRaw=(german||'').trim(); const bases=[];
      if(baseRaw){
        bases.push(baseRaw, baseRaw.toLowerCase(), baseRaw.replaceAll(' ','-'), baseRaw.toLowerCase().replaceAll(' ','-'));
        const uml=replaceUmlauts(baseRaw);
        bases.push(uml, uml.toLowerCase(), uml.replaceAll(' ','-'), uml.toLowerCase().replaceAll(' ','-'));
      }
      const exts=['jpg','jpeg','png','webp']; const out=[];
      bases.forEach(b=>exts.forEach(ext=>out.push('img/'+encodeURIComponent(b)+'.'+ext)));
      return out;
    }

    function resolveImageSrcForGerman(german){
      return new Promise((resolve)=>{
        if(!german){ resolve(null); return; }
        if(imageCache.has(german)){ resolve(imageCache.get(german)); return; }

        const candidates = buildCandidates(german);
        let i = 0, done = false;

        const tryNext = ()=>{
          if(done) return;
          if(i >= candidates.length){ done = true; imageCache.set(german, null); resolve(null); return; }
          const src = candidates[i++];
          const probe = new Image();
          probe.onload = ()=>{ if(done) return; done = true; imageCache.set(german, src); resolve(src); };
          probe.onerror = tryNext;
          probe.src = src;
        };
        tryNext();
      });
    }

    async function preloadWordImage(word){
      if(!word || !word.german) return { word, src: null };
      const src = await resolveImageSrcForGerman(word.german);
      return { word, src };
    }

    // Faster image: no artificial wait
    async function loadImageForCurrent(waitMs = 0){
      const img=document.getElementById('wordImage');
      if(!img) return;

      img.style.display='none';
      img.removeAttribute('src');
      if(!currentWord || !currentWord.german) return;

      let src = (preloadedNext && preloadedNext.word === currentWord) ? preloadedNext.src : null;
      if(!src){ src = await resolveImageSrcForGerman(currentWord.german); }
      if(!src){ return; }

      if(waitMs > 0) await new Promise(r => setTimeout(r, waitMs));

      img.onload = ()=>{ img.style.display='block'; };
      img.onerror = ()=>{ img.style.display='none'; };
      img.src = src;
    }

    function pickNextCandidateWord(){
      const active = getActiveWords();
      if(active.length === 0) return null;

      const minStreak = Math.min(...active.map(w => w.correctStreak));
      let tier = active.filter(w => w.correctStreak === minStreak && !w.answeredCorrect);
      if(tier.length === 0) tier = active.filter(w => w.correctStreak === minStreak);
      if(tier.length === 0) tier = active;

      return tier[Math.floor(Math.random()*tier.length)];
    }
    async function schedulePreloadNext(){
      const candidate = pickNextCandidateWord();
      if(!candidate){ preloadedNext = null; return; }
      preloadedNext = await preloadWordImage(candidate);
    }

    async function nextWord(){
      const activeWords=getActiveWords(); if(activeWords.length===0) return;

      let tierWords=getTierWords();
      if(tierWords.length===0){
        const minStreak=Math.min(...activeWords.map(w=>w.correctStreak));
        activeWords.filter(w=>w.correctStreak===minStreak).forEach(w=>w.answeredCorrect=false);
        tierWords=getTierWords();
      }
      const list=(tierWords.length?tierWords:activeWords);
      currentWord=list[Math.floor(Math.random()*list.length)];

      const englishEl = document.getElementById('english');
      const streakEl  = document.getElementById('streakDisplay');
      const germanEl  = document.getElementById('german');
      const pluralEl  = document.getElementById('plural');
      const feedbackEl= document.getElementById('feedback');
      const exampleEl = document.getElementById('example');
      const nextBtn   = document.getElementById('nextBtn');

      if(englishEl) englishEl.textContent=currentWord.english;
      if(streakEl)  streakEl.textContent=`(${currentWord.correctStreak}/${masteryThreshold})`;
      if(germanEl)  germanEl.value='';
      if(pluralEl)  pluralEl.value='';
      if(feedbackEl)feedbackEl.textContent='';
      if(exampleEl) exampleEl.textContent='';
      if(nextBtn)   nextBtn.style.display='none';

      chosenArticle='';
      resetArticleButtons();
      pluralEnterCount=0;

      applyEnglishVisibility();

      // Begin resolving image ASAP, then show it
      await loadImageForCurrent(0);
      schedulePreloadNext();

      if(germanEl){
        setTimeout(()=>{
          germanEl.focus();
          try{ germanEl.scrollIntoView({ behavior:'smooth', block:'center' }); }catch{}
        },0);
      }
    }

    function resetArticleButtons(){
      const a=document.getElementById('btnDer');
      const b=document.getElementById('btnDie');
      const c=document.getElementById('btnDas');
      if(a) a.classList.remove('selected');
      if(b) b.classList.remove('selected');
      if(c) c.classList.remove('selected');
    }

    function chooseArticle(article){
      chosenArticle=article; resetArticleButtons();
      if(article==='der') document.getElementById('btnDer')?.classList.add('selected');
      if(article==='die') document.getElementById('btnDie')?.classList.add('selected');
      if(article==='das') document.getElementById('btnDas')?.classList.add('selected');

      const germanEl=document.getElementById('german');
      if(germanEl){
        lastFocusId='german';
        setTimeout(()=>{
          germanEl.focus();
          try{ germanEl.scrollIntoView({ behavior:'smooth', block:'center' }); }catch{}
        },0);
      }
    }

    function randomExample(examples){ if(!examples||examples.length===0) return ''; const i=Math.floor(Math.random()*examples.length); return examples[i]; }

    function checkAnswer(){
      if(!currentWord) return;
      const german=(document.getElementById('german')?.value || '').trim().toLowerCase();
      const plural=(document.getElementById('plural')?.value || '').trim().toLowerCase();
      let feedback='';
      const correctGerman=(currentWord.german||'').toLowerCase();
      const correctPlural=(currentWord.plural||'').toLowerCase();
      const pluralCorrect=(plural===correctPlural) || (correctPlural==='â€”' && plural==='');
      if(chosenArticle===currentWord.article && german===correctGerman && pluralCorrect){
        currentWord.correctStreak++; currentWord.answeredCorrect=true; feedback='<span style="color:var(--ok)">Correct!</span>';
      } else {
        currentWord.correctStreak=0; currentWord.answeredCorrect=false; feedback=`<span style="color:var(--bad)">Wrong!</span><br>Correct: ${currentWord.article} ${currentWord.german} â€” ${currentWord.plural}`;
      }
      const feedbackEl=document.getElementById('feedback');
      if(feedbackEl) feedbackEl.innerHTML=feedback;
      const streakEl=document.getElementById('streakDisplay');
      if(streakEl) streakEl.textContent=`(${currentWord.correctStreak}/${masteryThreshold})`;
      const ex=randomExample(currentWord.examples);
      const exampleEl=document.getElementById('example');
      if(exampleEl) exampleEl.textContent=ex?`ðŸ“ ${ex}`:'';
      const nextBtn=document.getElementById('nextBtn');
      if(nextBtn) nextBtn.style.display='inline-block';
      saveProgress();

      const activeWords=getActiveWords();
      const allMastered=activeWords.every(w=>w.correctStreak>=masteryThreshold);
      if(allMastered && level*wordsPerLevel<words.length){
        level++; activeWords.forEach(w=>{w.correctStreak=0; w.answeredCorrect=false;}); updateLevelDisplay(); saveProgress();
      }
    }

    function saveProgress(){
      try{ localStorage.setItem('vocabProgress', JSON.stringify({ words, level, showEnglish: document.getElementById('toggleEnglish')?.checked })); }catch{}
    }

    function loadProgress(){
      try{
        const saved=localStorage.getItem('vocabProgress');
        const cb=document.getElementById('toggleEnglish');
        if(saved){
          const data=JSON.parse(saved);
          level=data.level||1;
          if(cb) cb.checked = (data.showEnglish!==undefined)? !!data.showEnglish : true;
          words.forEach((w,i)=>{ if(data.words && data.words[i]){ w.correctStreak=data.words[i].correctStreak||0; w.answeredCorrect=data.words[i].answeredCorrect||false; } });
        } else { if(cb) cb.checked = true; }
      }catch{}
    }

    function resetProgress(){
      if(confirm('Are you sure you want to reset progress?')){
        try{ localStorage.removeItem('vocabProgress'); }catch{}
        words.forEach(w=>{ w.correctStreak=0; w.answeredCorrect=false; }); level=1; updateLevelDisplay(); nextWord();
      }
    }

    // Input focus + Enter behavior
    document.getElementById('german')?.addEventListener('focus', ()=>{ lastFocusId='german'; });
    document.getElementById('plural')?.addEventListener('focus', ()=>{ lastFocusId='plural'; });

    document.getElementById('german')?.addEventListener('keydown', e=>{ if(e.key==='Enter'){ e.preventDefault(); document.getElementById('plural')?.focus(); }});
    document.getElementById('plural')?.addEventListener('keydown', e=>{
      if(e.key==='Enter'){
        e.preventDefault();
        pluralEnterCount++;
        if(pluralEnterCount===1) checkAnswer();
        else if(pluralEnterCount===2){ pluralEnterCount=0; nextWord(); }
      }
    });

    // ===== Article buttons â€” keep keyboard up =====
    function bindArticleButton(id, article){
      const el = document.getElementById(id);
      if(!el) return;

      // Prevent the button from stealing focus (so keyboard stays open)
      const early = (e)=>{ 
        try { e.preventDefault(); } catch {}
        chooseArticle(article);
      };
      el.addEventListener('pointerdown', early);
      el.addEventListener('mousedown', early);
      el.addEventListener('click', (e)=>{ e.preventDefault(); chooseArticle(article); });
    }
    bindArticleButton('btnDer','der');
    bindArticleButton('btnDie','die');
    bindArticleButton('btnDas','das');

    // Other buttons
    document.getElementById('checkBtn')?.addEventListener('click', checkAnswer);
    document.getElementById('resetBtn')?.addEventListener('click', resetProgress);
    document.getElementById('nextBtn')?.addEventListener('click', nextWord);

    // English toggle
    function applyEnglishVisibility(){
      const cb=document.getElementById('toggleEnglish');
      if(!englishRowEl) return;
      englishRowEl.style.display = cb && cb.checked ? '' : 'none';
    }
    document.getElementById('toggleEnglish')?.addEventListener('change', ()=>{ applyEnglishVisibility(); saveProgress(); });

    // Start
    applyEnglishVisibility();
    loadCSV();
  });
  </script>
  <script>
        /* =======================
           Verbs Trainer (ADD-ON)
           ======================= */
        
        /* LocalStorage keys (namespaced) */
        const MODE_KEY = 'mode'; // shared selector; defaults to 'vocab'
        const VERBS_LEVEL_KEY = 'verbs_level';
        const VERBS_UNLOCKED_KEY = 'verbs_unlocked_count';
        const VERBS_STREAKS_KEY = 'verbs_streaks';
        const VERBS_INDEX_KEY = 'verbs_index';
        
        /* State */
        const verbsState = {
          data: [],      // array of verbs
          index: 0,      // pointer within unlocked pool
          level: 1,      // 25 items per level
          unlocked: 25,  // how many available = level * 25
          streaks: {}    // id -> 0..3
        };
        
        /* DOM refs */
        const elModeSwitch = document.getElementById('mode-switch');
        const elVerbsCard  = document.getElementById('verbs-card');
        const elEnglish    = document.getElementById('verbs-english');
        const elInf        = document.getElementById('verbs-inf');
        const elAuxBtns    = Array.from(document.querySelectorAll('.aux-btn'));
        const elAuxBadge   = document.getElementById('verbs-aux-badge');
        const elAuxFixed   = document.getElementById('verbs-aux-fixed');
        const pIch = document.getElementById('verbs-p-ich');
        const pDu  = document.getElementById('verbs-p-du');
        const pEr  = document.getElementById('verbs-p-er');
        const pIhr = document.getElementById('verbs-p-ihr');  const elPart = document.getElementById('verbs-partizip');
        const elCheck = document.getElementById('verbs-check');
        const elNext  = document.getElementById('verbs-next');
        const elFeedback = document.getElementById('verbs-feedback');
        const reflBtns = Array.from(document.querySelectorAll('.refl-btn'));
        const selReflCase = document.getElementById('verbs-refl-case');
		
		// Keep track: after Check is pressed once, second Enter on last field should go Next
		elCheck?.addEventListener('click', ()=> { lastFieldCheckedOnce = true; });
		elNext ?.addEventListener('click', ()=> { lastFieldCheckedOnce = false; });

		
		// NEW fields
		const inpPast = document.getElementById('verbs-past');     // PrÃ¤teritum
		const inpPrep = document.getElementById('verbs-prep');     // preposition input

		// Case buttons + state
		const caseBtns = Array.from(document.querySelectorAll('.case-btn'));
		let chosenCase = null;  // 'inf' | 'akk' | 'dat' | null

		let lastFieldCheckedOnce = false; // first Enter on last field triggers Check; second triggers Next


		// Reflexive state (we already had chosenRefl)
		let chosenRefl = null;  // 'yes' | 'no' | null
		
		let chosenAux = null;   // 'haben' | 'sein'

		// remember last focused text input (to keep keyboard open)
		let lastInputFocus = null;
		[elInf, inpPrep, pIch, pDu, pEr, pIhr, inpPast, elPart].forEach(el=>{
		  el?.addEventListener('focus', ()=>{
			lastInputFocus = el;
			scrollFieldIntoView(el);
		  });
		});


      
      
          // The order you want to tab through with Enter:
          function focusChain(){
		  return [elInf, inpPrep, pIch, pDu, pEr, pIhr, inpPast, elPart]
			.filter(el => el && !el.disabled && el.offsetParent !== null);
		}

       
        function focusNextFrom(current){
		  const list = focusChain();
		  const i = list.indexOf(current);
		  if (i >= 0 && i < list.length - 1) {
			const nextEl = list[i+1];
			nextEl.focus({preventScroll:true});
			scrollFieldIntoView(nextEl);
		  } else {
			elCheck?.click();
		  }
		}

        // Add Enter key handler to each input
        [elInf, inpPrep, pIch, pDu, pEr, pIhr, inpPast, elPart].forEach(el=>{
		  el?.addEventListener('keydown', (e)=>{
			if (e.key === 'Enter') {
			  e.preventDefault();
			  const list   = focusChain();
			  const lastEl = list[list.length - 1];
			  const isLast = (e.target === lastEl);

			  if (isLast) {
				if (!lastFieldCheckedOnce) {
				  // First Enter on last field => CHECK
				  elCheck?.click();
				  // keep focus on the same field so second Enter goes Next
				  e.target.focus({ preventScroll: true });
				  scrollFieldIntoView(e.target);
				} else {
				  // Second Enter on last field => NEXT
				  elNext?.click();
				}
			  } else {
				// Normal path: go to next field
				focusNextFrom(e.target);
			  }
			}
		  });
		});

      
          
        /* Helpers */
        function lsGet(key, fallback) {
          try { const v = localStorage.getItem(key); return v ? JSON.parse(v) : fallback; } catch { return fallback; }
        }
        function lsSet(key, val) { try { localStorage.setItem(key, JSON.stringify(val)); } catch {} }
        function lsGetInt(key, fallback) {
          const v = localStorage.getItem(key); const n = v===null?NaN:parseInt(v,10); return Number.isFinite(n)?n:fallback;
        }
        function lsSetInt(key, n) { try { localStorage.setItem(key, String(n)); } catch {} }
        function norm(s){ return (s||'').trim().toLowerCase().replaceAll('ÃŸ','ss').replaceAll('Ã¤','ae').replaceAll('Ã¶','oe').replaceAll('Ã¼','ue'); }
        function mark(el, ok){ el?.classList.remove('result-ok','result-bad'); el?.classList.add(ok?'result-ok':'result-bad'); }
        
		// Helper: show the correct answer below wrong inputs
		function showCorrect(el, isOK, correctValue){
		  // remove old tip if any
		  const old = el?.nextElementSibling;
		  if (old && old.classList.contains('correct-tip')) old.remove();

		  if (!isOK && correctValue && el) {
			el.insertAdjacentHTML('afterend', `<div class="correct-tip">${correctValue}</div>`);
		  }
		}
		
		function updateLevelIndicator(){
		  const el = document.getElementById('verbs-level-indicator');
		  if (!el || !verbsState?.data?.length) return;

		  // current level (default 1); if you store it differently, adjust here
		  const level = verbsState.level || getInt?.('verbs_level', 1) || 1;

		  // total items available up to this level (25 per level)
		  const totalUpToLevel = Math.min(level * 25, verbsState.data.length);

		  // build IDs for first N verbs
		  const idsUpToLevel = verbsState.data.slice(0, totalUpToLevel)
			.map(v => v.id || `${v.lemma}_${v.english}`);

		  const doneUpToLevel = idsUpToLevel
			.filter(id => (verbsState.streaks?.[id] || 0) >= 3)
			.length;

		  el.textContent = `Level ${level} â€¢ ${doneUpToLevel}/${totalUpToLevel} mastered`;
		}


		//Scroll to focus the text field helper
		function scrollFieldIntoView(el){
		  if (!el) return;
		  // small delay helps on mobile when keyboard pops
		  setTimeout(()=>{ try { el.scrollIntoView({ behavior:'smooth', block:'center' }); } catch(_){} }, 50);
		}

		
        /* Mode switch (non-destructive) */
        function getMode(){ return localStorage.getItem(MODE_KEY) || 'vocab'; }
        function setMode(m){ localStorage.setItem(MODE_KEY, m); renderMode(); }
        function renderMode(){
          const mode = localStorage.getItem(MODE_KEY) || 'vocab';
        
          // Highlight the active mode button
          document.querySelectorAll('#mode-switch .mode-btn').forEach(btn=>{
            btn.classList.toggle('active', btn.dataset.mode === mode);
          });
        
          // Sections we want to show/hide
          const vocab = document.getElementById('vocab-wrapper'); // <- the wrapper you just added
          const verbs = document.getElementById('verbs-card');
        
          // Show Verbs card only in "verbs" mode
          if (verbs) verbs.hidden = (mode !== 'verbs');
        
          // Show Vocab only in "vocab" or "mix" (hide when "verbs")
          if (vocab) vocab.style.display = (mode === 'vocab' || mode === 'mix') ? '' : 'none';
        
          // If entering verbs, (re)render a fresh card
          if (mode === 'verbs') {
            chosenAux = null;          // from the verbs add-on state
            renderVerbsCard?.();       // safe call in case itâ€™s not defined yet
          }
        }
        elModeSwitch?.addEventListener('click', (e)=>{
          if(e.target.matches('.mode-btn')){
            setMode(e.target.dataset.mode);
          }
        });
        
        /* Load verbs data
           - Tries verbs.csv (same folder) with header:
             id,lemma,english,aux,ich,du,er,wir,ihr,sie,partizip
           - If not found, uses a small mock so you can test UI immediately.
        */
        async function loadVerbsData(){
          let rows = null;
          try {
            const res = await fetch('verbs.csv', { cache: 'no-store' });
            if (res.ok) {
              const csv = await res.text();
              rows = parseCSV(csv);
            }
          } catch(_) {}
          if (!rows || rows.length===0) {
            rows = [
              { id:'v001', lemma:'gehen',  english:'to go',    aux:'sein',  ich:'gehe', du:'gehst', er:'geht', wir:'gehen', ihr:'geht', sie:'gehen', partizip:'gegangen' },
              { id:'v002', lemma:'machen', english:'to make',  aux:'haben', ich:'mache', du:'machst', er:'macht', wir:'machen', ihr:'macht', sie:'machen', partizip:'gemacht' },
              { id:'v003', lemma:'kommen', english:'to come',  aux:'sein',  ich:'komme', du:'kommst', er:'kommt', wir:'kommen', ihr:'kommt', sie:'kommen', partizip:'gekommen' },
            ];
          }
          verbsState.data = rows;
        }
        
        /* Tiny CSV parser (no deps) */
        function parseCSV(text){
          const lines = text.trim().split(/\r?\n/);
          const headers = lines.shift().split(',').map(h=>h.trim());
          return lines.map(line=>{
            const cells = [];
            let cur = '', inQ=false;
            for (let i=0;i<line.length;i++){
              const ch=line[i];
              if (ch==='\"'){ inQ = !inQ; continue; }
              if (ch===',' && !inQ){ cells.push(cur); cur=''; continue; }
              cur += ch;
            }
            cells.push(cur);
            const obj={};
            headers.forEach((h,i)=>obj[h]= (cells[i]||'').trim());
            // ensure id exists
            if (!obj.id) obj.id = 'v_' + obj.lemma + '_' + Math.random().toString(36).slice(2,7);
            return obj;
          });
        }
        
        /* Initialize state from LS */
        function initVerbsState(){
          verbsState.level   = lsGetInt(VERBS_LEVEL_KEY, 1);
          verbsState.unlocked= lsGetInt(VERBS_UNLOCKED_KEY, verbsState.level*25);
          verbsState.index   = lsGetInt(VERBS_INDEX_KEY, 0);
          verbsState.streaks = lsGet(VERBS_STREAKS_KEY, {});
        }
        
        /* Save state to LS */
        function saveVerbsState(){
          lsSetInt(VERBS_LEVEL_KEY, verbsState.level);
          lsSetInt(VERBS_UNLOCKED_KEY, verbsState.unlocked);
          lsSetInt(VERBS_INDEX_KEY, verbsState.index);
          lsSet(VERBS_STREAKS_KEY, verbsState.streaks);
        }
        
        /* Render current verb card */
        function currentVerb(){
          const pool = verbsState.data.slice(0, Math.min(verbsState.unlocked, verbsState.data.length));
          if (pool.length===0) return null;
          const i = Math.max(0, Math.min(verbsState.index % pool.length, pool.length-1));
          return pool[i];
        }
        
        function clearFieldStyles(){
          [elInf, pIch, pDu, pEr, pIhr, elPart].forEach(el=>el?.classList.remove('result-ok','result-bad'));
        }
        
        function renderVerbsCard(){
          const v = currentVerb();
          if (!v) { elVerbsCard.hidden = true; return; }
          clearFieldStyles();
          elEnglish.textContent = v.english || '';
          elInf.value = '';
          elPart.value = '';
          [pIch,pDu,pEr,pIhr].forEach(el=>{ if(el) el.value=''; });
		  
		  // Enter-behavior state reset for the last field
			lastFieldCheckedOnce = false;

      
          if (inpPrep) inpPrep.value = '';
		  
		  // --- NEW: reset extra governance fields for each new card ---

			// Preposition input (just the preposition, e.g., "auf")
			if (inpPrep) inpPrep.value = '';

			// Past (PrÃ¤teritum) input (e.g., "ging")
			if (inpPast) inpPast.value = '';

			// Case buttons (Inf/Akk/Dat)
			chosenCase = null;
			caseBtns.forEach(b => b.classList.remove('selected'));

			// Reflexive buttons (Yes/No)
			chosenRefl = null;
			reflBtns.forEach(b => b.classList.remove('selected'));
      
          
          // Reset preposition & reflexive UI (new feature)
          if (inpPrep) inpPrep.value = '';               // reset preposition dropdown
          chosenRefl = null;                             // forget previous yes/no choice
          reflBtns.forEach(b=>b.classList.remove('selected'));  // unselect both buttons
          if (selReflCase) { 
            selReflCase.value = 'Akk';                   // set default case to Akkusativ
            selReflCase.disabled = true;                 // keep it disabled until "Yes" is clicked
          }
      
          // aux UI reset
          elAuxBtns.forEach(btn=>btn.classList.remove('selected'));
          elAuxBadge.style.display='none';
          elAuxBadge.textContent='';
          elAuxFixed.textContent='â€”';
          elFeedback.textContent='';
		  
		  // remove any old correct tips
			document.querySelectorAll('.correct-tip').forEach(tip => tip.remove());

			updateLevelIndicator();


        }
        
        // Function to select auxiliary (haben/sein)
        function selectAux(aux){ // 'haben' or 'sein'
          chosenAux = aux;
          elAuxBtns.forEach(b=>b.classList.toggle('selected', b.dataset.aux === aux));
          elAuxBadge.style.display='inline-block';
          elAuxBadge.textContent = aux;
          elAuxFixed.textContent = (aux === 'haben') ? 'habe' : 'bin';
        }
        
        // Make sure clicking buttons doesnâ€™t close the keyboard
        elAuxBtns.forEach(btn=>{
          // On touch or click, prevent the input from losing focus
          btn.addEventListener('mousedown', (e)=>{ 
            e.preventDefault();            // stop losing focus
            selectAux(btn.dataset.aux);    // handle logic
            if (lastInputFocus) lastInputFocus.focus({preventScroll:true}); // refocus
          });
          btn.addEventListener('touchstart', (e)=>{ 
            e.preventDefault(); 
            selectAux(btn.dataset.aux);
            if (lastInputFocus) lastInputFocus.focus({preventScroll:true});
          }, {passive:false});
          // Also handle desktop clicks normally
          btn.addEventListener('click', ()=> selectAux(btn.dataset.aux));
        });
      
		// === CASE BUTTONS (Inf / Akk / Dat) ===

		// function to remember which case you picked
		function selectCase(val){ // 'inf' | 'akk' | 'dat'
		  chosenCase = val;
		  caseBtns.forEach(b => 
			b.classList.toggle('selected', b.dataset.case === val)
		  );
		}

		// these make sure tapping buttons on mobile doesn't close keyboard
		caseBtns.forEach(btn=>{
		  btn.addEventListener('mousedown', (e)=>{
			e.preventDefault();                     // stop losing focus
			selectCase(btn.dataset.case);           // mark this case as chosen
			if (lastInputFocus)                     // if a text field was focused...
			  lastInputFocus.focus({preventScroll:true}); // ...keep it focused
		  });

		  btn.addEventListener('touchstart', (e)=>{
			e.preventDefault(); 
			selectCase(btn.dataset.case);
			if (lastInputFocus)
			  lastInputFocus.focus({preventScroll:true});
		  }, {passive:false});

		  // desktop fallback (works even if you donâ€™t need it)
		  btn.addEventListener('click', ()=> selectCase(btn.dataset.case));
		});
	  
	  
          // Function to choose reflexive yes/no
          function selectRefl(val){ // 'yes' or 'no'
            chosenRefl = val;
            reflBtns.forEach(b=>b.classList.toggle('selected', b.dataset.refl === val));
            if (selReflCase) selReflCase.disabled = (val !== 'yes');

          }
          
            // Prevent losing focus so keyboard stays up
            reflBtns.forEach(btn=>{
              btn.addEventListener('mousedown', (e)=>{ 
                e.preventDefault();
                selectRefl(btn.dataset.refl);
                if (lastInputFocus) lastInputFocus.focus({preventScroll:true});
              });
              btn.addEventListener('touchstart', (e)=>{ 
                e.preventDefault();
                selectRefl(btn.dataset.refl);
                if (lastInputFocus) lastInputFocus.focus({preventScroll:true});
              }, {passive:false});
              btn.addEventListener('click', ()=> selectRefl(btn.dataset.refl));
            });
      
      
        
        /* Check logic: full card must be correct to increment streak (3x target) */
		function checkVerbsCard(){
		  const v = currentVerb();
		  if (!v) return;

		  // --- 1) Basic checks (infinitive, aux, PrÃ¤sens, past, partizip) ---
		  const okInf  = norm(elInf.value)   === norm(v.lemma || '');
		  // AUX supports "sein" or "haben" or "sein/haben" in CSV
		  const allowedAux = String(v.aux || '').toLowerCase().split('/').map(s=>s.trim()).filter(Boolean);
		  const okAux  = allowedAux.includes((chosenAux || '').toLowerCase());

		  const okIch  = norm(pIch.value)    === norm(v.ich || '');
		  const okDu   = norm(pDu.value)     === norm(v.du || '');
		  const okEr   = norm(pEr.value)     === norm(v.er || '');
		  const okIhr  = norm(pIhr.value)    === norm(v.ihr || '');

		  const okPast = norm((inpPast?.value)||'') === norm(v.past || '');
		  const okPart = norm(elPart.value)  === norm(v.partizip || '');

		  // Mark the text inputs green/red
		  mark(elInf, okInf);
		  // Aux buttons visual
		  elAuxBtns.forEach(b=>{
			b.classList.remove('result-ok','result-bad');
			b.classList.add(okAux ? 'result-ok' : 'result-bad');
		  });
		  mark(pIch, okIch); mark(pDu, okDu); mark(pEr, okEr); mark(pIhr, okIhr);
		  mark(inpPast, okPast); mark(elPart, okPart);
		  
		  // --- show correct answers under wrong fields ---
			showCorrect(elInf, okInf, v.lemma);
			showCorrect(pIch, okIch, v.ich);
			showCorrect(pDu, okDu, v.du);
			showCorrect(pEr, okEr, v.er);
			showCorrect(pIhr, okIhr, v.ihr);
			showCorrect(inpPast, okPast, v.past);
			showCorrect(elPart, okPart, v.partizip);
			showCorrect(inpPrep, okPrep, v.preps);


		  // --- 2) Preposition (CSV now has ONLY the preposition(s)) ---
		  // CSV: preps = "auf;an;mit" or "" (empty means: no preposition requirement)
		  let okPrep = true;
		  const csvPreps = String(v.preps || '').split(';').map(s=>s.trim().toLowerCase()).filter(Boolean); // ["auf","an"]
		  if (csvPreps.length) {
			const userPrep = (inpPrep?.value || '').trim().toLowerCase();
			okPrep = csvPreps.includes(userPrep);
			if (inpPrep) {
			  inpPrep.classList.remove('result-ok','result-bad');
			  inpPrep.classList.add(okPrep ? 'result-ok' : 'result-bad');
			}
		  }

		  // --- 3) Case after the verb (buttons: Inf / Akk / Dat) ---
		  // CSV: case = "Inf" | "Akk" | "Dativ" (or empty)
		  let okCase = true;
		  const csvCaseRaw = String(v.case || '').trim().toLowerCase(); // "inf" | "akk" | "dativ"
		  // normalize variants
		  const csvCase = csvCaseRaw
			.replace('akkusativ','akk')
			.replace('dativ','dat')
			.replace('infinitiv','inf');
		  if (csvCase) {
			okCase = (chosenCase === csvCase); // chosenCase is 'inf' | 'akk' | 'dat'
			caseBtns.forEach(b=>{
			  b.classList.remove('result-ok','result-bad');
			  b.classList.add(okCase ? 'result-ok' : 'result-bad');
			});
		  }

		  // --- 4) Reflexive (Yes/No only) ---
		  // CSV: reflexive = True/False (boolean-ish)
		  let okRefl = true;
		  const needRefl = String(v.reflexive || '').toLowerCase(); // "true" | "false" | ""
		  if (needRefl === 'true') {
			okRefl = (chosenRefl === 'yes');
		  } else if (needRefl === 'false') {
			// allow 'no' or untouched (null) to count as correct non-reflexive
			okRefl = (chosenRefl === 'no' || chosenRefl === null);
		  }
		  reflBtns.forEach(b=>{
			b.classList.remove('result-ok','result-bad');
			if (needRefl) b.classList.add(okRefl ? 'result-ok' : 'result-bad');
		  });

		  // --- 5) Final pass/fail & scoring ---
		  const allOK =
			okInf && okAux &&
			okIch && okDu && okEr && okIhr &&
			okPast && okPart && okPrep && okCase && okRefl;

		  // Base fields we always check now: 8
		  // (inf, aux, ich, du, er, ihr, past, partizip)
		  let total = 8;
		  if (csvPreps.length) total += 1;       // preposition present in CSV
		  if (csvCase)          total += 1;       // case present in CSV
		  if (needRefl)         total += 1;       // reflexive requirement present

		  // Update per-verb streak
		  const id = v.id || `${v.lemma}_${v.english}`;
		  const cur = verbsState.streaks[id] || 0;
		  verbsState.streaks[id] = allOK ? Math.min(3, cur + 1) : 0;

		  // Unlock next levels if needed
		  maybeUnlockNextVerbsLevel();
		  saveVerbsState();

		  // Feedback
		  elFeedback.textContent = allOK
			? `âœ… Perfect! Streak for "${v.lemma}" is now ${verbsState.streaks[id]}/3.`
			: `âŒ Not quite. Streak for "${v.lemma}" reset to 0.`;
			updateLevelIndicator();


		  // Optional global hook (if you had one)
		  try {
			if (typeof updateStreak === 'function') {
			  updateStreak({ mode: 'verbs', passed: allOK, correctFields: allOK?total:0, totalFields: total });
			}
		  } catch(_) {}
		}

        
        /* Unlock logic identical shape to your vocab levels */
        function allVerbsInCurrentLevelComplete(){
          const need = verbsState.level * 25;
          const ids = verbsState.data.slice(0, Math.min(need, verbsState.data.length)).map(v=>v.id);
          return ids.length>0 && ids.every(id => (verbsState.streaks[id]||0) >= 3);
        }
        function maybeUnlockNextVerbsLevel(){
          if (allVerbsInCurrentLevelComplete()){
            verbsState.level += 1;
            verbsState.unlocked = Math.min(verbsState.level * 25, verbsState.data.length);
            // You can show a toast here if you have one
          }
        }
        
        /* Navigation */
        function nextVerb(){
          // Prefer items that are < 3 streak within unlocked set
          const pool = verbsState.data.slice(0, Math.min(verbsState.unlocked, verbsState.data.length));
          if (pool.length===0) return;
        
          let nextIdx = (verbsState.index + 1) % pool.length;
        
          // Try to find a verb with streak < 3
          const start = nextIdx;
          do {
            const id = pool[nextIdx].id;
            if ((verbsState.streaks[id]||0) < 3) break;
            nextIdx = (nextIdx + 1) % pool.length;
          } while(nextIdx !== start);
        
          verbsState.index = nextIdx;
          saveVerbsState();
          chosenAux = null;
          renderVerbsCard();
        }
        
        /* Wire buttons */
        elCheck?.addEventListener('click', checkVerbsCard);
        elNext ?.addEventListener('click', nextVerb);
        
        /* Boot */
        (async function initVerbs(){
          document.body.classList.add('dark'); // enables black mode
          
          await loadVerbsData();
          initVerbsState();
          renderMode();
		  updateLevelIndicator();

        
          // If first time and no mode saved, keep your site behavior (vocab default).
          if (!localStorage.getItem(MODE_KEY)) localStorage.setItem(MODE_KEY, 'vocab');
        
          if (getMode() === 'verbs') renderVerbsCard();
        
          // Re-render verbs card whenever switching to verbs mode
          const obs = new MutationObserver(()=>{ if(getMode()==='verbs') renderVerbsCard(); });
          obs.observe(document.getElementById('mode-switch'), { attributes:true, childList:true, subtree:true });
        })();

       
     /* ============================================
     Adjectives & Adverbs (Adj/Adv) â€” simple trainer
     ============================================= */
        
        /* LocalStorage keys */
        const ADJADV_LEVEL_KEY   = 'adjadv_level';
        const ADJADV_UNLOCKED_KEY= 'adjadv_unlocked_count';
        const ADJADV_INDEX_KEY   = 'adjadv_index';
        const ADJADV_STREAKS_KEY = 'adjadv_streaks';
        
        /* State */
        const adjadvState = {
          data: [],     // {id, english, german, example}
          index: 0,
          level: 1,     // 25 per level
          unlocked: 25,
          streaks: {}   // id -> 0..3
        };
        
        /* DOM refs */
        const elAdjAdvCard   = document.getElementById('adjadv-card');
        const elAdjAdvEn     = document.getElementById('adjadv-english');
        const elAdjAdvDe     = document.getElementById('adjadv-german');
        const elAdjAdvEx     = document.getElementById('adjadv-example');
        const elAdjAdvCheck  = document.getElementById('adjadv-check');
        const elAdjAdvNext   = document.getElementById('adjadv-next');
        const elAdjAdvFb     = document.getElementById('adjadv-feedback');
        
        /* Helpers */
        function aa_lsGet(key, fallback){ try{const v=localStorage.getItem(key); return v?JSON.parse(v):fallback;}catch{ return fallback; } }
        function aa_lsSet(key, val){ try{ localStorage.setItem(key, JSON.stringify(val)); }catch{} }
        function aa_lsGetInt(key, fallback){ const v=localStorage.getItem(key); const n=v===null?NaN:parseInt(v,10); return Number.isFinite(n)?n:fallback; }
        function aa_lsSetInt(key, n){ try{ localStorage.setItem(key, String(n)); }catch{} }
        function aa_norm(s){ return (s||'').trim().toLowerCase().replaceAll('ÃŸ','ss').replaceAll('Ã¤','ae').replaceAll('Ã¶','oe').replaceAll('Ã¼','ue'); }
        
        function aa_initState(){
          adjadvState.level    = aa_lsGetInt(ADJADV_LEVEL_KEY, 1);
          adjadvState.unlocked = aa_lsGetInt(ADJADV_UNLOCKED_KEY, 25);
          adjadvState.index    = aa_lsGetInt(ADJADV_INDEX_KEY, 0);
          adjadvState.streaks  = aa_lsGet(ADJADV_STREAKS_KEY, {});
        }
        function aa_saveState(){
          aa_lsSetInt(ADJADV_LEVEL_KEY, adjadvState.level);
          aa_lsSetInt(ADJADV_UNLOCKED_KEY, adjadvState.unlocked);
          aa_lsSetInt(ADJADV_INDEX_KEY, adjadvState.index);
          aa_lsSet(ADJADV_STREAKS_KEY, adjadvState.streaks);
        }
        
        /* Load data from adjadv.csv (english,german,example) */
        async function aa_loadData(){
          try{
            const res = await fetch('adjadv.csv', { cache:'no-store' });
            if(res.ok){
              const csv = await res.text();
              const rows = parseCSV(csv); // we reuse the verbs parseCSV helper
              // Expect headers: english,german,example
              // If user CSV has headers, parseCSV returns objects already.
              // But our parseCSV returns array-of-objects only when a header line exists.
              // So handle both cases:
              if(Array.isArray(rows) && rows.length && typeof rows[0]==='object' && rows[0].english!==undefined){
                adjadvState.data = rows.map((r,i)=>({
                  id: r.id || ('aa_'+(r.german||r.english||('i'+i)).replace(/\s+/g,'_')+'_'+i),
                  english: r.english || '',
                  german:  r.german  || '',
                  example: r.example || ''
                }));
              } else {
                // Simple fallback if the CSV had no header or parse failed:
                adjadvState.data = [
                  { id:'aa001', english:'beautiful', german:'schÃ¶n', example:'Das ist ein schÃ¶nes Haus.' },
                  { id:'aa002', english:'slow',      german:'langsam', example:'Er fÃ¤hrt langsam.' },
                  { id:'aa003', english:'quickly',   german:'schnell', example:'Sie lÃ¤uft schnell.' },
                  { id:'aa004', english:'angry',     german:'wÃ¼tend', example:'Er ist sehr wÃ¼tend.' },
                  { id:'aa005', english:'carefully', german:'vorsichtig', example:'Er arbeitet vorsichtig.' },
                ];
              }
            } else {
              // No CSV file -> use small demo list
              adjadvState.data = [
                { id:'aa001', english:'beautiful', german:'schÃ¶n', example:'Das ist ein schÃ¶nes Haus.' },
                { id:'aa002', english:'slow',      german:'langsam', example:'Er fÃ¤hrt langsam.' },
                { id:'aa003', english:'quickly',   german:'schnell', example:'Sie lÃ¤uft schnell.' },
              ];
            }
          } catch {
            adjadvState.data = [
              { id:'aa001', english:'beautiful', german:'schÃ¶n', example:'Das ist ein schÃ¶nes Haus.' },
              { id:'aa002', english:'slow',      german:'langsam', example:'Er fÃ¤hrt langsam.' },
            ];
          }
        }
        
        /* Current item helpers */
        function aa_pool(){
          return adjadvState.data.slice(0, Math.min(adjadvState.unlocked, adjadvState.data.length));
        }
        function aa_current(){
          const p = aa_pool(); if(!p.length) return null;
          const i = Math.max(0, Math.min(adjadvState.index % p.length, p.length-1));
          return p[i];
        }
        
        /* Render & actions */
        function aa_clearStyles(){ elAdjAdvDe?.classList.remove('result-ok','result-bad'); }
        function aa_render(){
          const it = aa_current();
          if(!it){ elAdjAdvCard.hidden = true; return; }
          aa_clearStyles();
          elAdjAdvCard.hidden = false;
          elAdjAdvEn.textContent = it.english || '';
          elAdjAdvDe.value = '';
          elAdjAdvEx.textContent = it.example ? 'ðŸ“ ' + it.example : '';
          elAdjAdvFb.textContent = '';
          setTimeout(()=>{ elAdjAdvDe?.focus(); }, 0);
        }
        
        function aa_allInLevelMastered(){
          const need = adjadvState.level * 25;
          const ids = adjadvState.data.slice(0, Math.min(need, adjadvState.data.length)).map(x=>x.id);
          return ids.length>0 && ids.every(id => (adjadvState.streaks[id]||0) >= 3);
        }
        function aa_maybeUnlockNext(){
          if(aa_allInLevelMastered()){
            adjadvState.level += 1;
            adjadvState.unlocked = Math.min(adjadvState.level * 25, adjadvState.data.length);
          }
        }
        
        function aa_check(){
          const it = aa_current(); if(!it) return;
          const ok = aa_norm(elAdjAdvDe.value) === aa_norm(it.german);
          elAdjAdvDe.classList.add(ok ? 'result-ok' : 'result-bad');
          const cur = adjadvState.streaks[it.id] || 0;
          adjadvState.streaks[it.id] = ok ? Math.min(3, cur+1) : 0;
          aa_maybeUnlockNext();
          aa_saveState();
          elAdjAdvFb.textContent = ok
            ? `âœ… Correct! Streak for "${it.german}" is now ${adjadvState.streaks[it.id]}/3.`
            : `âŒ Wrong. Correct: ${it.german}`;
        }
        function aa_next(){
          const p = aa_pool(); if(!p.length) return;
          // Prefer items with streak < 3
          let next = (adjadvState.index + 1) % p.length;
          const start = next;
          do{
            const id = p[next].id;
            if ((adjadvState.streaks[id]||0) < 3) break;
            next = (next + 1) % p.length;
          }while(next !== start);
          adjadvState.index = next;
          aa_saveState();
          aa_render();
        }
        
        /* Wire buttons */
        elAdjAdvCheck?.addEventListener('click', aa_check);
        elAdjAdvNext ?.addEventListener('click', ()=>{
          aa_next();
          // if MIX mode, after moving within this pool, switch to a random section
          if (getMode()==='mix') pickRandomSectionAndRender();
        });
        elAdjAdvDe?.addEventListener('keydown', (e)=>{
          if(e.key==='Enter'){ e.preventDefault(); aa_check(); }
        });
        
        /* ===== Mix integration =====
           When in MIX, we show one section at a time (vocab/verbs/adjadv).
           - On entering MIX -> pick random section and render.
           - On any "Next" click of the visible section -> advance that pool, then randomly switch section.
        */
        const MIX_SECTIONS = ['vocab','verbs','adjadv'];
        function pickRandomSection(){
          return MIX_SECTIONS[Math.floor(Math.random()*MIX_SECTIONS.length)];
        }
        function showOnly(section){ // hide/show sections
          const vocab = document.getElementById('vocab-wrapper');
          const verbs = document.getElementById('verbs-card');
          const adjad = document.getElementById('adjadv-card');
          if (section==='vocab'){
            if(vocab) vocab.style.display='';
            if(verbs) verbs.hidden=true;
            if(adjad) adjad.hidden=true;
          } else if (section==='verbs'){
            if(vocab) vocab.style.display='none';
            if(verbs) verbs.hidden=false;
            if(adjad) adjad.hidden=true;
          } else if (section==='adjadv'){
            if(vocab) vocab.style.display='none';
            if(verbs) verbs.hidden=true;
            if(adjad) adjad.hidden=false;
          }
        }
        function renderForSection(section){
          if (section==='vocab'){
            // reuse your existing nextWord() to ensure a word is visible
            try { nextWord(); } catch {}
          } else if (section==='verbs'){
            try { renderVerbsCard(); } catch {}
          } else if (section==='adjadv'){
            aa_render();
          }
          showOnly(section);
        }
        function pickRandomSectionAndRender(){
          const s = pickRandomSection();
          renderForSection(s);
        }
        
        /* Extend existing renderMode to include adjadv + mix */
        const _origRenderMode = renderMode;
        renderMode = function(){
          _origRenderMode(); // keeps original show/hide for vocab & verbs
          const mode = getMode();
        
          const vocab = document.getElementById('vocab-wrapper');
          const verbs = document.getElementById('verbs-card');
          const adjad = document.getElementById('adjadv-card');
        
          // Show Adj/Adv only in "adjadv" mode
          if (adjad) adjad.hidden = !(mode==='adjadv' || mode==='mix');
        
          // For "vocab": (keep original) -> vocab visible, others hidden by original code
          // For "verbs": (keep original) -> verbs visible
          // For "adjadv": hide vocab & verbs, show adjadv
          if (mode==='adjadv'){
            if(vocab) vocab.style.display='none';
            if(verbs) verbs.hidden = true;
            if(adjad) { adjad.hidden = false; aa_render(); }
          }
        
          // For "mix": pick one section randomly and render only that
          if (mode==='mix'){
            const section = pickRandomSection();
            renderForSection(section);
        
            // Also tweak each card's Next to jump to a new random section after it advances:
            // (Vocab) â€” hook its Next button (id="nextBtn")
            const vbNext = document.getElementById('nextBtn');
            if (vbNext && !vbNext._mixHooked){
              vbNext._mixHooked = true;
              const orig = vbNext.onclick;
              vbNext.addEventListener('click', ()=>{
                setTimeout(()=>{ if(getMode()==='mix') pickRandomSectionAndRender(); }, 0);
              });
            }
            // (Verbs) â€” already hooked above in elNext listener (added set for mix)
            // (Adj/Adv) â€” already hooked above in elAdjAdvNext listener
          }
        };
        
        /* Boot Adj/Adv together with verbs init */
        (async function initAdjAdv(){
          await aa_loadData();
          aa_initState();
          // If user switches to adjadv later, aa_render() will run via renderMode().
        })();
   

  </script>
  
  <script>
    /* ============================================
       Prepositions Trainer â€” type the preposition (no +Akk/+Dat)
       CSV: prepositions.csv
       Columns: german_sentence,english_translation,correct_prep,options
       - Put "___" where the blank is in the German sentence.
       - correct_prep: just the word (e.g., "auf", "bei").
       - options (optional): "auf;an;bei"
    ============================================ */
    
    const PREPS_LEVEL_KEY    = 'preps_level';
    const PREPS_UNLOCKED_KEY = 'preps_unlocked_count';
    const PREPS_INDEX_KEY    = 'preps_index';
    const PREPS_STREAKS_KEY  = 'preps_streaks';
    
    const prepsState = { data: [], index: 0, level: 1, unlocked: 25, streaks: {} };
    
    const elPrepsCard   = document.getElementById('preps-card');
    const elPrepsSentence = document.getElementById('preps-sentence');
    const elPrepsEn     = document.getElementById('preps-english');
    const elPrepsCheck  = document.getElementById('preps-check');
    const elPrepsNext   = document.getElementById('preps-next');
    const elPrepsFb     = document.getElementById('preps-feedback');
    
    function pp_lsGet(key, fallback){ try{const v=localStorage.getItem(key); return v?JSON.parse(v):fallback;}catch{ return fallback; } }
    function pp_lsSet(key, val){ try{ localStorage.setItem(key, JSON.stringify(val)); }catch{} }
    function pp_lsGetInt(key, fallback){ const v=localStorage.getItem(key); const n=v===null?NaN:parseInt(v,10); return Number.isFinite(n)?n:fallback; }
    function pp_lsSetInt(key, n){ try{ localStorage.setItem(key, String(n)); }catch{} }
    function pp_norm(s){ return (s||'').trim().toLowerCase().replaceAll('ÃŸ','ss').replaceAll('Ã¤','ae').replaceAll('Ã¶','oe').replaceAll('Ã¼','ue'); }
    
    function pp_initState(){
      prepsState.level    = pp_lsGetInt(PREPS_LEVEL_KEY, 1);
      prepsState.unlocked = pp_lsGetInt(PREPS_UNLOCKED_KEY, 25);
      prepsState.index    = pp_lsGetInt(PREPS_INDEX_KEY, 0);
      prepsState.streaks  = pp_lsGet(PREPS_STREAKS_KEY, {});
    }
    function pp_saveState(){
      pp_lsSetInt(PREPS_LEVEL_KEY, prepsState.level);
      pp_lsSetInt(PREPS_UNLOCKED_KEY, prepsState.unlocked);
      pp_lsSetInt(PREPS_INDEX_KEY, prepsState.index);
      pp_lsSet(PREPS_STREAKS_KEY, prepsState.streaks);
    }
    
    /* Load data */
    async function pp_loadData(){
      let rows = null;
      try{
        const res = await fetch('prepositions.csv', { cache:'no-store' });
        if(res.ok){
          const csv = await res.text();
          rows = pp_parseCSVtoObjects(csv);
        }
      }catch(_){}
      if(!rows || !rows.length){
        // Safe demo items if CSV missing
        rows = [
          { german_sentence:'Ich warte ___ den Bus.', english_translation:'I am waiting for the bus.', correct_prep:'auf', options:'auf;an;bei' },
          { german_sentence:'Er interessiert sich ___ Musik.', english_translation:'He is interested in music.', correct_prep:'fÃ¼r', options:'fÃ¼r;bei;mit' },
          { german_sentence:'Wir sprechen ___ das Problem.', english_translation:'We are talking about the problem.', correct_prep:'Ã¼ber', options:'Ã¼ber;auf;mit' },
        ];
      }
      prepsState.data = rows.map((r,i)=>({
        id: 'pp_' + (r.german_sentence || 'row_'+i).replace(/\s+/g,'_') + '_' + i,
        de: r.german_sentence || '',
        en: r.english_translation || '',
        correct: (r.correct_prep || '').trim(),
        options: (r.options || '').split(';').map(s=>s.trim()).filter(Boolean)
      }));
    }
    
    /* CSV to objects */
    function pp_parseCSVtoObjects(text){
      const lines = text.trim().split(/\r?\n/);
      if(!lines.length) return [];
      const headers = lines[0].split(',').map(h=>h.trim());
      return lines.slice(1).map(line=>{
        const cells = []; let cur = '', inQ=false;
        for(let i=0;i<line.length;i++){
          const ch=line[i];
          if(ch === '"'){ inQ = !inQ; continue; }
          if(ch === ',' && !inQ){ cells.push(cur); cur=''; continue; }
          cur += ch;
        }
        cells.push(cur);
        const obj={};
        headers.forEach((h,i)=> obj[h] = (cells[i]||'').trim());
        return obj;
      });
    }
    
    function pp_pool(){ return prepsState.data.slice(0, Math.min(prepsState.unlocked, prepsState.data.length)); }
    function pp_current(){
      const p = pp_pool(); if(!p.length) return null;
      const i = Math.max(0, Math.min(prepsState.index % p.length, p.length-1));
      return p[i];
    }
    
    /* Render sentence with inline input */
    function pp_render(){
      const it = pp_current();
      if(!it){ elPrepsCard.hidden = true; return; }
      elPrepsCard.hidden = false;
      elPrepsFb.textContent = '';
      elPrepsEn.textContent = it.en ? ('ðŸ“ ' + it.en) : '';
    
      const parts = (it.de || '').split('___');
      const left = parts[0] || '';
      const right = parts[1] || '';
    
      const input = document.createElement('input');
      input.id = 'preps-input';
      input.setAttribute('list', 'preps-options');
      input.setAttribute('autocomplete', 'off');
      input.placeholder = 'auf';
      input.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); pp_check(); } });
    
      if (it.options && it.options.length){
        const dlId = 'preps-options-dyn';
        let dl = document.getElementById(dlId);
        if(!dl){
          dl = document.createElement('datalist');
          dl.id = dlId;
          document.body.appendChild(dl);
        }
        dl.innerHTML = it.options.map(o=>`<option value="${o}"></option>`).join('');
        input.setAttribute('list', dlId);
      } else {
        input.setAttribute('list', 'preps-options');
      }
    
      elPrepsSentence.innerHTML = '';
      elPrepsSentence.append(document.createTextNode(left), input, document.createTextNode(right));
      setTimeout(()=>{ input.focus(); }, 0);
    }
    
    function pp_allInLevelMastered(){
      const need = prepsState.level * 25;
      const ids = prepsState.data.slice(0, Math.min(need, prepsState.data.length)).map(x=>x.id);
      return ids.length>0 && ids.every(id => (prepsState.streaks[id]||0) >= 3);
    }
    function pp_maybeUnlockNext(){
      if(pp_allInLevelMastered()){
        prepsState.level += 1;
        prepsState.unlocked = Math.min(prepsState.level * 25, prepsState.data.length);
      }
    }
    
    function pp_check(){
      const it = pp_current(); if(!it) return;
      const input = document.getElementById('preps-input');
      const val = (input?.value || '').trim();
      const ok = pp_norm(val) === pp_norm(it.correct.split(' ')[0]); // only the word
      input?.classList.remove('result-ok','result-bad');
      input?.classList.add(ok ? 'result-ok' : 'result-bad');
    
      const cur = prepsState.streaks[it.id] || 0;
      prepsState.streaks[it.id] = ok ? Math.min(3, cur+1) : 0;
      pp_maybeUnlockNext();
      pp_saveState();
    
      elPrepsFb.textContent = ok
        ? `âœ… Correct! Streak now ${prepsState.streaks[it.id]}/3.`
        : `âŒ Wrong. Correct: ${it.correct}`;
    }
    
    function pp_next(){
      const p = pp_pool(); if(!p.length) return;
      let next = (prepsState.index + 1) % p.length;
      const start = next;
      do{
        const id = p[next].id;
        if ((prepsState.streaks[id]||0) < 3) break;
        next = (next + 1) % p.length;
      }while(next !== start);
      prepsState.index = next;
      pp_saveState();
      pp_render();
    }
    
    /* Buttons */
    elPrepsCheck?.addEventListener('click', pp_check);
    elPrepsNext ?.addEventListener('click', pp_next);
    
    /* Load + init */
    (async function initPreps(){
      await pp_loadData();
      pp_initState();
    })();
    
    /* Hook into your renderMode() so 'preps' shows the card */
    const _renderMode_preps = renderMode;  // keep previous behavior (vocab/verbs/adjadv/mix)
    renderMode = function(){
      _renderMode_preps();
    
      const mode = getMode();
      const vocab = document.getElementById('vocab-wrapper');
      const verbs = document.getElementById('verbs-card');
      const adjad = document.getElementById('adjadv-card');
      const preps = document.getElementById('preps-card');
    
      if (mode === 'preps'){
        if (vocab) vocab.style.display = 'none';
        if (verbs) verbs.hidden = true;
        if (adjad) adjad.hidden = true;
        if (preps) { preps.hidden = false; pp_render(); }
      } else {
        if (preps) preps.hidden = true;
      }
    };
  </script>


  
</body>
</html>
